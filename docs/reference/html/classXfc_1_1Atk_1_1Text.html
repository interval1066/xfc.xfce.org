<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1Atk.html">Atk</a>::<a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a></div>
<h1>Xfc::Atk::Text Class Reference</h1><!-- doxytag: class="Xfc::Atk::Text" --><!-- doxytag: inherits="Xfc::G::TypeInterface" -->A AtkText C++ wrapper class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/atk/text.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::Atk::Text:
<p><center><img src="classXfc_1_1Atk_1_1Text.png" usemap="#Xfc::Atk::Text_map" border="0" alt=""></center>
<map name="Xfc::Atk::Text_map">
<area href="classXfc_1_1G_1_1TypeInterface.html" alt="Xfc::G::TypeInterface" shape="rect" coords="0,112,131,136">
<area href="classXfc_1_1G_1_1TypeInstance.html" alt="Xfc::G::TypeInstance" shape="rect" coords="0,56,131,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,131,24">
</map>
<a href="classXfc_1_1Atk_1_1Text-members.html">List of all members.</a><h2>Signal Prototypes</h2>
<ul>
<li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">TextChangedSignalType</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#057ca0f3217a574b402f3f90ef5ac267">text_changed_signal</a>
<dl class="el"><dd class="mdescRight"><a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> changed signal (see signal_text_change()).  <a href="#057ca0f3217a574b402f3f90ef5ac267"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">TextCaretMovedSignalType</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#c7261397adb4377a8c5e825426a186e2">text_caret_moved_signal</a>
<dl class="el"><dd class="mdescRight"><a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> caret moved signal (see <a class="el" href="classXfc_1_1Atk_1_1Text.html#cbd809785d9124c81823a486e188879e">signal_text_caret_moved()</a>).  <a href="#c7261397adb4377a8c5e825426a186e2"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">TextSelectionChangedSignalType</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#604da5af7675e6b7302b049adf6f51db">text_selection_changed_signal</a>
<dl class="el"><dd class="mdescRight"><a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> selection changed signal (see <a class="el" href="classXfc_1_1Atk_1_1Text.html#c6e7fd343a1a6437f0302e8ea2f75452">signal_text_selection_changed()</a>).  <a href="#604da5af7675e6b7302b049adf6f51db"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">TextAttributesChangedSignalType</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#73b2db87f2e550cf222dc05deb8ca2de">text_attributes_changed_signal</a>
<dl class="el"><dd class="mdescRight"><a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> attributes changed signal (see <a class="el" href="classXfc_1_1Atk_1_1Text.html#ff4ab14c40b11da09315f67276eb992b">signal_text_attributes_changed()</a>).  <a href="#73b2db87f2e550cf222dc05deb8ca2de"></a><br></dl></ul>
<h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="befa72a6ddf5aa42dde74961ab2b2e8a"></a><!-- doxytag: member="Xfc::Atk::Text::atk_text" ref="befa72a6ddf5aa42dde74961ab2b2e8a" args="() const" -->
AtkText * <a class="el" href="classXfc_1_1Atk_1_1Text.html#befa72a6ddf5aa42dde74961ab2b2e8a">atk_text</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the AtkText structure. <br></dl><li><a class="anchor" name="da87dcb4c68c35471bb3b9c0caa2d742"></a><!-- doxytag: member="Xfc::Atk::Text::operator AtkText *" ref="da87dcb4c68c35471bb3b9c0caa2d742" args="() const" -->
<a class="el" href="classXfc_1_1Atk_1_1Text.html#da87dcb4c68c35471bb3b9c0caa2d742">operator AtkText *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; safely converts a <a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> to an AtkText pointer. <br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#999e62ac4f97d6d5b11c4b7dfce8fd47">get_text</a> (int start_offset, int end_offset) const
<dl class="el"><dd class="mdescRight">Gets the specified text.  <a href="#999e62ac4f97d6d5b11c4b7dfce8fd47"></a><br></dl><li><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#82229b87947dc37244d128cd7d5936b3">get_character_at_offset</a> (int offset) const
<dl class="el"><dd class="mdescRight">Gets the character at the specified offset.  <a href="#82229b87947dc37244d128cd7d5936b3"></a><br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#bc136f739ad39c5e6157b5d187d73493">get_text_after_offset</a> (int offset, <a class="el" href="namespaceXfc_1_1Atk.html#4d9d9a6d80eecc1259f4fc3ca8513f54">TextBoundary</a> boundary_type, int *start_offset, int *end_offset) const 
<dl class="el"><dd class="mdescRight">Gets the specified text.  <a href="#bc136f739ad39c5e6157b5d187d73493"></a><br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#f83c87ab176e32d88f068fd9dfa2119e">get_text_at_offset</a> (int offset, <a class="el" href="namespaceXfc_1_1Atk.html#4d9d9a6d80eecc1259f4fc3ca8513f54">TextBoundary</a> boundary_type, int *start_offset, int *end_offset) const 
<dl class="el"><dd class="mdescRight">Gets the specified text.  <a href="#f83c87ab176e32d88f068fd9dfa2119e"></a><br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#19bde8130e7220949499fd18230db786">get_text_before_offset</a> (int offset, <a class="el" href="namespaceXfc_1_1Atk.html#4d9d9a6d80eecc1259f4fc3ca8513f54">TextBoundary</a> boundary_type, int *start_offset, int *end_offset) const 
<dl class="el"><dd class="mdescRight">Gets the specified text.  <a href="#19bde8130e7220949499fd18230db786"></a><br></dl><li><a class="anchor" name="fd77a0bcd8e678a8d42b5d8746a76f26"></a><!-- doxytag: member="Xfc::Atk::Text::get_caret_offset" ref="fd77a0bcd8e678a8d42b5d8746a76f26" args="() const" -->
int <a class="el" href="classXfc_1_1Atk_1_1Text.html#fd77a0bcd8e678a8d42b5d8746a76f26">get_caret_offset</a> () const
<dl class="el"><dd class="mdescRight">Returns the offset position of the caret (cursor). <br></dl><li>void <a class="el" href="classXfc_1_1Atk_1_1Text.html#209ae0064d63efcdc1a94c6063ec63ab">get_character_extents</a> (int offset, int *x, int *y, int *width, int *height, <a class="el" href="namespaceXfc_1_1Atk.html#aff9b04c77fa3853d95df3438bffd41b">CoordType</a> coords) const
<dl class="el"><dd class="mdescRight">Given an offset, the x, y, width, and height values are filled appropriately.  <a href="#209ae0064d63efcdc1a94c6063ec63ab"></a><br></dl><li>std::vector&lt; <a class="el" href="classXfc_1_1Atk_1_1Attribute.html">Attribute</a> &gt; <a class="el" href="classXfc_1_1Atk_1_1Text.html#16c7b94daa9bfadf389e49462a963307">get_run_attributes</a> (int offset, int *start_offset, int *end_offset) const
<dl class="el"><dd class="mdescRight">Gets a list which consists of the attributes explicitly set at the position <em>offset</em> in the text.  <a href="#16c7b94daa9bfadf389e49462a963307"></a><br></dl><li>std::vector&lt; <a class="el" href="classXfc_1_1Atk_1_1Attribute.html">Attribute</a> &gt; <a class="el" href="classXfc_1_1Atk_1_1Text.html#683a853bbe4d378e9abacea0e4c0bf32">get_default_attributes</a> () const
<dl class="el"><dd class="mdescRight">Gets a list which consists of the default values of attributes for the text.  <a href="#683a853bbe4d378e9abacea0e4c0bf32"></a><br></dl><li>int <a class="el" href="classXfc_1_1Atk_1_1Text.html#b87a95440c18cf8d84c6f10fabb23b3b">get_character_count</a> () const
<dl class="el"><dd class="mdescRight">Gets the character count for the text.  <a href="#b87a95440c18cf8d84c6f10fabb23b3b"></a><br></dl><li>int <a class="el" href="classXfc_1_1Atk_1_1Text.html#7b57b0eea2810b71ba4a3f07c4a76a1e">get_offset_at_point</a> (int x, int y, <a class="el" href="namespaceXfc_1_1Atk.html#aff9b04c77fa3853d95df3438bffd41b">CoordType</a> coords) const
<dl class="el"><dd class="mdescRight">Gets the offset of the character located at coordinates x and y.  <a href="#7b57b0eea2810b71ba4a3f07c4a76a1e"></a><br></dl><li>int <a class="el" href="classXfc_1_1Atk_1_1Text.html#5dc6de1b4d87d72ae5ac693b5c1f4a27">get_n_selections</a> () const
<dl class="el"><dd class="mdescRight">Gets the number of selected regions.  <a href="#5dc6de1b4d87d72ae5ac693b5c1f4a27"></a><br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#40a486165cd798b574ba97853b6dd019">get_selection</a> (int selection_num, int *start_offset, int *end_offset) const
<dl class="el"><dd class="mdescRight">Gets the text from the specified selection.  <a href="#40a486165cd798b574ba97853b6dd019"></a><br></dl><li><a class="el" href="classXfc_1_1Atk_1_1TextRectangle.html">TextRectangle</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#83f9d32ccd65a019c797bce92041be78">get_range_extents</a> (int start_offset, int end_offset, <a class="el" href="namespaceXfc_1_1Atk.html#aff9b04c77fa3853d95df3438bffd41b">CoordType</a> coord_type)
<dl class="el"><dd class="mdescRight">Get the bounding box for text within the specified range.  <a href="#83f9d32ccd65a019c797bce92041be78"></a><br></dl><li>void <a class="el" href="classXfc_1_1Atk_1_1Text.html#184b21f0c1d03a9edf656d07e2e539e8">get_range_extents</a> (int start_offset, int end_offset, <a class="el" href="namespaceXfc_1_1Atk.html#aff9b04c77fa3853d95df3438bffd41b">CoordType</a> coord_type, <a class="el" href="classXfc_1_1Atk_1_1TextRectangle.html">TextRectangle</a> &amp;rect)
<dl class="el"><dd class="mdescRight">Get the bounding box for text within the specified range.  <a href="#184b21f0c1d03a9edf656d07e2e539e8"></a><br></dl><li>std::vector&lt; <a class="el" href="classXfc_1_1Atk_1_1TextRange.html">TextRange</a> &gt; <a class="el" href="classXfc_1_1Atk_1_1Text.html#622f1b08cdc7fa3ba5d6ad61bdd8f2cf">get_bounded_ranges</a> (const <a class="el" href="classXfc_1_1Atk_1_1TextRectangle.html">TextRectangle</a> &amp;rect, <a class="el" href="namespaceXfc_1_1Atk.html#aff9b04c77fa3853d95df3438bffd41b">CoordType</a> coord_type, <a class="el" href="namespaceXfc_1_1Atk.html#003a7fa83bf4b3346387e595a500885a">TextClipType</a> x_clip_type, <a class="el" href="namespaceXfc_1_1Atk.html#003a7fa83bf4b3346387e595a500885a">TextClipType</a> y_clip_type)
<dl class="el"><dd class="mdescRight">Get the ranges of text in the specified bounding box.  <a href="#622f1b08cdc7fa3ba5d6ad61bdd8f2cf"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>bool <a class="el" href="classXfc_1_1Atk_1_1Text.html#c28e244eb0a5ffab1609616f599307b0">add_selection</a> (int start_offset, int end_offset)
<dl class="el"><dd class="mdescRight">Adds the selection bounded by the specified offsets.  <a href="#c28e244eb0a5ffab1609616f599307b0"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Atk_1_1Text.html#497eb2570d4a0efa4f8d655839e03031">remove_selection</a> (int selection_num)
<dl class="el"><dd class="mdescRight">Removes the specified selection.  <a href="#497eb2570d4a0efa4f8d655839e03031"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Atk_1_1Text.html#b5b4fc09f1a8c5ce3cccd0421db11d7a">set_selection</a> (int selection_num, int start_offset, int end_offset)
<dl class="el"><dd class="mdescRight">Changes the start and end offset of the specified selection.  <a href="#b5b4fc09f1a8c5ce3cccd0421db11d7a"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Atk_1_1Text.html#90d1580d3931f1bb10b6b7fec985fd92">set_caret_offset</a> (int offset)
<dl class="el"><dd class="mdescRight">Sets the caret (cursor) position to the specified offset.  <a href="#90d1580d3931f1bb10b6b7fec985fd92"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Signal Proxies</div></td></tr>
<ul>
<li><a class="anchor" name="ebd032963b863a6d379e2b669d7038e6"></a><!-- doxytag: member="Xfc::Atk::Text::signal_text_changed" ref="ebd032963b863a6d379e2b669d7038e6" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">TextChangedSignalProxy</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#ebd032963b863a6d379e2b669d7038e6">signal_text_changed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the text_changed_signal; emitted when text is inserted or deleted. <br></dl><li><a class="anchor" name="cbd809785d9124c81823a486e188879e"></a><!-- doxytag: member="Xfc::Atk::Text::signal_text_caret_moved" ref="cbd809785d9124c81823a486e188879e" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">TextCaretMovedSignalProxy</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#cbd809785d9124c81823a486e188879e">signal_text_caret_moved</a> ()
<dl class="el"><dd class="mdescRight">Connect to the text_caret_moved_signal; emitted when the text caret is moved. <br></dl><li><a class="anchor" name="c6e7fd343a1a6437f0302e8ea2f75452"></a><!-- doxytag: member="Xfc::Atk::Text::signal_text_selection_changed" ref="c6e7fd343a1a6437f0302e8ea2f75452" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">TextSelectionChangedSignalProxy</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#c6e7fd343a1a6437f0302e8ea2f75452">signal_text_selection_changed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the text_selection_changed_signal; emitted when the text selection changes. <br></dl><li><a class="anchor" name="ff4ab14c40b11da09315f67276eb992b"></a><!-- doxytag: member="Xfc::Atk::Text::signal_text_attributes_changed" ref="ff4ab14c40b11da09315f67276eb992b" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">TextAttributesChangedSignalProxy</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#ff4ab14c40b11da09315f67276eb992b">signal_text_attributes_changed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the text_attributes_changed_signal; emitted when the text attributes change. <br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A AtkText C++ wrapper class. 
<p>
<a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> should be implemented by Atk::Objects on behalf of widgets that have text content which is either attributed or otherwise non-trivial. Atk::Objects whose text content is simple, unattributed, and very brief may expose that content via <a class="el" href="classXfc_1_1Atk_1_1Object.html#834e9431585ad37e6a5f0159c000b9c8">Atk::Object::get_name()</a> instead; however if the text is editable, multi-line, typically longer than three or four words, attributed, selectable, or if the object already uses the 'name' ATK property for other information, the <a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> interface should be used to expose the text content. In the case of editable text content, <a class="el" href="classXfc_1_1Atk_1_1EditableText.html">EditableText</a> (a subtype of the <a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> interface) should be implemented instead.<p>
<a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> provides not only traversal facilities and change notification for text content, but also caret tracking and glyph bounding box calculations. Note that the text strings are exposed as UTF-8, and are therefore potentially multi-byte, and caret-to-byte offset mapping makes no assumptions about the character length; also bounding box glyph-to-offset mapping may be complex for languages which use ligatures. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="999e62ac4f97d6d5b11c4b7dfce8fd47"></a><!-- doxytag: member="Xfc::Atk::Text::get_text" ref="999e62ac4f97d6d5b11c4b7dfce8fd47" args="(int start_offset, int end_offset) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Atk::Text::get_text           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>end_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the specified text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_offset</em>&nbsp;</td><td>The start position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_offset</em>&nbsp;</td><td>The end position. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The text from <em>start_offset</em> up to, but not including <em>end_offset</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="82229b87947dc37244d128cd7d5936b3"></a><!-- doxytag: member="Xfc::Atk::Text::get_character_at_offset" ref="82229b87947dc37244d128cd7d5936b3" args="(int offset) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> Xfc::Atk::Text::get_character_at_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the character at the specified offset. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The character position. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The character at <em>offset</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc136f739ad39c5e6157b5d187d73493"></a><!-- doxytag: member="Xfc::Atk::Text::get_text_after_offset" ref="bc136f739ad39c5e6157b5d187d73493" args="(int offset, TextBoundary boundary_type, int *start_offset, int *end_offset) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Atk::Text::get_text_after_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Atk.html#4d9d9a6d80eecc1259f4fc3ca8513f54">TextBoundary</a>&nbsp;</td>
          <td class="paramname"> <em>boundary_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>end_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the specified text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The position </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boundary_type</em>&nbsp;</td><td>A TextBoundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_offset</em>&nbsp;</td><td>The location for the start offset of the returned string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_offset</em>&nbsp;</td><td>The location for the end offset of the returned string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The text after offset bounded by the specified boundary_type.</dd></dl>
If <em>boundary_type</em> is TEXT_BOUNDARY_CHAR the character after the offset is returned.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_WORD_START the returned string is from the word start after the offset to the next word start. The returned string will contain the word after the offset if the offset is inside a word or if the offset is not inside a word.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_WORD_END the returned string is from the word end at or after the offset to the next work end. The returned string will contain the word after the offset if the offset is inside a word and will contain the word after the word after the offset if the offset is not inside a word.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_SENTENCE_START the returned string is from the sentence start after the offset to the next sentence start. The returned string will contain the sentence after the offset if the offset is inside a sentence or if the offset is not inside a sentence.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_SENTENCE_END the returned string is from the sentence end at or after the offset to the next sentence end. The returned string will contain the sentence after the offset if the offset is inside a sentence and will contain the sentence after the sentence after the offset if the offset is not inside a sentence.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_LINE_START the returned string is from the line start after the offset to the next line start.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_LINE_END the returned string is from the line end at or after the offset to the next line start. 
</div>
</div><p>
<a class="anchor" name="f83c87ab176e32d88f068fd9dfa2119e"></a><!-- doxytag: member="Xfc::Atk::Text::get_text_at_offset" ref="f83c87ab176e32d88f068fd9dfa2119e" args="(int offset, TextBoundary boundary_type, int *start_offset, int *end_offset) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Atk::Text::get_text_at_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Atk.html#4d9d9a6d80eecc1259f4fc3ca8513f54">TextBoundary</a>&nbsp;</td>
          <td class="paramname"> <em>boundary_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>end_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the specified text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The position </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boundary_type</em>&nbsp;</td><td>A TextBoundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_offset</em>&nbsp;</td><td>The location for the start offset of the returned string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_offset</em>&nbsp;</td><td>The location for the end offset of the returned string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The text after offset bounded by the specified boundary_type.</dd></dl>
If <em>boundary_type</em> is TEXT_BOUNDARY_CHAR the character at the offset is returned.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_WORD_START the returned string is from the word start at or before the offset to the word start after the offset. The returned string will contain the word at the offset if the offset is inside a word and will contain the word before the offset if the offset is not inside a word.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_WORD_END the returned string is from the word end before the offset to the word end at or after the offset. The returned string will contain the word at the offset if the offset is inside a word and will contain the word after to the offset if the offset is not inside a word.<p>
If <em>boundary_type</em>e is TEXT_BOUNDARY_SENTENCE_START the returned string is from the sentence start at or before the offset to the sentence start after the offset. The returned string will contain the sentence at the offset if the offset is inside a sentence and will contain the sentence before the offset if the offset is not inside a sentence.<p>
If <em>boundary_type</em> is ATK_TEXT_BOUNDARY_SENTENCE_END the returned string is from the sentence end before the offset to the sentence end at or after the offset. The returned string will contain the sentence at the offset if the offset is inside a sentence and will contain the sentence after the offset if the offset is not inside a sentence.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_LINE_START the returned string is from the line start at or before the offset to the line start after the offset.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_LINE_END the returned string is from the line end before the offset to the line end at or after the offset. 
</div>
</div><p>
<a class="anchor" name="19bde8130e7220949499fd18230db786"></a><!-- doxytag: member="Xfc::Atk::Text::get_text_before_offset" ref="19bde8130e7220949499fd18230db786" args="(int offset, TextBoundary boundary_type, int *start_offset, int *end_offset) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Atk::Text::get_text_before_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Atk.html#4d9d9a6d80eecc1259f4fc3ca8513f54">TextBoundary</a>&nbsp;</td>
          <td class="paramname"> <em>boundary_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>end_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the specified text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The position </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boundary_type</em>&nbsp;</td><td>A TextBoundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_offset</em>&nbsp;</td><td>The location for the start offset of the returned string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_offset</em>&nbsp;</td><td>The location for the end offset of the returned string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The text after offset bounded by the specified boundary_type.</dd></dl>
If the boundary_type is TEXT_BOUNDARY_CHAR the character before the offset is returned.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_WORD_START the returned string is from the word start before the word start before the offset to the word start before the offset. The returned string will contain the word before the offset if the offset is inside a word and will contain the word before the word before the offset if the offset is not inside a word.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_WORD_END the returned string is from the word end before the word end at or before the offset to the word end at or before the offset. The returned string will contain the word before the offset if the offset is inside a word or if the offset is not inside a word.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_SENTENCE_START the returned string is from the sentence start before the sentence start before the offset to the sentence start before the offset. The returned string will contain the sentence before the offset if the offset is inside a sentence and will contain the sentence before the sentence before the offset if the offset is not inside a sentence.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_SENTENCE_END the returned string is from the sentence end before the sentence end at or before the offset to the sentence end at or before the offset. The returned string will contain the sentence before the offset if the offset is inside a sentence or if the offset is not inside a sentence.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_LINE_START the returned string is from the line start before the line start at or before the offset to the line start ar or before the offset.<p>
If <em>boundary_type</em> is TEXT_BOUNDARY_LINE_END the returned string is from the line end before the line end before the offset to the line end before the offset. 
</div>
</div><p>
<a class="anchor" name="209ae0064d63efcdc1a94c6063ec63ab"></a><!-- doxytag: member="Xfc::Atk::Text::get_character_extents" ref="209ae0064d63efcdc1a94c6063ec63ab" args="(int offset, int *x, int *y, int *width, int *height, CoordType coords) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Atk::Text::get_character_extents           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Atk.html#aff9b04c77fa3853d95df3438bffd41b">CoordType</a>&nbsp;</td>
          <td class="paramname"> <em>coords</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an offset, the x, y, width, and height values are filled appropriately. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>A character position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The location for the x-position of the character at <em>position</em>, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The location for the y-position of the character at <em>position</em>, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The location for the width of the character at <em>position</em>, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The location for the height of the character at <em>position</em>, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coords</em>&nbsp;</td><td>Specify whether coordinates are relative to the screen or the widget window. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="16c7b94daa9bfadf389e49462a963307"></a><!-- doxytag: member="Xfc::Atk::Text::get_run_attributes" ref="16c7b94daa9bfadf389e49462a963307" args="(int offset, int *start_offset, int *end_offset) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classXfc_1_1Atk_1_1Attribute.html">Attribute</a>&gt; Xfc::Atk::Text::get_run_attributes           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>end_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a list which consists of the attributes explicitly set at the position <em>offset</em> in the text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset at which to get the attributes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_offset</em>&nbsp;</td><td>The address to put the start offset of the range, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_offset</em>&nbsp;</td><td>The address to put the end offset of the range, or null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vector of <a class="el" href="classXfc_1_1Atk_1_1Attribute.html">Attribute</a> which contains the attributes explicitly set at <em>offset</em>.</dd></dl>
<em>start_offset</em> and <em>end_offset</em> are set to the start and end of the range around offset where the attributes are invariant. See the enum <a class="el" href="namespaceXfc_1_1Atk.html#0e5af37493dff48c2cc607bed9816dc1">Atk::TextAttribute</a> for the types of text attributes that can be returned. Note that other attributes may also be returned. 
</div>
</div><p>
<a class="anchor" name="683a853bbe4d378e9abacea0e4c0bf32"></a><!-- doxytag: member="Xfc::Atk::Text::get_default_attributes" ref="683a853bbe4d378e9abacea0e4c0bf32" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classXfc_1_1Atk_1_1Attribute.html">Attribute</a>&gt; Xfc::Atk::Text::get_default_attributes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a list which consists of the default values of attributes for the text. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vector of <a class="el" href="classXfc_1_1Atk_1_1Attribute.html">Attribute</a> which contains the default values of the attributes at <em>offset</em>.</dd></dl>
See the enum <a class="el" href="namespaceXfc_1_1Atk.html#0e5af37493dff48c2cc607bed9816dc1">Atk::TextAttribute</a> for types of text attributes that can be returned. Note that other attributes may also be returned. 
</div>
</div><p>
<a class="anchor" name="b87a95440c18cf8d84c6f10fabb23b3b"></a><!-- doxytag: member="Xfc::Atk::Text::get_character_count" ref="b87a95440c18cf8d84c6f10fabb23b3b" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Atk::Text::get_character_count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the character count for the text. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of characters in the text. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b57b0eea2810b71ba4a3f07c4a76a1e"></a><!-- doxytag: member="Xfc::Atk::Text::get_offset_at_point" ref="7b57b0eea2810b71ba4a3f07c4a76a1e" args="(int x, int y, CoordType coords) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Atk::Text::get_offset_at_point           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Atk.html#aff9b04c77fa3853d95df3438bffd41b">CoordType</a>&nbsp;</td>
          <td class="paramname"> <em>coords</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the offset of the character located at coordinates x and y. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The x-position of a character. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The y-position of a character. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coords</em>&nbsp;</td><td>Specify whether the coordinates are relative to the screen or widget window. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset to the character which is located at the specified x and y coordinates.</dd></dl>
<em>x</em> and <em>y</em> are interpreted as being relative to the screen or this widget's window, depending on coords. 
</div>
</div><p>
<a class="anchor" name="5dc6de1b4d87d72ae5ac693b5c1f4a27"></a><!-- doxytag: member="Xfc::Atk::Text::get_n_selections" ref="5dc6de1b4d87d72ae5ac693b5c1f4a27" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Atk::Text::get_n_selections           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of selected regions. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of selected regions, or -1 if a failure occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="40a486165cd798b574ba97853b6dd019"></a><!-- doxytag: member="Xfc::Atk::Text::get_selection" ref="40a486165cd798b574ba97853b6dd019" args="(int selection_num, int *start_offset, int *end_offset) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Atk::Text::get_selection           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>selection_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>end_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the text from the specified selection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection_num</em>&nbsp;</td><td>The selection number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_offset</em>&nbsp;</td><td>The location for the start position of the selected region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_offset</em>&nbsp;</td><td>The location for the end position of the selected region. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The selected text.</dd></dl>
Selected regions are assigned numbers that correspond to how far the region is from the start of the text. The selected region closest to the beginning of the text region is assigned the number 0, etc. Note that adding, moving or deleting a selected region can change the numbering. 
</div>
</div><p>
<a class="anchor" name="83f9d32ccd65a019c797bce92041be78"></a><!-- doxytag: member="Xfc::Atk::Text::get_range_extents" ref="83f9d32ccd65a019c797bce92041be78" args="(int start_offset, int end_offset, CoordType coord_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Atk_1_1TextRectangle.html">TextRectangle</a> Xfc::Atk::Text::get_range_extents           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>end_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Atk.html#aff9b04c77fa3853d95df3438bffd41b">CoordType</a>&nbsp;</td>
          <td class="paramname"> <em>coord_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the bounding box for text within the specified range. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_offset</em>&nbsp;</td><td>The offset of the first text character in the range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_offset</em>&nbsp;</td><td>The offset of the text character after the last character in the range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coord_type</em>&nbsp;</td><td>Specifies whether coordinates are relative to the screen or widget window. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1Atk_1_1TextRectangle.html">TextRectangle</a> filled with the boundaries of the text range. </dd></dl>

</div>
</div><p>
<a class="anchor" name="184b21f0c1d03a9edf656d07e2e539e8"></a><!-- doxytag: member="Xfc::Atk::Text::get_range_extents" ref="184b21f0c1d03a9edf656d07e2e539e8" args="(int start_offset, int end_offset, CoordType coord_type, TextRectangle &amp;rect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Atk::Text::get_range_extents           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>end_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Atk.html#aff9b04c77fa3853d95df3438bffd41b">CoordType</a>&nbsp;</td>
          <td class="paramname"> <em>coord_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Atk_1_1TextRectangle.html">TextRectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the bounding box for text within the specified range. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_offset</em>&nbsp;</td><td>The offset of the first text character in the range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_offset</em>&nbsp;</td><td>The offset of the text character after the last character in the range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coord_type</em>&nbsp;</td><td>Specifies whether coordinates are relative to the screen or widget window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Atk_1_1TextRectangle.html">TextRectangle</a> which is filled in by this method. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="622f1b08cdc7fa3ba5d6ad61bdd8f2cf"></a><!-- doxytag: member="Xfc::Atk::Text::get_bounded_ranges" ref="622f1b08cdc7fa3ba5d6ad61bdd8f2cf" args="(const TextRectangle &amp;rect, CoordType coord_type, TextClipType x_clip_type, TextClipType y_clip_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classXfc_1_1Atk_1_1TextRange.html">TextRange</a>&gt; Xfc::Atk::Text::get_bounded_ranges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Atk_1_1TextRectangle.html">TextRectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Atk.html#aff9b04c77fa3853d95df3438bffd41b">CoordType</a>&nbsp;</td>
          <td class="paramname"> <em>coord_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Atk.html#003a7fa83bf4b3346387e595a500885a">TextClipType</a>&nbsp;</td>
          <td class="paramname"> <em>x_clip_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Atk.html#003a7fa83bf4b3346387e595a500885a">TextClipType</a>&nbsp;</td>
          <td class="paramname"> <em>y_clip_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the ranges of text in the specified bounding box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>A TextRectagle giving the dimensions of the bounding box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coord_type</em>&nbsp;</td><td>Specifies whether coordinates are relative to the screen or widget window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x_clip_type</em>&nbsp;</td><td>Specifies the horizontal clip type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y_clip_type</em>&nbsp;</td><td>Specifies the vertical clip type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vector of <a class="el" href="classXfc_1_1Atk_1_1TextRange.html">TextRange</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c28e244eb0a5ffab1609616f599307b0"></a><!-- doxytag: member="Xfc::Atk::Text::add_selection" ref="c28e244eb0a5ffab1609616f599307b0" args="(int start_offset, int end_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Atk::Text::add_selection           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>end_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the selection bounded by the specified offsets. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_offset</em>&nbsp;</td><td>The start position of the selected region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_offset</em>&nbsp;</td><td>The end position of the selected region. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if successful, <em>false</em> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="497eb2570d4a0efa4f8d655839e03031"></a><!-- doxytag: member="Xfc::Atk::Text::remove_selection" ref="497eb2570d4a0efa4f8d655839e03031" args="(int selection_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Atk::Text::remove_selection           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>selection_num</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the specified selection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection_num</em>&nbsp;</td><td>The selection number. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if successful, <em>false</em> otherwise.</dd></dl>
Selected regions are assigned numbers that correspond to how far the region is from the start of the text. The selected region closest to the beginning of the text region is assigned the number 0, etc. Note that adding, moving or deleting a selected region can change the numbering. 
</div>
</div><p>
<a class="anchor" name="b5b4fc09f1a8c5ce3cccd0421db11d7a"></a><!-- doxytag: member="Xfc::Atk::Text::set_selection" ref="b5b4fc09f1a8c5ce3cccd0421db11d7a" args="(int selection_num, int start_offset, int end_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Atk::Text::set_selection           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>selection_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>end_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes the start and end offset of the specified selection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection_num</em>&nbsp;</td><td>The selection number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_offset</em>&nbsp;</td><td>The new start position of the selection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_offset</em>&nbsp;</td><td>The new end position of the selection. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if successful, <em>false</em> otherwise.</dd></dl>
Selected regions are assigned numbers that correspond to how far the region is from the start of the text. The selected region closest to the beginning of the text region is assigned the number 0, etc. Note that adding, moving or deleting a selected region can change the numbering. 
</div>
</div><p>
<a class="anchor" name="90d1580d3931f1bb10b6b7fec985fd92"></a><!-- doxytag: member="Xfc::Atk::Text::set_caret_offset" ref="90d1580d3931f1bb10b6b7fec985fd92" args="(int offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Atk::Text::set_caret_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the caret (cursor) position to the specified offset. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>A character position. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if successful, <em>false</em> otherwise. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="057ca0f3217a574b402f3f90ef5ac267"></a><!-- doxytag: member="Xfc::Atk::Text::text_changed_signal" ref="057ca0f3217a574b402f3f90ef5ac267" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">TextChangedSignalType</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#057ca0f3217a574b402f3f90ef5ac267">Xfc::Atk::Text::text_changed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> changed signal (see signal_text_change()). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<span class="keywordtype">int</span> position, <span class="keywordtype">int</span> length);
&lt; <span class="comment">// position: The position of the insertion or deletion.</span>
&lt; <span class="comment">// length: The length of the text inserted or deleted.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="c7261397adb4377a8c5e825426a186e2"></a><!-- doxytag: member="Xfc::Atk::Text::text_caret_moved_signal" ref="c7261397adb4377a8c5e825426a186e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">TextCaretMovedSignalType</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#c7261397adb4377a8c5e825426a186e2">Xfc::Atk::Text::text_caret_moved_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> caret moved signal (see <a class="el" href="classXfc_1_1Atk_1_1Text.html#cbd809785d9124c81823a486e188879e">signal_text_caret_moved()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<span class="keywordtype">int</span> location);
&lt; <span class="comment">// location: The new position of the text caret.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="604da5af7675e6b7302b049adf6f51db"></a><!-- doxytag: member="Xfc::Atk::Text::text_selection_changed_signal" ref="604da5af7675e6b7302b049adf6f51db" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">TextSelectionChangedSignalType</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#604da5af7675e6b7302b049adf6f51db">Xfc::Atk::Text::text_selection_changed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> selection changed signal (see <a class="el" href="classXfc_1_1Atk_1_1Text.html#c6e7fd343a1a6437f0302e8ea2f75452">signal_text_selection_changed()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="73b2db87f2e550cf222dc05deb8ca2de"></a><!-- doxytag: member="Xfc::Atk::Text::text_attributes_changed_signal" ref="73b2db87f2e550cf222dc05deb8ca2de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">TextAttributesChangedSignalType</a> <a class="el" href="classXfc_1_1Atk_1_1Text.html#73b2db87f2e550cf222dc05deb8ca2de">Xfc::Atk::Text::text_attributes_changed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classXfc_1_1Atk_1_1Text.html">Text</a> attributes changed signal (see <a class="el" href="classXfc_1_1Atk_1_1Text.html#ff4ab14c40b11da09315f67276eb992b">signal_text_attributes_changed()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="text_8hh.html">text.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
