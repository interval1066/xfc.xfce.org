<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="classXfc_1_1G_1_1AsyncQueue.html">AsyncQueue</a></div>
<h1>Xfc::G::AsyncQueue Class Reference</h1><!-- doxytag: class="Xfc::G::AsyncQueue" --><!-- doxytag: inherits="Xfc::Object" -->A GAsyncQueue C++ wrapper interface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/asyncqueue.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::G::AsyncQueue:
<p><center><img src="classXfc_1_1G_1_1AsyncQueue.png" usemap="#Xfc::G::AsyncQueue_map" border="0" alt=""></center>
<map name="Xfc::G::AsyncQueue_map">
<area href="classXfc_1_1Object.html" alt="Xfc::Object" shape="rect" coords="0,56,127,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,127,24">
</map>
<a href="classXfc_1_1G_1_1AsyncQueue-members.html">List of all members.</a><h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="ec66604533d35e2609a68d1a709363d4"></a><!-- doxytag: member="Xfc::G::AsyncQueue::g_async_queue" ref="ec66604533d35e2609a68d1a709363d4" args="() const" -->
GAsyncQueue * <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#ec66604533d35e2609a68d1a709363d4">g_async_queue</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GAsyncQueue structure. <br></dl><li>int <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#c78c4414af2eeba0a81f63e49028885b">length</a> () const
<dl class="el"><dd class="mdescRight">Gets the length of the queue.  <a href="#c78c4414af2eeba0a81f63e49028885b"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li><a class="anchor" name="5da2a4ecfc98654bccabcdc9a2f5e73f"></a><!-- doxytag: member="Xfc::G::AsyncQueue::ref" ref="5da2a4ecfc98654bccabcdc9a2f5e73f" args="()" -->
virtual void <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#5da2a4ecfc98654bccabcdc9a2f5e73f">ref</a> ()
<dl class="el"><dd class="mdescRight">Increases the reference count of the asynchronous queue by one. <br></dl><li>virtual void <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#2858622c763028508656cb7af94e9fbc">unref</a> ()
<dl class="el"><dd class="mdescRight">Decreases the reference count of the asynchronous queue by one.  <a href="#2858622c763028508656cb7af94e9fbc"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#1410c7e18fecc6f4d304566e2e407cf7">lock</a> ()
<dl class="el"><dd class="mdescRight">Acquires the queue's lock.  <a href="#1410c7e18fecc6f4d304566e2e407cf7"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#513b0477205ab61191703f551adc010b">unlock</a> ()
<dl class="el"><dd class="mdescRight">Releases the queue's lock.  <a href="#513b0477205ab61191703f551adc010b"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#8995ba465c393c6918a1f5091a1ad7a9">push</a> (void *data)
<dl class="el"><dd class="mdescRight">Pushes the <em>data</em> into the queue (<em>data</em> must not be null).  <a href="#8995ba465c393c6918a1f5091a1ad7a9"></a><br></dl><li>void * <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#17e1bc79b46e1338b89f3a5a04999e05">pop</a> ()
<dl class="el"><dd class="mdescRight">Pop data from the async queue.  <a href="#17e1bc79b46e1338b89f3a5a04999e05"></a><br></dl><li>void * <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#7d1c771d3b8755d649126d7f9971bd36">try_pop</a> ()
<dl class="el"><dd class="mdescRight">Try to pop data.  <a href="#7d1c771d3b8755d649126d7f9971bd36"></a><br></dl><li>void * <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#b530936cd359d6166446f9ec4e936f10">timed_pop</a> (<a class="el" href="classXfc_1_1G_1_1TimeVal.html">TimeVal</a> *end_time)
<dl class="el"><dd class="mdescRight">Pops data from the queue.  <a href="#b530936cd359d6166446f9ec4e936f10"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GAsyncQueue C++ wrapper interface. 
<p>
Often you need to communicate between different threads. In general it's safer not to do this by shared memory, but by explicit message passing. These messages only make sense asynchronously for multi-threaded applications though, as a synchronous operation could as well be done in the same thread.<p>
Asynchronous queues are an exception from most other GLib data structures, as they can be used simultaneously from multiple threads without explicit locking and they bring their own builtin reference counting. This is because the nature of an asynchronous queue is that it will always be used by at least 2 concurrent threads.<p>
For using an asynchronous queue you first have to construct one, either dynamically or on the stack. A newly-created queue will get the reference count 1. Whenever another thread is creating a new reference to a queue, it has to increase the reference count (using <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#5da2a4ecfc98654bccabcdc9a2f5e73f">ref()</a>). Also, before removing this reference, the reference count has to be decreased (using <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#2858622c763028508656cb7af94e9fbc">unref()</a>). After that the queue might no longer exist so you must not access it after that point.<p>
A thread which wants to send a message to a queue simply calls <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#8995ba465c393c6918a1f5091a1ad7a9">push()</a> to push the message to the queue. A thread which is expecting messages from an asynchronous queue simply calls <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#17e1bc79b46e1338b89f3a5a04999e05">pop()</a> for that queue. If no message is available in the queue at that point, the thread is now put to sleep until a message arrives. The message will be removed from the queue and returned. The methods <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#7d1c771d3b8755d649126d7f9971bd36">try_pop()</a> and <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#b530936cd359d6166446f9ec4e936f10">timed_pop()</a> can be used to only check for the presence of messages or to only wait a certain time for messages respectively.<p>
In GLib, for almost every g_async_queue_* function there exist two variants, one that locks the queue and one that doesn't. That way you can hold the queue lock (acquire it with g_async_queue_lock() and release it with g_async_queue_unlock()) over multiple queue accessing instructions. This can be necessary to ensure the integrity of the queue, but should only be used when really necessary, as it can make your life harder if used unwisely. Normally you should only use the locking function variants (those without the suffix _unlocked).<p>
<a class="el" href="classXfc_1_1G_1_1AsyncQueue.html">AsyncQueue</a> hides the these two function variants behind a single API. When you call <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#1410c7e18fecc6f4d304566e2e407cf7">lock()</a> the bool flag 'locked_' is set, and the API calls the *_unlocked functions. When you call <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#513b0477205ab61191703f551adc010b">unlock()</a> the 'locked_' flag is cleared, and the functions without the suffix _unlocked are called. For saftey reasons, and ensure the <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html">AsyncQueue</a> locked_ flag can't be broken, there is no <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#ec66604533d35e2609a68d1a709363d4">g_async_queue()</a> method or conversion operator.<p>
Note, you must call <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#2858622c763028508656cb7af94e9fbc">unref()</a> whether you create the queue dynamically or on the stack. If you create an <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html">AsyncQueue</a> dynamically with operatror new the easiest way to handle <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#2858622c763028508656cb7af94e9fbc">unref()</a> is to use a smart pointer. If you create an <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html">AsyncQueue</a> on the stack you will have to <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#2858622c763028508656cb7af94e9fbc">unref()</a> it yourself, as you would with any object derived from ReferencedBase, including G::Objects. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c78c4414af2eeba0a81f63e49028885b"></a><!-- doxytag: member="Xfc::G::AsyncQueue::length" ref="c78c4414af2eeba0a81f63e49028885b" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::G::AsyncQueue::length           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the length of the queue. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The queue length.</dd></dl>
Negative values mean that threads are waiting, positive values mean that there are entries in the queue. Actually this method returns the length of the queue minus the number of waiting threads, length == 0 could also mean 'n' entries in the queue and 'n' thread waiting. Such can happen due to locking of the queue or due to scheduling. 
</div>
</div><p>
<a class="anchor" name="2858622c763028508656cb7af94e9fbc"></a><!-- doxytag: member="Xfc::G::AsyncQueue::unref" ref="2858622c763028508656cb7af94e9fbc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Xfc::G::AsyncQueue::unref           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decreases the reference count of the asynchronous queue by one. 
<p>
After this call if the reference is zero and the queue will be destroyed. 
<p>
Reimplemented from <a class="el" href="classXfc_1_1Object.html#97861bfac97de2b84b18803c1bd560ca">Xfc::Object</a>.
</div>
</div><p>
<a class="anchor" name="1410c7e18fecc6f4d304566e2e407cf7"></a><!-- doxytag: member="Xfc::G::AsyncQueue::lock" ref="1410c7e18fecc6f4d304566e2e407cf7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::AsyncQueue::lock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquires the queue's lock. 
<p>
All methods lock/unlock the queue for themselves, but in certain cirumstances you want to hold the lock longer, thus you lock the queue, and unlock when your finished. 
</div>
</div><p>
<a class="anchor" name="513b0477205ab61191703f551adc010b"></a><!-- doxytag: member="Xfc::G::AsyncQueue::unlock" ref="513b0477205ab61191703f551adc010b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::AsyncQueue::unlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases the queue's lock. 
<p>
All methods lock/unlock the queue for themselves, but in certain cirumstances you want to hold the lock longer, thus you lock the queue, and unlock when your finished. 
</div>
</div><p>
<a class="anchor" name="8995ba465c393c6918a1f5091a1ad7a9"></a><!-- doxytag: member="Xfc::G::AsyncQueue::push" ref="8995ba465c393c6918a1f5091a1ad7a9" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::AsyncQueue::push           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pushes the <em>data</em> into the queue (<em>data</em> must not be null). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to push into the queue. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="17e1bc79b46e1338b89f3a5a04999e05"></a><!-- doxytag: member="Xfc::G::AsyncQueue::pop" ref="17e1bc79b46e1338b89f3a5a04999e05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Xfc::G::AsyncQueue::pop           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pop data from the async queue. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The data from the queue.</dd></dl>
When no data is there, the thread is blocked until data arrives. 
</div>
</div><p>
<a class="anchor" name="7d1c771d3b8755d649126d7f9971bd36"></a><!-- doxytag: member="Xfc::G::AsyncQueue::try_pop" ref="7d1c771d3b8755d649126d7f9971bd36" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Xfc::G::AsyncQueue::try_pop           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Try to pop data. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The data from the queue, or null if the queue is empty. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b530936cd359d6166446f9ec4e936f10"></a><!-- doxytag: member="Xfc::G::AsyncQueue::timed_pop" ref="b530936cd359d6166446f9ec4e936f10" args="(TimeVal *end_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Xfc::G::AsyncQueue::timed_pop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1TimeVal.html">TimeVal</a> *&nbsp;</td>
          <td class="paramname"> <em>end_time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pops data from the queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>end_time</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1G_1_1TimeVal.html">G::TimeVal</a>, determining the final time. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The data from the queue, or null when no data is received before end_time.</dd></dl>
To easily calculate end_time a combination of <a class="el" href="namespaceXfc_1_1G.html#10d83a8c0d92f71924764d771989d7ad">G::get_current_time()</a> and <a class="el" href="classXfc_1_1G_1_1TimeVal.html#6ac3985dddf4f6f4c334c7d7f8ad098e">G::TimeVal::add()</a> can be used. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="asyncqueue_8hh.html">asyncqueue.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
