<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="classXfc_1_1G_1_1Condition.html">Condition</a></div>
<h1>Xfc::G::Condition Class Reference</h1><!-- doxytag: class="Xfc::G::Condition" --><!-- doxytag: inherits="Xfc::Object" -->A GCond C++ wrapper interface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/thread.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::G::Condition:
<p><center><img src="classXfc_1_1G_1_1Condition.png" usemap="#Xfc::G::Condition_map" border="0" alt=""></center>
<map name="Xfc::G::Condition_map">
<area href="classXfc_1_1Object.html" alt="Xfc::Object" shape="rect" coords="0,56,106,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,106,24">
</map>
<a href="classXfc_1_1G_1_1Condition-members.html">List of all members.</a><h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="3bd4b1d8e6ce6a0e90c132f367c223db"></a><!-- doxytag: member="Xfc::G::Condition::g_cond" ref="3bd4b1d8e6ce6a0e90c132f367c223db" args="() const" -->
GCond * <a class="el" href="classXfc_1_1G_1_1Condition.html#3bd4b1d8e6ce6a0e90c132f367c223db">g_cond</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GCond structure. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1G_1_1Condition.html#498137f11d758ac6ce6b15af76cb7f13">signal</a> ()
<dl class="el"><dd class="mdescRight">If threads are waiting for the condition, exactly one of them is woken up.  <a href="#498137f11d758ac6ce6b15af76cb7f13"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1Condition.html#d7ede27225761e7038c6cc8bf7a26ee7">broadcast</a> ()
<dl class="el"><dd class="mdescRight">If threads are waiting for the condition, all of them are woken up.  <a href="#d7ede27225761e7038c6cc8bf7a26ee7"></a><br></dl><li>bool <a class="el" href="classXfc_1_1G_1_1Condition.html#6d106546d4809cac9fb2a1032fa68e86">wait</a> (<a class="el" href="classXfc_1_1G_1_1Mutex.html">Mutex</a> &amp;mutex, const <a class="el" href="classXfc_1_1G_1_1TimeVal.html">TimeVal</a> *abs_time=0)
<dl class="el"><dd class="mdescRight">Waits until a thread is woken up on condition.  <a href="#6d106546d4809cac9fb2a1032fa68e86"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GCond C++ wrapper interface. 
<p>
The <a class="el" href="classXfc_1_1G_1_1Condition.html">Condition</a> object represents a condition that threads can block on, if they find a certain condition to be false. If other threads change the state of this condition they can signal the <a class="el" href="classXfc_1_1G_1_1Condition.html">Condition</a>, such that the waiting thread is woken up.<p>
<b>Example:</b> Using <a class="el" href="classXfc_1_1G_1_1Condition.html">G::Condition</a> to block a thread until a condition is satisfied. <div class="fragment"><pre class="fragment"> G::Condition *data_cond = 0; <span class="comment">// Must be initialized somewhere.</span>
 G::Mutex *data_mutex = 0; <span class="comment">// Must be initialized somewhere.</span>
 <span class="keywordtype">void</span> *current_data = 0;

 <span class="keywordtype">void</span> push_data(<span class="keywordtype">void</span> *data)
 {
        data_mutex-&gt;lock();
        current_data = data;
        data_cond-&gt;signal();
        data_mutex-&gt;unlock();
 }

 <span class="keywordtype">void</span>* pop_data()
 {
        data_mutex-&gt;lock();
        <span class="keywordflow">while</span> (!current_data)
                data_cond-&gt;wait(*data_mutex);
        <span class="keywordtype">void</span> *data = current_data;
        current_data = 0;
        data_mutex-&gt;unlock();
     <span class="keywordflow">return</span> data;
 }
</pre></div><p>
Whenever a thread calls pop_data() now, it will wait until current_data is non-null, i.e. until some other thread has called push_data().<p>
Note, it is important to use the <a class="el" href="classXfc_1_1G_1_1Condition.html#6d106546d4809cac9fb2a1032fa68e86">wait()</a> method only inside a loop, which checks for the condition to be <em>true</em> as it is not guaranteed that the waiting thread will find it fulfilled, even if the signaling thread left the condition in that state. This is because another thread can have altered the condition, before the waiting thread got the chance to be woken up, even if the condition itself is protected by a <a class="el" href="classXfc_1_1G_1_1Mutex.html">Mutex</a>, like above. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="498137f11d758ac6ce6b15af76cb7f13"></a><!-- doxytag: member="Xfc::G::Condition::signal" ref="498137f11d758ac6ce6b15af76cb7f13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Condition::signal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If threads are waiting for the condition, exactly one of them is woken up. 
<p>
It is good practice to hold the same lock as the waiting thread, while calling this method, though not required. This method can also be used, if g_thread_init() has not yet been called, and will do nothing then. 
</div>
</div><p>
<a class="anchor" name="d7ede27225761e7038c6cc8bf7a26ee7"></a><!-- doxytag: member="Xfc::G::Condition::broadcast" ref="d7ede27225761e7038c6cc8bf7a26ee7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Condition::broadcast           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If threads are waiting for the condition, all of them are woken up. 
<p>
It is good practice to lock the same mutex as the waiting threads, while calling this method, though not required. This method can also be used if g_thread_init() has not yet been called, and will do nothing then. 
</div>
</div><p>
<a class="anchor" name="6d106546d4809cac9fb2a1032fa68e86"></a><!-- doxytag: member="Xfc::G::Condition::wait" ref="6d106546d4809cac9fb2a1032fa68e86" args="(Mutex &amp;mutex, const TimeVal *abs_time=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::Condition::wait           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Mutex.html">Mutex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1G_1_1TimeVal.html">TimeVal</a> *&nbsp;</td>
          <td class="paramname"> <em>abs_time</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits until a thread is woken up on condition. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1G_1_1Mutex.html">Mutex</a> that is currently locked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>abs_time</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1G_1_1TimeVal.html">TimeVal</a> determining the final time, or null for unlimited time. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the thread is woken up in time, or if <em>abs_time</em> is null.</dd></dl>
The mutex is unlocked before falling asleep and locked again before resuming. If abs_time is null, timed_wait() acts like g_cond_wait(). If <em>abs_time</em> is specified, this method waits no longer than the time <em>abs_time</em> specifies. To easily calculate <em>abs_time</em> a combination of <a class="el" href="namespaceXfc_1_1G.html#10d83a8c0d92f71924764d771989d7ad">G::get_current_time()</a> and <a class="el" href="classXfc_1_1G_1_1TimeVal.html#6ac3985dddf4f6f4c334c7d7f8ad098e">G::TimeVal::add()</a> can be used. This method can be used if g_thread_init() has not yet been called, and will immediately return true then. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="thread_8hh.html">thread.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
