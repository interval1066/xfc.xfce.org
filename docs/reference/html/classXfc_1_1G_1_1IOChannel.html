<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a></div>
<h1>Xfc::G::IOChannel Class Reference</h1><!-- doxytag: class="Xfc::G::IOChannel" --><!-- doxytag: inherits="Xfc::Trackable" -->A GIOChannel C++ wrapper class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/iochannel.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::G::IOChannel:
<p><center><img src="classXfc_1_1G_1_1IOChannel.png" usemap="#Xfc::G::IOChannel_map" border="0" alt=""></center>
<map name="Xfc::G::IOChannel_map">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,113,24">
</map>
<a href="classXfc_1_1G_1_1IOChannel-members.html">List of all members.</a><h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="0278404f00983cd553e697c8ad4edced"></a><!-- doxytag: member="Xfc::G::IOChannel::g_io_channel" ref="0278404f00983cd553e697c8ad4edced" args="() const" -->
GIOChannel * <a class="el" href="classXfc_1_1G_1_1IOChannel.html#0278404f00983cd553e697c8ad4edced">g_io_channel</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GIOChannel structure. <br></dl><li><a class="anchor" name="de976b1cf4f2fc3060fe7116da2b036d"></a><!-- doxytag: member="Xfc::G::IOChannel::operator GIOChannel *" ref="de976b1cf4f2fc3060fe7116da2b036d" args="() const" -->
<a class="el" href="classXfc_1_1G_1_1IOChannel.html#de976b1cf4f2fc3060fe7116da2b036d">operator GIOChannel *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; Safely converts a <a class="el" href="classXfc_1_1G_1_1IOChannel.html">G::IOChannel</a> object into a GIOChannel pointer. <br></dl><li>size_t <a class="el" href="classXfc_1_1G_1_1IOChannel.html#810a805411346a4d737b9d3410c59d5a">get_buffer_size</a> () const
<dl class="el"><dd class="mdescRight">Gets the buffer size.  <a href="#810a805411346a4d737b9d3410c59d5a"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#0a164d71cfd9c48b105d624868c62cc5">IOConditionField</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#c2c24453102d1caa3d7fce5cc1f1953d">get_buffer_condition</a> () const
<dl class="el"><dd class="mdescRight">Gets an IOCondition depending on whether there is data to be read/space to write data in the internal buffers in the <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a>.  <a href="#c2c24453102d1caa3d7fce5cc1f1953d"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#f9622492d26cf492fefb726a3c1ad0fe">IOFlagsField</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#b044514cee3252ee06e30c4a67d3385a">get_flags</a> () const
<dl class="el"><dd class="mdescRight">Gets the current flags for the channel, including read-only flags such as IO_FLAG_IS_READABLE.  <a href="#b044514cee3252ee06e30c4a67d3385a"></a><br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#b806f0aff1a7f5f9cc09388bb4413ba4">get_line_term</a> () const
<dl class="el"><dd class="mdescRight">Gets the string that the channel uses to determine where in the file a line break occurs.  <a href="#b806f0aff1a7f5f9cc09388bb4413ba4"></a><br></dl><li>bool <a class="el" href="classXfc_1_1G_1_1IOChannel.html#9799a8daaa761c0b4cd617483aaeb5cd">get_buffered</a> () const
<dl class="el"><dd class="mdescRight">Returns whether the channel is buffered.  <a href="#9799a8daaa761c0b4cd617483aaeb5cd"></a><br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#b49de3b3fd49d5babf477c7ce9b51b02">get_encoding</a> () const
<dl class="el"><dd class="mdescRight">Gets the encoding for the input/output of the channel.  <a href="#b49de3b3fd49d5babf477c7ce9b51b02"></a><br></dl><li>bool <a class="el" href="classXfc_1_1G_1_1IOChannel.html#82fe464489826af5da92b6b56922b63e">get_close_on_unref</a> () const
<dl class="el"><dd class="mdescRight">Returns whether the file/socket/whatever associated with the channel will be closed when the channel receives its final unref and is destroyed.  <a href="#82fe464489826af5da92b6b56922b63e"></a><br></dl><li>int <a class="el" href="classXfc_1_1G_1_1IOChannel.html#5425a2b88daeef70eabaaf527aa72f31">get_fd</a> () const
<dl class="el"><dd class="mdescRight">Returns the file descriptor of the UNIX channel created by the <a class="el" href="classXfc_1_1G_1_1IOChannel.html#ccdf36612525bdd1452cb9af4543735c">create()</a> file descriptor method.  <a href="#5425a2b88daeef70eabaaf527aa72f31"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li><a class="anchor" name="82fb9f3ab43adda13251d6e4b72881be"></a><!-- doxytag: member="Xfc::G::IOChannel::ref" ref="82fb9f3ab43adda13251d6e4b72881be" args="()" -->
virtual void <a class="el" href="classXfc_1_1G_1_1IOChannel.html#82fb9f3ab43adda13251d6e4b72881be">ref</a> ()
<dl class="el"><dd class="mdescRight">Increase an IO channel's reference count by one. <br></dl><li>virtual void <a class="el" href="classXfc_1_1G_1_1IOChannel.html#45c8749367a15752d764807d172fea56">unref</a> ()
<dl class="el"><dd class="mdescRight">Decrease an IO channel's reference count by one.  <a href="#45c8749367a15752d764807d172fea56"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#2458e0243b3296f9cbf5a30d7a43582b">close</a> (bool flush, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Close an IO channel.  <a href="#2458e0243b3296f9cbf5a30d7a43582b"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1IOChannel.html#700c97096c74ff6c4aab9c229aa8a4bf">set_buffer_size</a> (size_t size)
<dl class="el"><dd class="mdescRight">Sets the buffer size.  <a href="#700c97096c74ff6c4aab9c229aa8a4bf"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#0788b8eecc950a09d04893fb66e7f2dc">set_flags</a> (<a class="el" href="namespaceXfc_1_1G.html#f9622492d26cf492fefb726a3c1ad0fe">IOFlagsField</a> flags, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Sets the (writeable) flags in the channel to (flags &amp; IO_CHANNEL_SET_MASK).  <a href="#0788b8eecc950a09d04893fb66e7f2dc"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1IOChannel.html#2840989b26bd5cbd2267c4ead5369f0b">set_line_term</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;line_term)
<dl class="el"><dd class="mdescRight">This sets the string that the channel uses to determine where in the file a line break occurs.  <a href="#2840989b26bd5cbd2267c4ead5369f0b"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1IOChannel.html#cb074468a974020a150c941decaa35ee">set_buffered</a> (bool buffered)
<dl class="el"><dd class="mdescRight">Set the buffering state of the channel (the default state is buffered).  <a href="#cb074468a974020a150c941decaa35ee"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#3e30eed6e6fd3376bcb350c2085ab853">set_encoding</a> (const char *encoding, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Sets the encoding for the input/output of the channel.  <a href="#3e30eed6e6fd3376bcb350c2085ab853"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1IOChannel.html#8edbd29b0ce4aa7d223260ba5e9bffa2">set_close_on_unref</a> (bool do_close)
<dl class="el"><dd class="mdescRight">Setting this flag to true for a channel you have already closed can cause problems.  <a href="#8edbd29b0ce4aa7d223260ba5e9bffa2"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#82eb2e9470ae0b97ee612ca8103e64c4">flush</a> (<a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Flushes the write buffer for the channel.  <a href="#82eb2e9470ae0b97ee612ca8103e64c4"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#5186b790a4d7ffbf8879d2b087dfd0b0">read_line</a> (<a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t *bytes_read, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Reads a line, including the terminating character(s), from a channel into <a class="el" href="classXfc_1_1String.html">String</a>.  <a href="#5186b790a4d7ffbf8879d2b087dfd0b0"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#46c8673d136058371d4ecd194ddf90cc">read_to_end</a> (<a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t *bytes_read, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Reads data from a channel.  <a href="#46c8673d136058371d4ecd194ddf90cc"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#5d35ba545f478fd369831e237773bbbc">read</a> (char *buffer, size_t count, size_t *bytes_read, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Reads data from a channel.  <a href="#5d35ba545f478fd369831e237773bbbc"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#b397cad627cc4d41c78986b3d674acf3">read</a> (<a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t *bytes_read, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Reads at most <em>count</em> data from a channel into a <a class="el" href="classXfc_1_1String.html">String</a>.  <a href="#b397cad627cc4d41c78986b3d674acf3"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#5fa6af07b4c1f734329cac0c7a1c224a">read</a> (<a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> &amp;unichar, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">This method cannot be called on a channel with a null encoding.  <a href="#5fa6af07b4c1f734329cac0c7a1c224a"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#178c49430166a1ff8305c20aa1ff9e36">write</a> (const char *buffer, size_t count, size_t *bytes_written, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Writes data to a channel.  <a href="#178c49430166a1ff8305c20aa1ff9e36"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#f438dd9e64329319c8f9d6bfc39c8cca">write</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t *bytes_written, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Writes a <a class="el" href="classXfc_1_1String.html">String</a> to a channel.  <a href="#f438dd9e64329319c8f9d6bfc39c8cca"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#fb14a73ac76ca622ed057ca2b9a273c0">write</a> (<a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> unichar, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">This method cannot be called on a channel with a null encoding.  <a href="#fb14a73ac76ca622ed057ca2b9a273c0"></a><br></dl><li><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#d63aa17f420862a6763b80541bfcab80">seek</a> (gint64 offset, <a class="el" href="namespaceXfc_1_1G.html#fe9fe589e1e5eda6fa94e11096d8e74a">SeekType</a> type, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Sets the current position in the channel, similar to the standard library function fseek().  <a href="#d63aa17f420862a6763b80541bfcab80"></a><br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> &gt; <a class="el" href="classXfc_1_1G_1_1IOChannel.html#ccdf36612525bdd1452cb9af4543735c">create</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;filename, const char *mode, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error)
<dl class="el"><dd class="mdescRight">Create a new channel for the file <em>filename</em> using the mode <em>mode</em>.  <a href="#ccdf36612525bdd1452cb9af4543735c"></a><br></dl><li>static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> &gt; <a class="el" href="classXfc_1_1G_1_1IOChannel.html#2dfed4ce7ee4be647859b6e99794a642">create</a> (int fd, bool close_on_unref=false)
<dl class="el"><dd class="mdescRight">Create a new channel for the file descriptor <em>fd</em>.  <a href="#2dfed4ce7ee4be647859b6e99794a642"></a><br></dl><li>static <a class="el" href="namespaceXfc_1_1G.html#03128d178fa8356c85974a7d158a22dc">IOChannelError</a> <a class="el" href="classXfc_1_1G_1_1IOChannel.html#2df848ed289fca9658bcc35ebf60f81e">error_from_errno</a> (int errno_number)
<dl class="el"><dd class="mdescRight">Converts an errno error number to a IOChannelError.  <a href="#2df848ed289fca9658bcc35ebf60f81e"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GIOChannel C++ wrapper class. 
<p>
The <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> object provides a portable method for using file descriptors, pipes, and sockets, and integrating them into the main event loop. Currently full support is available on UNIX platforms, support for Windows is only partially complete.<p>
To create a new <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> on UNIX systems use the <a class="el" href="classXfc_1_1G_1_1IOChannel.html#ccdf36612525bdd1452cb9af4543735c">create()</a> 'file descriptor' method. This works for plain file descriptors, pipes and sockets. Alternatively, a channel can be opened for a file in a system independent manner using open_file(). Once an <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> has been created, it can be used in a generic manner with the methods <a class="el" href="classXfc_1_1G_1_1IOChannel.html#5d35ba545f478fd369831e237773bbbc">read()</a>, <a class="el" href="classXfc_1_1G_1_1IOChannel.html#178c49430166a1ff8305c20aa1ff9e36">write()</a>, <a class="el" href="classXfc_1_1G_1_1IOChannel.html#d63aa17f420862a6763b80541bfcab80">seek()</a>, and <a class="el" href="classXfc_1_1G_1_1IOChannel.html#2458e0243b3296f9cbf5a30d7a43582b">close()</a>.<p>
To add an <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> to the main event loop use add_watch(). Here you specify which events you are interested in watching on the <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a>, and provide a slot to be called whenever these events occur.<p>
<a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> instances are created with an initial reference count of 1. <a class="el" href="classXfc_1_1G_1_1IOChannel.html#82fb9f3ab43adda13251d6e4b72881be">ref()</a> and <a class="el" href="classXfc_1_1G_1_1IOChannel.html#45c8749367a15752d764807d172fea56">unref()</a> can be used to increment or decrement the reference count respectively. When the reference count falls to 0, the <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> is freed. (Though it isn't closed automatically, unless it was opened using open_file().) Using add_watch() increments a channel's reference count. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6c940c309f18445ca9a5ac5537ce09da"></a><!-- doxytag: member="Xfc::G::IOChannel::IOChannel" ref="6c940c309f18445ca9a5ac5537ce09da" args="(GIOChannel *channel, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::IOChannel::IOChannel           </td>
          <td>(</td>
          <td class="paramtype">GIOChannel *&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a IO channel from an existing GIOChannel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A pointer to a GIOChannel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set <em>true</em> if the initial reference count is owned by this object.</td></tr>
  </table>
</dl>
The <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> object takes over the ownership of the GIOChannel and unreferences it when the destructor is called. 
</div>
</div><p>
<a class="anchor" name="6c940c309f18445ca9a5ac5537ce09da"></a><!-- doxytag: member="Xfc::G::IOChannel::IOChannel" ref="6c940c309f18445ca9a5ac5537ce09da" args="(GIOChannel *channel, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::IOChannel::IOChannel           </td>
          <td>(</td>
          <td class="paramtype">GIOChannel *&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a IO channel from an existing GIOChannel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A pointer to a GIOChannel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set <em>true</em> if the initial reference count is owned by this object.</td></tr>
  </table>
</dl>
The <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> object takes over the ownership of the GIOChannel and unreferences it when the destructor is called. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="ccdf36612525bdd1452cb9af4543735c"></a><!-- doxytag: member="Xfc::G::IOChannel::create" ref="ccdf36612525bdd1452cb9af4543735c" args="(const String &amp;filename, const char *mode, G::Error *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a>&gt; Xfc::G::IOChannel::create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new channel for the file <em>filename</em> using the mode <em>mode</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>A string containing the name of a file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>One of "r", "w", "a", "r+", "w+", "a+". These have the same meaning as in fopen(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>A location to return an error of type G_FILE_ERROR. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to a new <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> on success, or null on failure.</dd></dl>
This channel will be closed automatically when the last reference to it is dropped. 
</div>
</div><p>
<a class="anchor" name="2dfed4ce7ee4be647859b6e99794a642"></a><!-- doxytag: member="Xfc::G::IOChannel::create" ref="2dfed4ce7ee4be647859b6e99794a642" args="(int fd, bool close_on_unref=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a>&gt; Xfc::G::IOChannel::create           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>close_on_unref</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new channel for the file descriptor <em>fd</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>A file descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>close_on_unref</em>&nbsp;</td><td>Whether to close the channel on the final unref of the GIOChannel data structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to a new <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a>.</dd></dl>
On UNIX systems this works for plain files, pipes, and sockets. The default encoding for an <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> is UTF-8. If your application is reading output from a command using via pipe, you may need to set the encoding to the encoding of the current locale (see g_get_charset()) with the <a class="el" href="classXfc_1_1G_1_1IOChannel.html#3e30eed6e6fd3376bcb350c2085ab853">IOChannel::set_encoding()</a> method. 
</div>
</div><p>
<a class="anchor" name="2df848ed289fca9658bcc35ebf60f81e"></a><!-- doxytag: member="Xfc::G::IOChannel::error_from_errno" ref="2df848ed289fca9658bcc35ebf60f81e" args="(int errno_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceXfc_1_1G.html#03128d178fa8356c85974a7d158a22dc">IOChannelError</a> Xfc::G::IOChannel::error_from_errno           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>errno_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts an errno error number to a IOChannelError. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>errno_number</em>&nbsp;</td><td>An errno error number, e.g. EINVAL. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An IOChannelError error number, e.g. IO_CHANNEL_ERROR_INVAL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="810a805411346a4d737b9d3410c59d5a"></a><!-- doxytag: member="Xfc::G::IOChannel::get_buffer_size" ref="810a805411346a4d737b9d3410c59d5a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Xfc::G::IOChannel::get_buffer_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the buffer size. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The size of the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c2c24453102d1caa3d7fce5cc1f1953d"></a><!-- doxytag: member="Xfc::G::IOChannel::get_buffer_condition" ref="c2c24453102d1caa3d7fce5cc1f1953d" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#0a164d71cfd9c48b105d624868c62cc5">IOConditionField</a> Xfc::G::IOChannel::get_buffer_condition           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets an IOCondition depending on whether there is data to be read/space to write data in the internal buffers in the <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="namespaceXfc_1_1G.html#4b74b37de986eb7a5ab17f9ea6e45fd1">G::IOCondition</a>.</dd></dl>
Note only the flags IO_IN and IO_OUT may be set. 
</div>
</div><p>
<a class="anchor" name="b044514cee3252ee06e30c4a67d3385a"></a><!-- doxytag: member="Xfc::G::IOChannel::get_flags" ref="b044514cee3252ee06e30c4a67d3385a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#f9622492d26cf492fefb726a3c1ad0fe">IOFlagsField</a> Xfc::G::IOChannel::get_flags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current flags for the channel, including read-only flags such as IO_FLAG_IS_READABLE. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="namespaceXfc_1_1G.html#72d5c15d5e441df4c1fd7fbb46e47dcd">G::IOFlags</a> which are set on the channel.</dd></dl>
The values of the flags IO_FLAG_IS_READABLE and IO_FLAG_IS_WRITEABLE are cached for internal use by the channel when it is created. If they should change at some later point (e.g. partial shutdown of a socket with the UNIX shutdown() function), the user should immediately call <a class="el" href="classXfc_1_1G_1_1IOChannel.html#b044514cee3252ee06e30c4a67d3385a">get_flags()</a> to update the internal values of these flags. 
</div>
</div><p>
<a class="anchor" name="b806f0aff1a7f5f9cc09388bb4413ba4"></a><!-- doxytag: member="Xfc::G::IOChannel::get_line_term" ref="b806f0aff1a7f5f9cc09388bb4413ba4" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::G::IOChannel::get_line_term           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the string that the channel uses to determine where in the file a line break occurs. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The line termination string (a null <a class="el" href="classXfc_1_1String.html">String</a> indicates auto detection). </dd></dl>

</div>
</div><p>
<a class="anchor" name="9799a8daaa761c0b4cd617483aaeb5cd"></a><!-- doxytag: member="Xfc::G::IOChannel::get_buffered" ref="9799a8daaa761c0b4cd617483aaeb5cd" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::IOChannel::get_buffered           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the channel is buffered. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the channel is buffered. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b49de3b3fd49d5babf477c7ce9b51b02"></a><!-- doxytag: member="Xfc::G::IOChannel::get_encoding" ref="b49de3b3fd49d5babf477c7ce9b51b02" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::G::IOChannel::get_encoding           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the encoding for the input/output of the channel. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A string containing the encoding.</dd></dl>
The internal encoding is always UTF-8. The encoding <em>null</em> makes the channel safe for binary data. 
</div>
</div><p>
<a class="anchor" name="82fe464489826af5da92b6b56922b63e"></a><!-- doxytag: member="Xfc::G::IOChannel::get_close_on_unref" ref="82fe464489826af5da92b6b56922b63e" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::IOChannel::get_close_on_unref           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the file/socket/whatever associated with the channel will be closed when the channel receives its final unref and is destroyed. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the channel will be closed on the final unref of the <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> data structure.</dd></dl>
The return value is <em>true</em> for channels created from a filename, and <em>false</em> for all other channels. 
</div>
</div><p>
<a class="anchor" name="5425a2b88daeef70eabaaf527aa72f31"></a><!-- doxytag: member="Xfc::G::IOChannel::get_fd" ref="5425a2b88daeef70eabaaf527aa72f31" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::G::IOChannel::get_fd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the file descriptor of the UNIX channel created by the <a class="el" href="classXfc_1_1G_1_1IOChannel.html#ccdf36612525bdd1452cb9af4543735c">create()</a> file descriptor method. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The file descriptor of the channel. </dd></dl>

</div>
</div><p>
<a class="anchor" name="45c8749367a15752d764807d172fea56"></a><!-- doxytag: member="Xfc::G::IOChannel::unref" ref="45c8749367a15752d764807d172fea56" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Xfc::G::IOChannel::unref           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decrease an IO channel's reference count by one. 
<p>
When the reference count becomes zero for a heap object delete is called. Remember, as with all XFC Objects you must call <a class="el" href="classXfc_1_1G_1_1IOChannel.html#45c8749367a15752d764807d172fea56">unref()</a> on a dynamically allocated <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a>, not delete. If you use a smart you don't need to call <a class="el" href="classXfc_1_1G_1_1IOChannel.html#45c8749367a15752d764807d172fea56">unref()</a>, the smart pointer will do that for you. You don't need to call <a class="el" href="classXfc_1_1G_1_1IOChannel.html#45c8749367a15752d764807d172fea56">unref()</a> on an <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a> allocated on the stack unless you first called <a class="el" href="classXfc_1_1G_1_1IOChannel.html#82fb9f3ab43adda13251d6e4b72881be">ref()</a>. 
<p>
Reimplemented from <a class="el" href="classXfc_1_1Trackable.html#e3755b87fbff5a30350e2bf7492a62a0">Xfc::Trackable</a>.
</div>
</div><p>
<a class="anchor" name="2458e0243b3296f9cbf5a30d7a43582b"></a><!-- doxytag: member="Xfc::G::IOChannel::close" ref="2458e0243b3296f9cbf5a30d7a43582b" args="(bool flush, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::close           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close an IO channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flush</em>&nbsp;</td><td>Set <em>true</em> to flush pending data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location to store an IOChannelError </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation.</dd></dl>
Any pending data to be written will be flushed if <em>flush</em> is true. The channel will not be freed until the last reference is dropped using <a class="el" href="classXfc_1_1G_1_1IOChannel.html#45c8749367a15752d764807d172fea56">unref()</a>. Note that you don't need top call <a class="el" href="classXfc_1_1G_1_1IOChannel.html#45c8749367a15752d764807d172fea56">unref()</a> with smart pointers, the smart pointer does that for you. 
</div>
</div><p>
<a class="anchor" name="700c97096c74ff6c4aab9c229aa8a4bf"></a><!-- doxytag: member="Xfc::G::IOChannel::set_buffer_size" ref="700c97096c74ff6c4aab9c229aa8a4bf" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::IOChannel::set_buffer_size           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the buffer size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the buffer (0 == pick a good size). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0788b8eecc950a09d04893fb66e7f2dc"></a><!-- doxytag: member="Xfc::G::IOChannel::set_flags" ref="0788b8eecc950a09d04893fb66e7f2dc" args="(IOFlagsField flags, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::set_flags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1G.html#f9622492d26cf492fefb726a3c1ad0fe">IOFlagsField</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the (writeable) flags in the channel to (flags &amp; IO_CHANNEL_SET_MASK). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The <a class="el" href="namespaceXfc_1_1G.html#72d5c15d5e441df4c1fd7fbb46e47dcd">G::IOFlags</a> to set on the IO channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location to store an error of type IOChannelErro. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2840989b26bd5cbd2267c4ead5369f0b"></a><!-- doxytag: member="Xfc::G::IOChannel::set_line_term" ref="2840989b26bd5cbd2267c4ead5369f0b" args="(const String &amp;line_term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::IOChannel::set_line_term           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>line_term</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This sets the string that the channel uses to determine where in the file a line break occurs. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line_term</em>&nbsp;</td><td>The line termination string (use null for auto detect).</td></tr>
  </table>
</dl>
Auto detection breaks on "\n", "\r\n", "\r", "\0", and the Unicode paragraph separator. Auto detection should not be used for anything other than file-based channels. 
</div>
</div><p>
<a class="anchor" name="cb074468a974020a150c941decaa35ee"></a><!-- doxytag: member="Xfc::G::IOChannel::set_buffered" ref="cb074468a974020a150c941decaa35ee" args="(bool buffered)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::IOChannel::set_buffered           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>buffered</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the buffering state of the channel (the default state is buffered). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffered</em>&nbsp;</td><td>Whether to set the channel buffered or unbuffered.</td></tr>
  </table>
</dl>
The buffering state can only be set if the channel's encoding is null. For any other encoding, the channel must be buffered. A buffered channel can only be set unbuffered if the channel's internal buffers have been flushed. Newly created channels or channels which have returned IO_STATUS_EOF do not require such a flush. For write-only channels, a call to <a class="el" href="classXfc_1_1G_1_1IOChannel.html#82eb2e9470ae0b97ee612ca8103e64c4">flush()</a> is sufficient. For all other channels, the buffers may be flushed by a call to <a class="el" href="classXfc_1_1G_1_1IOChannel.html#d63aa17f420862a6763b80541bfcab80">seek()</a>. This includes the possibility of seeking with seek type IO_SEEK_CUR and an offset of zero. Note that this means that socket-based channels cannot be set unbuffered once they have had data read from them. 
</div>
</div><p>
<a class="anchor" name="3e30eed6e6fd3376bcb350c2085ab853"></a><!-- doxytag: member="Xfc::G::IOChannel::set_encoding" ref="3e30eed6e6fd3376bcb350c2085ab853" args="(const char *encoding, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::set_encoding           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the encoding for the input/output of the channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>The encoding type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location to store an error of type GConvertError. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>IO_STATUS_NORMAL if the encoding was successfully set.</dd></dl>
The internal encoding is always UTF-8. The default encoding for the external file is UTF-8. The encoding 'null' is safe to use with binary data. The encoding can only be set if one of the following conditions is true:<ol type=1>
<li>The channel was just created, and has not been written to or read from yet.</li><li>The channel is write-only.</li><li>The channel is a file, and the file pointer was just repositioned by a call to <a class="el" href="classXfc_1_1G_1_1IOChannel.html#d63aa17f420862a6763b80541bfcab80">seek()</a> (this flushes all the internal buffers).</li><li>The current encoding is NULL or UTF-8.</li><li>One of the read functions has just returned IO_STATUS_EOF (or, in the case of <a class="el" href="classXfc_1_1G_1_1IOChannel.html#46c8673d136058371d4ecd194ddf90cc">read_to_end()</a>, IO_STATUS_NORMAL).</li><li>One of the <a class="el" href="classXfc_1_1G_1_1IOChannel.html#5d35ba545f478fd369831e237773bbbc">read()</a> methods has returned IO_STATUS_AGAIN or IO_STATUS_ERROR. This may be useful in the case of G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Returning one of these statuses from <a class="el" href="classXfc_1_1G_1_1IOChannel.html#5186b790a4d7ffbf8879d2b087dfd0b0">read_line()</a> or <a class="el" href="classXfc_1_1G_1_1IOChannel.html#46c8673d136058371d4ecd194ddf90cc">read_to_end()</a> does not guarantee that the encoding can be changed. Channels which do not meet one of the above conditions cannot call seek with an offset of IO_SEEK_CUR, and, if they are "seekable", cannot call write after calling one of the <a class="el" href="classXfc_1_1G_1_1IOChannel.html#5d35ba545f478fd369831e237773bbbc">read()</a> methods. </li></ol>

</div>
</div><p>
<a class="anchor" name="8edbd29b0ce4aa7d223260ba5e9bffa2"></a><!-- doxytag: member="Xfc::G::IOChannel::set_close_on_unref" ref="8edbd29b0ce4aa7d223260ba5e9bffa2" args="(bool do_close)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::IOChannel::set_close_on_unref           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_close</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setting this flag to true for a channel you have already closed can cause problems. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>do_close</em>&nbsp;</td><td>Whether to close the channel on the final unref of the GIOChannel data structure.</td></tr>
  </table>
</dl>
The default value is <em>true</em> for channels created by the <a class="el" href="classXfc_1_1G_1_1IOChannel.html#ccdf36612525bdd1452cb9af4543735c">create()</a> filename method, and <em>false</em> for all other channels. 
</div>
</div><p>
<a class="anchor" name="82eb2e9470ae0b97ee612ca8103e64c4"></a><!-- doxytag: member="Xfc::G::IOChannel::flush" ref="82eb2e9470ae0b97ee612ca8103e64c4" args="(G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::flush           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flushes the write buffer for the channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location to store an error of type <a class="el" href="namespaceXfc_1_1G.html#03128d178fa8356c85974a7d158a22dc">G::IOChannelError</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation: One of IO_CHANNEL_NORMAL, IO_CHANNEL_AGAIN, or IO_CHANNEL_ERROR. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5186b790a4d7ffbf8879d2b087dfd0b0"></a><!-- doxytag: member="Xfc::G::IOChannel::read_line" ref="5186b790a4d7ffbf8879d2b087dfd0b0" args="(String &amp;str, size_t *bytes_read, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::read_line           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a line, including the terminating character(s), from a channel into <a class="el" href="classXfc_1_1String.html">String</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The line read from the <a class="el" href="classXfc_1_1G_1_1IOChannel.html">IOChannel</a>, including the line terminator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_read</em>&nbsp;</td><td>The number of bytes read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>A location to return an error of type GConvertError or IOChannelError. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="46c8673d136058371d4ecd194ddf90cc"></a><!-- doxytag: member="Xfc::G::IOChannel::read_to_end" ref="46c8673d136058371d4ecd194ddf90cc" args="(String &amp;str, size_t *bytes_read, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::read_to_end           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads data from a channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1String.html">String</a> to read the data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_read</em>&nbsp;</td><td>The number of bytes read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>A location to return an error of type GConvertError or <a class="el" href="namespaceXfc_1_1G.html#03128d178fa8356c85974a7d158a22dc">G::IOChannelError</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d35ba545f478fd369831e237773bbbc"></a><!-- doxytag: member="Xfc::G::IOChannel::read" ref="5d35ba545f478fd369831e237773bbbc" args="(char *buffer, size_t count, size_t *bytes_read, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::read           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads data from a channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A buffer to read data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The size of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_read</em>&nbsp;</td><td>The number of bytes read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>A location to return an error of type GConvertError or <a class="el" href="namespaceXfc_1_1G.html#03128d178fa8356c85974a7d158a22dc">G::IOChannelError</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation.</dd></dl>
Note that the buffer may not be complelely filled even if there is data in the buffer if the remaining data is not a complete character. The <em>bytes_read</em> may be zero even on success if <em>count</em> &lt; 6 and the channel's encoding is non-null. This indicates that the next UTF-8 character is too wide for the buffer. 
</div>
</div><p>
<a class="anchor" name="b397cad627cc4d41c78986b3d674acf3"></a><!-- doxytag: member="Xfc::G::IOChannel::read" ref="b397cad627cc4d41c78986b3d674acf3" args="(String &amp;str, size_t *bytes_read, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads at most <em>count</em> data from a channel into a <a class="el" href="classXfc_1_1String.html">String</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1String.html">String</a> to read the data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_read</em>&nbsp;</td><td>The number of bytes read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>A location to return an error of type GConvertError or <a class="el" href="namespaceXfc_1_1G.html#03128d178fa8356c85974a7d158a22dc">G::IOChannelError</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation.</dd></dl>
Note that the buffer may not be complelely filled even if there is data in the buffer if the remaining data is not a complete character. 
</div>
</div><p>
<a class="anchor" name="5fa6af07b4c1f734329cac0c7a1c224a"></a><!-- doxytag: member="Xfc::G::IOChannel::read" ref="5fa6af07b4c1f734329cac0c7a1c224a" args="(G::Unichar &amp;unichar, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unichar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method cannot be called on a channel with a null encoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unichar</em>&nbsp;</td><td>A location to return a unicode character. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>A location to return an error of type GConvertError or <a class="el" href="namespaceXfc_1_1G.html#03128d178fa8356c85974a7d158a22dc">G::IOChannelError</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="178c49430166a1ff8305c20aa1ff9e36"></a><!-- doxytag: member="Xfc::G::IOChannel::write" ref="178c49430166a1ff8305c20aa1ff9e36" args="(const char *buffer, size_t count, size_t *bytes_written, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::write           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_written</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes data to a channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A buffer to write data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The size of the buffer. If -1, the buffer is taken to be a null-terminated string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_written</em>&nbsp;</td><td>The location to store the number of bytes written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>A location to return an error of type GConvertError or <a class="el" href="namespaceXfc_1_1G.html#03128d178fa8356c85974a7d158a22dc">G::IOChannelError</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation.</dd></dl>
On seekable channels with encodings other than null or UTF-8, generic mixing of reading and writing is not allowed. A call to <a class="el" href="classXfc_1_1G_1_1IOChannel.html#178c49430166a1ff8305c20aa1ff9e36">write()</a> may only be made on a channel from which data has been read in the cases described in the documentation for <a class="el" href="classXfc_1_1G_1_1IOChannel.html#3e30eed6e6fd3376bcb350c2085ab853">set_encoding()</a>.<p>
The <em>bytes_read</em> can be nonzero even if the return value is not G_IO_STATUS_NORMAL. If the return value is G_IO_STATUS_NORMAL and the channel is blocking, <em>bytes_read</em> will always be equal to count if count &gt;= 0. 
</div>
</div><p>
<a class="anchor" name="f438dd9e64329319c8f9d6bfc39c8cca"></a><!-- doxytag: member="Xfc::G::IOChannel::write" ref="f438dd9e64329319c8f9d6bfc39c8cca" args="(const String &amp;str, size_t *bytes_written, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::write           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_written</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a <a class="el" href="classXfc_1_1String.html">String</a> to a channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1String.html">String</a> to write from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_written</em>&nbsp;</td><td>The location to store the number of bytes written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>A location to return an error of type GConvertError or <a class="el" href="namespaceXfc_1_1G.html#03128d178fa8356c85974a7d158a22dc">G::IOChannelError</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation.</dd></dl>
On seekable channels with encodings other than null or UTF-8, generic mixing of reading and writing is not allowed. A call to <a class="el" href="classXfc_1_1G_1_1IOChannel.html#178c49430166a1ff8305c20aa1ff9e36">write()</a> may only be made on a channel from which the <a class="el" href="classXfc_1_1String.html">String</a> has been read in the cases described in the documentation for <a class="el" href="classXfc_1_1G_1_1IOChannel.html#3e30eed6e6fd3376bcb350c2085ab853">set_encoding()</a>. 
</div>
</div><p>
<a class="anchor" name="fb14a73ac76ca622ed057ca2b9a273c0"></a><!-- doxytag: member="Xfc::G::IOChannel::write" ref="fb14a73ac76ca622ed057ca2b9a273c0" args="(G::Unichar unichar, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::write           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a>&nbsp;</td>
          <td class="paramname"> <em>unichar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method cannot be called on a channel with a null encoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unichar</em>&nbsp;</td><td>A unicode character. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>A location to return an error of type GConvertError or <a class="el" href="namespaceXfc_1_1G.html#03128d178fa8356c85974a7d158a22dc">G::IOChannelError</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d63aa17f420862a6763b80541bfcab80"></a><!-- doxytag: member="Xfc::G::IOChannel::seek" ref="d63aa17f420862a6763b80541bfcab80" args="(gint64 offset, SeekType type, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1G.html#b252832325f95413dbb2578a828417d5">IOStatus</a> Xfc::G::IOChannel::seek           </td>
          <td>(</td>
          <td class="paramtype">gint64&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1G.html#fe9fe589e1e5eda6fa94e11096d8e74a">SeekType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the current position in the channel, similar to the standard library function fseek(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset in bytes from the position specified by type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>A SeekType. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>A location to return an error of type <a class="el" href="namespaceXfc_1_1G.html#03128d178fa8356c85974a7d158a22dc">G::IOChannelError</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation.</dd></dl>
The <a class="el" href="namespaceXfc_1_1G.html#fe9fe589e1e5eda6fa94e11096d8e74a">G::SeekType</a> IO_SEEK_CUR is only allowed in those cases where a call to <a class="el" href="classXfc_1_1G_1_1IOChannel.html#3e30eed6e6fd3376bcb350c2085ab853">set_encoding()</a> is allowed. See the documentation for <a class="el" href="classXfc_1_1G_1_1IOChannel.html#3e30eed6e6fd3376bcb350c2085ab853">set_encoding()</a> for details. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="iochannel_8hh.html">iochannel.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
