<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html">MarkupParseContext</a></div>
<h1>Xfc::G::MarkupParseContext Class Reference</h1><!-- doxytag: class="Xfc::G::MarkupParseContext" --><!-- doxytag: inherits="Xfc::Object" -->A GMarkupParseContext C++ wrapper interface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/markup.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::G::MarkupParseContext:
<p><center><img src="classXfc_1_1G_1_1MarkupParseContext.png" usemap="#Xfc::G::MarkupParseContext_map" border="0" alt=""></center>
<map name="Xfc::G::MarkupParseContext_map">
<area href="classXfc_1_1Object.html" alt="Xfc::Object" shape="rect" coords="0,56,171,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,171,24">
</map>
<a href="classXfc_1_1G_1_1MarkupParseContext-members.html">List of all members.</a><h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="e390c33f0791ee7c0d6f5d647dbd07b0"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::g_markup_parse_context" ref="e390c33f0791ee7c0d6f5d647dbd07b0" args="() const" -->
GMarkupParseContext * <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#e390c33f0791ee7c0d6f5d647dbd07b0">g_markup_parse_context</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GMarkupParseContext object. <br></dl><li><a class="anchor" name="6016a0d710207cbf19cf7e75be752a99"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::operator GMarkupParseContext *" ref="6016a0d710207cbf19cf7e75be752a99" args="() const" -->
<a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#6016a0d710207cbf19cf7e75be752a99">operator GMarkupParseContext *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; Safely converts a <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html">G::MarkupParseContext</a> object into a GMarkupParseContext pointer. <br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#10c03cc6fb84a1893d1895cf366fca6b">get_element</a> () const
<dl class="el"><dd class="mdescRight">Retrieves the name of the currently open element.  <a href="#10c03cc6fb84a1893d1895cf366fca6b"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#410e0db312a3e4c7d18eb04830a1463f">get_position</a> (int *line_number, int *char_number) const
<dl class="el"><dd class="mdescRight">Retrieves the current line number and the number of the character on that line.  <a href="#410e0db312a3e4c7d18eb04830a1463f"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>bool <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#eb8d47e0556336bf6e766f8c900d6b25">parse</a> (const char *text, int length, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error)
<dl class="el"><dd class="mdescRight">Feed some data to the <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html">MarkupParseContext</a>.  <a href="#eb8d47e0556336bf6e766f8c900d6b25"></a><br></dl><li>bool <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#5a23374adb2af88cf32653efbbdd8ce0">parse</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error)
<dl class="el"><dd class="mdescRight">Feed some data to the <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html">MarkupParseContext</a>.  <a href="#5a23374adb2af88cf32653efbbdd8ce0"></a><br></dl><li>bool <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#dce0a173f3cca4a952020db639079818">end_parse</a> (<a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error)
<dl class="el"><dd class="mdescRight">Signals to the <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html">MarkupParseContext</a> that all data has been fed into the parse context with <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#eb8d47e0556336bf6e766f8c900d6b25">parse()</a>.  <a href="#dce0a173f3cca4a952020db639079818"></a><br></dl></ul>
<h2>Static Public Member Functions</h2>
<ul>
<li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#018964de44e22f2abc6211625432c30a">escape_text</a> (const char *text, int length)
<dl class="el"><dd class="mdescRight">Escapes text so that the markup parser will parse it verbatim.  <a href="#018964de44e22f2abc6211625432c30a"></a><br></dl><li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#d3d2089f1e6463c3a88cbb28b7faccdb">escape_text</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text)
<dl class="el"><dd class="mdescRight">Escapes text so that the markup parser will parse it verbatim.  <a href="#d3d2089f1e6463c3a88cbb28b7faccdb"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GMarkupParseContext C++ wrapper interface. 
<p>
The markup parser is intended to parse a simple markup format that's a subset of XML. This is a small, efficient, easy-to-use parser. It should not be used if you expect to interoperate with other applications generating full-scale XML. However, it's very useful for application data files, config files, etc. where you know your application will be the only one writing the file. Full-scale XML parsers should be able to parse the subset used by <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html">MarkupParseContext</a>, so you can easily migrate to full-scale XML at a later time if the need arises.<p>
The markup parser is not guaranteed to signal an error on all invalid XML; the parser may accept documents that an XML parser would not. However, invalid XML documents are not considered valid markup documents.<p>
Simplifications to XML include:<ul>
<li>Only UTF-8 encoding is allowed.</li><li>No user-defined entities.</li><li>Processing instructions, comments and the doctype declaration are "passed through" but are not interpreted in any way.</li><li>No DTD or validation.</li></ul>
<p>
The markup format does support:<ul>
<li>Elements.</li><li>Attributes.</li><li>5 standard entities: &amp; &lt; &gt; " '</li><li>Character references.</li><li>Sections marked as CDATA. </li></ul>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="72827514af0c7536e179a50abe938dc0"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::MarkupParseContext" ref="72827514af0c7536e179a50abe938dc0" args="(MarkupParser &amp;parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::MarkupParseContext::MarkupParseContext           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1MarkupParser.html">MarkupParser</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new parse context. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1G_1_1MarkupParser.html">MarkupParser</a>.</td></tr>
  </table>
</dl>
A parse context is used to parse marked-up documents. You can feed any number of documents into a context, as long as no errors occur; once an error occurs, the parse context can't continue to parse text. You have to delete the parse context and construct a new one. The easiest way to do this is to use a smart pointer. If an error occurs construct a new parse context and assign it to the existing smart pointer. The smart pointer will delete the previous parse context first and then take over the new one. 
</div>
</div><p>
<a class="anchor" name="17e066522f5b5265b9f4e822b7e27880"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::MarkupParseContext" ref="17e066522f5b5265b9f4e822b7e27880" args="(GMarkupParseContext *context, bool can_free)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::MarkupParseContext::MarkupParseContext           </td>
          <td>(</td>
          <td class="paramtype">GMarkupParseContext *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>can_free</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new parse context from an existing GMarkupParseContext. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>A pointer to a GMarkupParseContext. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>can_free</em>&nbsp;</td><td>Set <em>true</em> if context should be freed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="72827514af0c7536e179a50abe938dc0"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::MarkupParseContext" ref="72827514af0c7536e179a50abe938dc0" args="(MarkupParser &amp;parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::MarkupParseContext::MarkupParseContext           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1MarkupParser.html">MarkupParser</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new parse context. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1G_1_1MarkupParser.html">MarkupParser</a>.</td></tr>
  </table>
</dl>
A parse context is used to parse marked-up documents. You can feed any number of documents into a context, as long as no errors occur; once an error occurs, the parse context can't continue to parse text. You have to delete the parse context and construct a new one. The easiest way to do this is to use a smart pointer. If an error occurs construct a new parse context and assign it to the existing smart pointer. The smart pointer will delete the previous parse context first and then take over the new one. 
</div>
</div><p>
<a class="anchor" name="17e066522f5b5265b9f4e822b7e27880"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::MarkupParseContext" ref="17e066522f5b5265b9f4e822b7e27880" args="(GMarkupParseContext *context, bool can_free)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::MarkupParseContext::MarkupParseContext           </td>
          <td>(</td>
          <td class="paramtype">GMarkupParseContext *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>can_free</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new parse context from an existing GMarkupParseContext. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>A pointer to a GMarkupParseContext. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>can_free</em>&nbsp;</td><td>Set <em>true</em> if context should be freed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="10c03cc6fb84a1893d1895cf366fca6b"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::get_element" ref="10c03cc6fb84a1893d1895cf366fca6b" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::G::MarkupParseContext::get_element           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the name of the currently open element. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The name of the currently open element, or null. </dd></dl>

</div>
</div><p>
<a class="anchor" name="410e0db312a3e4c7d18eb04830a1463f"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::get_position" ref="410e0db312a3e4c7d18eb04830a1463f" args="(int *line_number, int *char_number) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::MarkupParseContext::get_position           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>line_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>char_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the current line number and the number of the character on that line. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line_number</em>&nbsp;</td><td>The return location for a line number, or null; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>char_number</em>&nbsp;</td><td>The return location for a char-on-line number, or null;</td></tr>
  </table>
</dl>
Intended for use in error messages; there are no strict semantics for what constitutes the "current" line number other than "the best number we could come up with for error messages." 
</div>
</div><p>
<a class="anchor" name="eb8d47e0556336bf6e766f8c900d6b25"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::parse" ref="eb8d47e0556336bf6e766f8c900d6b25" args="(const char *text, int length, G::Error *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::MarkupParseContext::parse           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Feed some data to the <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html">MarkupParseContext</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The chunk of text to parse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of <em>text</em> in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>false</em> if an error occurred, <em>true</em> on success.</dd></dl>
The data need not be valid UTF-8; an error will be signaled if it's invalid. The data need not be an entire document; you can feed a document into the parser incrementally, via multiple calls to this function. Typically, as you receive data from a network connection or file, you feed each received chunk of data into this function, aborting the process if an error occurs. Once an error is reported, no further data may be fed to the <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html">MarkupParseContext</a>; all errors are fatal. 
</div>
</div><p>
<a class="anchor" name="5a23374adb2af88cf32653efbbdd8ce0"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::parse" ref="5a23374adb2af88cf32653efbbdd8ce0" args="(const String &amp;text, G::Error *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::MarkupParseContext::parse           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Feed some data to the <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html">MarkupParseContext</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The chunk of text to parse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>false</em> if an error occurred, <em>true</em> on success.</dd></dl>
See <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#eb8d47e0556336bf6e766f8c900d6b25">parse(const char*, int, G::Error*)</a> for details. 
</div>
</div><p>
<a class="anchor" name="dce0a173f3cca4a952020db639079818"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::end_parse" ref="dce0a173f3cca4a952020db639079818" args="(G::Error *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::MarkupParseContext::end_parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signals to the <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html">MarkupParseContext</a> that all data has been fed into the parse context with <a class="el" href="classXfc_1_1G_1_1MarkupParseContext.html#eb8d47e0556336bf6e766f8c900d6b25">parse()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> on success, <em>false</em> if an error was set.</dd></dl>
This method reports an error if the document isn't complete, for example if elements are still open. 
</div>
</div><p>
<a class="anchor" name="018964de44e22f2abc6211625432c30a"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::escape_text" ref="018964de44e22f2abc6211625432c30a" args="(const char *text, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::G::MarkupParseContext::escape_text           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Escapes text so that the markup parser will parse it verbatim. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>Some valid UTF-8 text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of <em>text</em> in bytes. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1String.html">String</a> holding the escaped text.</dd></dl>
Less than, greater than, ampersand, etc. are replaced with the corresponding entities. This method would typically be used when writing out a file to be parsed with the markup parser. 
</div>
</div><p>
<a class="anchor" name="d3d2089f1e6463c3a88cbb28b7faccdb"></a><!-- doxytag: member="Xfc::G::MarkupParseContext::escape_text" ref="d3d2089f1e6463c3a88cbb28b7faccdb" args="(const String &amp;text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::G::MarkupParseContext::escape_text           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Escapes text so that the markup parser will parse it verbatim. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>Some valid UTF-8 text. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1String.html">String</a> holding the escaped text.</dd></dl>
Less than, greater than, ampersand, etc. are replaced with the corresponding entities. This method would typically be used when writing out a file to be parsed with the markup parser. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="markup_8hh.html">markup.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
