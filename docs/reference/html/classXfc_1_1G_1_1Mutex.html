<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="classXfc_1_1G_1_1Mutex.html">Mutex</a></div>
<h1>Xfc::G::Mutex Class Reference</h1><!-- doxytag: class="Xfc::G::Mutex" --><!-- doxytag: inherits="Xfc::Object" -->A GMutex C++ wrapper interface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/mutex.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::G::Mutex:
<p><center><img src="classXfc_1_1G_1_1Mutex.png" usemap="#Xfc::G::Mutex_map" border="0" alt=""></center>
<map name="Xfc::G::Mutex_map">
<area href="classXfc_1_1Object.html" alt="Xfc::Object" shape="rect" coords="0,56,94,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,94,24">
</map>
<a href="classXfc_1_1G_1_1Mutex-members.html">List of all members.</a><h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="25bbdb9eca191781b4b7fe22edc1f3ff"></a><!-- doxytag: member="Xfc::G::Mutex::g_mutex" ref="25bbdb9eca191781b4b7fe22edc1f3ff" args="() const" -->
GMutex * <a class="el" href="classXfc_1_1G_1_1Mutex.html#25bbdb9eca191781b4b7fe22edc1f3ff">g_mutex</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GMutex object. <br></dl><li><a class="anchor" name="3b3e2891e30db1b7a78d228b121079e4"></a><!-- doxytag: member="Xfc::G::Mutex::operator GMutex *" ref="3b3e2891e30db1b7a78d228b121079e4" args="() const" -->
<a class="el" href="classXfc_1_1G_1_1Mutex.html#3b3e2891e30db1b7a78d228b121079e4">operator GMutex *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; Safely converts a <a class="el" href="classXfc_1_1G_1_1Mutex.html">G::Mutex</a> object into a GMutex pointer. <br></dl><li>bool <a class="el" href="classXfc_1_1G_1_1Mutex.html#8e7025008836787f151bac41261f6a97">is_locked</a> () const
<dl class="el"><dd class="mdescRight">Determines whether the mutex is locked.  <a href="#8e7025008836787f151bac41261f6a97"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1G_1_1Mutex.html#8e6e168031bcaf8e0f0f61ceba3378ac">lock</a> ()
<dl class="el"><dd class="mdescRight">Locks the mutex.  <a href="#8e6e168031bcaf8e0f0f61ceba3378ac"></a><br></dl><li>bool <a class="el" href="classXfc_1_1G_1_1Mutex.html#6b38665269d352ea3b994c5fcdae8555">trylock</a> ()
<dl class="el"><dd class="mdescRight">Tries to lock the mutex.  <a href="#6b38665269d352ea3b994c5fcdae8555"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1Mutex.html#e663f35cba9cc3bbf0453bed222c738e">unlock</a> ()
<dl class="el"><dd class="mdescRight">Unlocks the mutex.  <a href="#e663f35cba9cc3bbf0453bed222c738e"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GMutex C++ wrapper interface. 
<p>
<b><a class="el" href="classXfc_1_1G_1_1Mutex.html">Mutex</a></b> is an object that represents a mutex (mutual exclusion). It can be used to protect data against shared access. Take for example the following function:<p>
<b>Example 1:</b>. A method which will not work in a threaded environment. <div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> give_me_next_number()
 {
        <span class="keyword">static</span> <span class="keywordtype">int</span> current_number = 0;

        <span class="comment">// now do a very complicated calculation to calculate the new number,</span>
        <span class="comment">// this might for example be a random number generator.</span>
        current_number = calc_next_number(current_number);
        <span class="keywordflow">return</span> current_number;
 }
</pre></div><p>
It is easy to see, that this won't work in a multi-threaded application. There <em>current_number</em> must be protected against shared access. A first naive implementation would be:<p>
<b>Example 2:</b> The wrong way to write a thread-safe method. <div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> give_me_next_number ()
 {
        <span class="keyword">static</span> <span class="keywordtype">int</span> current_number = 0;

        G::Mutex *mutex = 0;
        <span class="keywordflow">if</span> (!mutex)
                mutex = <span class="keyword">new</span> G::Mutex;

        mutex-&gt;lock();
        <span class="keywordtype">int</span> result = current_number = calc_next_number(current_number);
        mutex-&gt;unlock();
        <span class="keywordflow">return</span> result;
 }
</pre></div><p>
This looks like it would work, but there is a race condition while constructing the mutex and this code cannot work reliably. So please do not use such constructs in your own programs. One working solution is:<p>
<b>Example 3:</b> A correct thread-safe method. <div class="fragment"><pre class="fragment"> G::Mutex *give_me_next_number_mutex = 0;

 <span class="comment">// This method must be called exactly once before any call to give_me_next_number().</span>
 <span class="keywordtype">void</span> init_give_me_next_number()
 {
        <span class="keywordflow">if</span> (!give_me_next_number_mutex)
                give_me_next_number_mutex = <span class="keyword">new</span> G::Mutex;
 }

 <span class="keywordtype">int</span> give_me_next_number()
 {
        <span class="keyword">static</span> <span class="keywordtype">int</span> current_number = 0;
        give_me_next_number_mutex-&gt;lock();
        <span class="keywordtype">int</span> result = current_number = calc_next_number(current_number);
        give_me_next_number_mutex-&gt;unlock();
        <span class="keywordflow">return</span> result;
 }
</pre></div> 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="3dcc21623e4b76270bd72ef1fa917fcb"></a><!-- doxytag: member="Xfc::G::Mutex::Mutex" ref="3dcc21623e4b76270bd72ef1fa917fcb" args="(bool lock_mutex=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::Mutex::Mutex           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lock_mutex</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new mutex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock_mutex</em>&nbsp;</td><td>Whether to lock the mutex at construction time.</td></tr>
  </table>
</dl>
If the mutex is locked at construction time it will automatically be unlocked when it goes out of scope. <b>Note</b> this constructor will abort, if <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">G::Thread::init()</a> has not been called yet. 
</div>
</div><p>
<a class="anchor" name="3dcc21623e4b76270bd72ef1fa917fcb"></a><!-- doxytag: member="Xfc::G::Mutex::Mutex" ref="3dcc21623e4b76270bd72ef1fa917fcb" args="(bool lock_mutex=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::Mutex::Mutex           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lock_mutex</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new mutex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock_mutex</em>&nbsp;</td><td>Whether to lock the mutex at construction time.</td></tr>
  </table>
</dl>
If the mutex is locked at construction time it will automatically be unlocked when it goes out of scope. <b>Note</b> this constructor will abort, if <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">G::Thread::init()</a> has not been called yet. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8e7025008836787f151bac41261f6a97"></a><!-- doxytag: member="Xfc::G::Mutex::is_locked" ref="8e7025008836787f151bac41261f6a97" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::Mutex::is_locked           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the mutex is locked. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the mutex is locked. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8e6e168031bcaf8e0f0f61ceba3378ac"></a><!-- doxytag: member="Xfc::G::Mutex::lock" ref="8e6e168031bcaf8e0f0f61ceba3378ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Mutex::lock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks the mutex. 
<p>
If mutex is already locked by another thread, the current thread will block until the mutex is unlocked by the other thread. This method can also be used if <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">G::Thread::init()</a> has not yet been called, in which case it will do nothing.<p>
<b>Note</b> <a class="el" href="classXfc_1_1G_1_1Mutex.html">Mutex</a> is neither guaranteed to be recursive nor to be non-recursive, that is, a thread could deadlock while calling <a class="el" href="classXfc_1_1G_1_1Mutex.html#8e6e168031bcaf8e0f0f61ceba3378ac">lock()</a>, if it already has locked the mutex. Use <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html">G::StaticRecMutex</a>, if you need a recursive mutex. 
</div>
</div><p>
<a class="anchor" name="6b38665269d352ea3b994c5fcdae8555"></a><!-- doxytag: member="Xfc::G::Mutex::trylock" ref="6b38665269d352ea3b994c5fcdae8555" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::Mutex::trylock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to lock the mutex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if mutex could be locked.</dd></dl>
If the mutex is already locked by another thread, it immediately returns false. Otherwise it locks mutex and returns true. This method can also be used if <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">G::Thread::init()</a> has not yet been called, in which case it will immediately return true.<p>
<b>Note</b> <a class="el" href="classXfc_1_1G_1_1Mutex.html">Mutex</a> is neither guaranteed to be recursive nor to be non-recursive, that is, the return value of <a class="el" href="classXfc_1_1G_1_1Mutex.html#6b38665269d352ea3b994c5fcdae8555">trylock()</a> could be both false or true, if the current thread already has locked the mutex. Use <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html">G::StaticRecMutex</a>, if you need a recursive mutex. 
</div>
</div><p>
<a class="anchor" name="e663f35cba9cc3bbf0453bed222c738e"></a><!-- doxytag: member="Xfc::G::Mutex::unlock" ref="e663f35cba9cc3bbf0453bed222c738e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Mutex::unlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlocks the mutex. 
<p>
If another thread is blocked in a <a class="el" href="classXfc_1_1G_1_1Mutex.html#8e6e168031bcaf8e0f0f61ceba3378ac">lock()</a> call for the mutex, it will be woken and can lock the mutex itself. This method can also be used if <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">G::Thread::init()</a> has not yet been called, in which case it will do nothing. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="mutex_8hh.html">mutex.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
