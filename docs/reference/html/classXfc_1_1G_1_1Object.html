<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="classXfc_1_1G_1_1Object.html">Object</a></div>
<h1>Xfc::G::Object Class Reference</h1><!-- doxytag: class="Xfc::G::Object" --><!-- doxytag: inherits="Xfc::G::TypeInstance" -->Base class for wrapped GTK+ objects and widgets.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/object.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::G::Object:
<p><center><img src="classXfc_1_1G_1_1Object.png" usemap="#Xfc::G::Object_map" border="0" alt=""></center>
<map name="Xfc::G::Object_map">
<area href="classXfc_1_1G_1_1TypeInstance.html" alt="Xfc::G::TypeInstance" shape="rect" coords="0,56,216,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,216,24">
<area href="classXfc_1_1Atk_1_1Hyperlink.html" alt="Xfc::Atk::Hyperlink" shape="rect" coords="226,168,442,192">
<area href="classXfc_1_1Atk_1_1Object.html" alt="Xfc::Atk::Object" shape="rect" coords="226,224,442,248">
<area href="classXfc_1_1Atk_1_1ObjectFactory.html" alt="Xfc::Atk::ObjectFactory" shape="rect" coords="226,280,442,304">
<area href="classXfc_1_1Atk_1_1Registry.html" alt="Xfc::Atk::Registry" shape="rect" coords="226,336,442,360">
<area href="classXfc_1_1Atk_1_1Relation.html" alt="Xfc::Atk::Relation" shape="rect" coords="226,392,442,416">
<area href="classXfc_1_1Atk_1_1RelationSet.html" alt="Xfc::Atk::RelationSet" shape="rect" coords="226,448,442,472">
<area href="classXfc_1_1Atk_1_1StateSet.html" alt="Xfc::Atk::StateSet" shape="rect" coords="226,504,442,528">
<area href="classXfc_1_1Gdk_1_1Colormap.html" alt="Xfc::Gdk::Colormap" shape="rect" coords="226,560,442,584">
<area href="classXfc_1_1Gdk_1_1Device.html" alt="Xfc::Gdk::Device" shape="rect" coords="226,616,442,640">
<area href="classXfc_1_1Gdk_1_1Display.html" alt="Xfc::Gdk::Display" shape="rect" coords="226,672,442,696">
<area href="classXfc_1_1Gdk_1_1DisplayManager.html" alt="Xfc::Gdk::DisplayManager" shape="rect" coords="226,728,442,752">
<area href="classXfc_1_1Gdk_1_1DragContext.html" alt="Xfc::Gdk::DragContext" shape="rect" coords="226,784,442,808">
<area href="classXfc_1_1Gdk_1_1Drawable.html" alt="Xfc::Gdk::Drawable" shape="rect" coords="226,840,442,864">
<area href="classXfc_1_1Gdk_1_1GC.html" alt="Xfc::Gdk::GC" shape="rect" coords="226,896,442,920">
<area href="classXfc_1_1Gdk_1_1Image.html" alt="Xfc::Gdk::Image" shape="rect" coords="226,952,442,976">
<area href="classXfc_1_1Gdk_1_1Keymap.html" alt="Xfc::Gdk::Keymap" shape="rect" coords="226,1008,442,1032">
<area href="classXfc_1_1Gdk_1_1Pixbuf.html" alt="Xfc::Gdk::Pixbuf" shape="rect" coords="226,1064,442,1088">
<area href="classXfc_1_1Gdk_1_1PixbufAnimation.html" alt="Xfc::Gdk::PixbufAnimation" shape="rect" coords="226,1120,442,1144">
<area href="classXfc_1_1Gdk_1_1PixbufAnimationIter.html" alt="Xfc::Gdk::PixbufAnimationIter" shape="rect" coords="226,1176,442,1200">
<area href="classXfc_1_1Gdk_1_1PixbufLoader.html" alt="Xfc::Gdk::PixbufLoader" shape="rect" coords="226,1232,442,1256">
<area href="classXfc_1_1Gdk_1_1Screen.html" alt="Xfc::Gdk::Screen" shape="rect" coords="226,1288,442,1312">
<area href="classXfc_1_1Gdk_1_1Visual.html" alt="Xfc::Gdk::Visual" shape="rect" coords="226,1344,442,1368">
<area href="classXfc_1_1Glade_1_1Xml.html" alt="Xfc::Glade::Xml" shape="rect" coords="226,1400,442,1424">
<area href="classXfc_1_1Gtk_1_1AccelGroup.html" alt="Xfc::Gtk::AccelGroup" shape="rect" coords="226,1456,442,1480">
<area href="classXfc_1_1Gtk_1_1AccelMap.html" alt="Xfc::Gtk::AccelMap" shape="rect" coords="226,1512,442,1536">
<area href="classXfc_1_1Gtk_1_1Action.html" alt="Xfc::Gtk::Action" shape="rect" coords="226,1568,442,1592">
<area href="classXfc_1_1Gtk_1_1ActionGroup.html" alt="Xfc::Gtk::ActionGroup" shape="rect" coords="226,1624,442,1648">
<area href="classXfc_1_1Gtk_1_1Clipboard.html" alt="Xfc::Gtk::Clipboard" shape="rect" coords="226,1680,442,1704">
<area href="classXfc_1_1Gtk_1_1EntryCompletion.html" alt="Xfc::Gtk::EntryCompletion" shape="rect" coords="226,1736,442,1760">
<area href="classXfc_1_1Gtk_1_1IconFactory.html" alt="Xfc::Gtk::IconFactory" shape="rect" coords="226,1792,442,1816">
<area href="classXfc_1_1Gtk_1_1IconTheme.html" alt="Xfc::Gtk::IconTheme" shape="rect" coords="226,1848,442,1872">
<area href="classXfc_1_1Gtk_1_1ListStore.html" alt="Xfc::Gtk::ListStore" shape="rect" coords="226,1904,442,1928">
<area href="classXfc_1_1Gtk_1_1Object.html" alt="Xfc::Gtk::Object" shape="rect" coords="226,1960,442,1984">
<area href="classXfc_1_1Gtk_1_1RcStyle.html" alt="Xfc::Gtk::RcStyle" shape="rect" coords="226,2016,442,2040">
<area href="classXfc_1_1Gtk_1_1Settings.html" alt="Xfc::Gtk::Settings" shape="rect" coords="226,2072,442,2096">
<area href="classXfc_1_1Gtk_1_1SizeGroup.html" alt="Xfc::Gtk::SizeGroup" shape="rect" coords="226,2128,442,2152">
<area href="classXfc_1_1Gtk_1_1SourceLanguage.html" alt="Xfc::Gtk::SourceLanguage" shape="rect" coords="226,2184,442,2208">
<area href="classXfc_1_1Gtk_1_1SourceLanguagesManager.html" alt="Xfc::Gtk::SourceLanguagesManager" shape="rect" coords="226,2240,442,2264">
<area href="classXfc_1_1Gtk_1_1SourcePrintJob.html" alt="Xfc::Gtk::SourcePrintJob" shape="rect" coords="226,2296,442,2320">
<area href="classXfc_1_1Gtk_1_1Style.html" alt="Xfc::Gtk::Style" shape="rect" coords="226,2352,442,2376">
<area href="classXfc_1_1Gtk_1_1TextBuffer.html" alt="Xfc::Gtk::TextBuffer" shape="rect" coords="226,2408,442,2432">
<area href="classXfc_1_1Gtk_1_1TextChildAnchor.html" alt="Xfc::Gtk::TextChildAnchor" shape="rect" coords="226,2464,442,2488">
<area href="classXfc_1_1Gtk_1_1TextMark.html" alt="Xfc::Gtk::TextMark" shape="rect" coords="226,2520,442,2544">
<area href="classXfc_1_1Gtk_1_1TextTag.html" alt="Xfc::Gtk::TextTag" shape="rect" coords="226,2576,442,2600">
<area href="classXfc_1_1Gtk_1_1TextTagTable.html" alt="Xfc::Gtk::TextTagTable" shape="rect" coords="226,2632,442,2656">
<area href="classXfc_1_1Gtk_1_1TreeModelFilter.html" alt="Xfc::Gtk::TreeModelFilter" shape="rect" coords="226,2688,442,2712">
<area href="classXfc_1_1Gtk_1_1TreeModelSort.html" alt="Xfc::Gtk::TreeModelSort" shape="rect" coords="226,2744,442,2768">
<area href="classXfc_1_1Gtk_1_1TreeSelection.html" alt="Xfc::Gtk::TreeSelection" shape="rect" coords="226,2800,442,2824">
<area href="classXfc_1_1Gtk_1_1TreeStore.html" alt="Xfc::Gtk::TreeStore" shape="rect" coords="226,2856,442,2880">
<area href="classXfc_1_1Gtk_1_1UIManager.html" alt="Xfc::Gtk::UIManager" shape="rect" coords="226,2912,442,2936">
<area href="classXfc_1_1Gtk_1_1WindowGroup.html" alt="Xfc::Gtk::WindowGroup" shape="rect" coords="226,2968,442,2992">
<area href="classXfc_1_1Pango_1_1Context.html" alt="Xfc::Pango::Context" shape="rect" coords="226,3024,442,3048">
<area href="classXfc_1_1Pango_1_1Font.html" alt="Xfc::Pango::Font" shape="rect" coords="226,3080,442,3104">
<area href="classXfc_1_1Pango_1_1FontFace.html" alt="Xfc::Pango::FontFace" shape="rect" coords="226,3136,442,3160">
<area href="classXfc_1_1Pango_1_1FontFamily.html" alt="Xfc::Pango::FontFamily" shape="rect" coords="226,3192,442,3216">
<area href="classXfc_1_1Pango_1_1FontMap.html" alt="Xfc::Pango::FontMap" shape="rect" coords="226,3248,442,3272">
<area href="classXfc_1_1Pango_1_1Fontset.html" alt="Xfc::Pango::Fontset" shape="rect" coords="226,3304,442,3328">
<area href="classXfc_1_1Pango_1_1Layout.html" alt="Xfc::Pango::Layout" shape="rect" coords="226,3360,442,3384">
<area href="classXfc_1_1Pango_1_1Renderer.html" alt="Xfc::Pango::Renderer" shape="rect" coords="226,3416,442,3440">
</map>
<a href="classXfc_1_1G_1_1Object-members.html">List of all members.</a><h2>Signal Prototypes</h2>
<ul>
<li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">NotifySignalType</a> <a class="el" href="classXfc_1_1G_1_1Object.html#5aac9357199d33b29be75675611ce52b">notify_signal</a>
<dl class="el"><dd class="mdescRight">Notify signal (see signal_notify()).  <a href="#5aac9357199d33b29be75675611ce52b"></a><br></dl></ul>
<h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="1906f0e47a99c0d30edf263a46314b98"></a><!-- doxytag: member="Xfc::G::Object::g_object" ref="1906f0e47a99c0d30edf263a46314b98" args="() const" -->
GObject * <a class="el" href="classXfc_1_1G_1_1Object.html#1906f0e47a99c0d30edf263a46314b98">g_object</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GObject structure. <br></dl><li><a class="anchor" name="77b547c6852eb2d3c9b0c6fda7f1b577"></a><!-- doxytag: member="Xfc::G::Object::operator GObject *" ref="77b547c6852eb2d3c9b0c6fda7f1b577" args="() const" -->
<a class="el" href="classXfc_1_1G_1_1Object.html#77b547c6852eb2d3c9b0c6fda7f1b577">operator GObject *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; safely converts a <a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> to a GObject pointer. <br></dl><li>void <a class="el" href="classXfc_1_1G_1_1Object.html#135b13900a2b1792a0b9740c16fb47a3">get_property</a> (const char *property_name, <a class="el" href="classXfc_1_1G_1_1Value.html">Value</a> &amp;value) const
<dl class="el"><dd class="mdescRight">Get a property of an object.  <a href="#135b13900a2b1792a0b9740c16fb47a3"></a><br></dl><li>void * <a class="el" href="classXfc_1_1G_1_1Object.html#5cd2be0de4548b8a905737713e444f26">get_data</a> (const <a class="el" href="classXfc_1_1G_1_1Quark.html">Quark</a> &amp;quark) const
<dl class="el"><dd class="mdescRight">Get a user data pointer set by calling set().  <a href="#5cd2be0de4548b8a905737713e444f26"></a><br></dl><li>void * <a class="el" href="classXfc_1_1G_1_1Object.html#91ca655f7f964355a7fc964f2d20602e">get_data</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;key) const
<dl class="el"><dd class="mdescRight">Get a user data pointer set by calling set().  <a href="#91ca655f7f964355a7fc964f2d20602e"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>virtual void <a class="el" href="classXfc_1_1G_1_1Object.html#47f87a1180f4950eba164d60aa281283">ref</a> ()
<dl class="el"><dd class="mdescRight">Increase the reference count of the object.  <a href="#47f87a1180f4950eba164d60aa281283"></a><br></dl><li>virtual void <a class="el" href="classXfc_1_1G_1_1Object.html#513fc400272db0db24d32f9a280e64a5">unref</a> ()
<dl class="el"><dd class="mdescRight">Decrease the reference count of the object.  <a href="#513fc400272db0db24d32f9a280e64a5"></a><br></dl><li>virtual void <a class="el" href="classXfc_1_1G_1_1Object.html#480842af7bdb77d761ae926b1f5584f7">dispose</a> ()
<dl class="el"><dd class="mdescRight">Finalize the object.  <a href="#480842af7bdb77d761ae926b1f5584f7"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1Object.html#9a2fe0562fae4691375fd929e8783699">set_property</a> (const char *property_name, const <a class="el" href="classXfc_1_1G_1_1Value.html">Value</a> &amp;value)
<dl class="el"><dd class="mdescRight">Set a property on an object.  <a href="#9a2fe0562fae4691375fd929e8783699"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1Object.html#b7e610618dfb2e6b7cc27e3c2601752d">set_data</a> (const <a class="el" href="classXfc_1_1G_1_1Quark.html">Quark</a> &amp;quark, void *data, GDestroyNotify destroy=0)
<dl class="el"><dd class="mdescRight">Set an opaque named pointer on an object.  <a href="#b7e610618dfb2e6b7cc27e3c2601752d"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1Object.html#fd13141ce1eff0667a7750239e7f301b">set_data</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;key, void *data, GDestroyNotify destroy=0)
<dl class="el"><dd class="mdescRight">Set an opaque named pointer on an object.  <a href="#fd13141ce1eff0667a7750239e7f301b"></a><br></dl><li>void * <a class="el" href="classXfc_1_1G_1_1Object.html#d7a5e227aaa1d02d7ff8f8facd6250a2">remove_data</a> (const <a class="el" href="classXfc_1_1G_1_1Quark.html">Quark</a> &amp;quark, bool notify=false)
<dl class="el"><dd class="mdescRight">Remove an opaque named pointer previously set on an object.  <a href="#d7a5e227aaa1d02d7ff8f8facd6250a2"></a><br></dl><li>void * <a class="el" href="classXfc_1_1G_1_1Object.html#d5a7345858bd5910a8f566ea3b9941ef">remove_data</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;key, bool notify=false)
<dl class="el"><dd class="mdescRight">Remove an opaque named pointer previously set on an object.  <a href="#d5a7345858bd5910a8f566ea3b9941ef"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Signal Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1G_1_1Object.html#690965e0ab31e8a61de67b6adf3698f5">emit_by_name</a> (const char *signal_name,...)
<dl class="el"><dd class="mdescRight">Emit a signal by name.  <a href="#690965e0ab31e8a61de67b6adf3698f5"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1Object.html#6e1c25f770e4b171cf8202aa3db2e8af">stop_emission_by_name</a> (const char *detailed_signal)
<dl class="el"><dd class="mdescRight">Aborts a signal's current emission by name.  <a href="#6e1c25f770e4b171cf8202aa3db2e8af"></a><br></dl><li>bool <a class="el" href="classXfc_1_1G_1_1Object.html#98bc135924c0b1ba8b63ba0ea6155ae1">disconnect_by_name</a> (const char *signal_name)
<dl class="el"><dd class="mdescRight">Disconnect a signal by name.  <a href="#98bc135924c0b1ba8b63ba0ea6155ae1"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Signal Proxies</div></td></tr>
<ul>
<li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">NotifySignalProxy</a> <a class="el" href="classXfc_1_1G_1_1Object.html#23d9be48be6cb44a0fee4cdec66114a9">signal_notify</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;property_name)
<dl class="el"><dd class="mdescRight">Connect to the notify_signal; emitted when a property on an object is changed.  <a href="#23d9be48be6cb44a0fee4cdec66114a9"></a><br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1G_1_1Object.html">Object</a> * <a class="el" href="classXfc_1_1G_1_1Object.html#847246f6472dce1d5a5cbea98f6d6878">pointer</a> (GObject *object)
<dl class="el"><dd class="mdescRight">Get the <a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> pointer for the specified GTK+ object.  <a href="#847246f6472dce1d5a5cbea98f6d6878"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Templates</div></td></tr>
<ul>
<li>template&lt;typename T, typename gObject&gt; static T * <a class="el" href="classXfc_1_1G_1_1Object.html#e7604dd7798c71fd24c7c1b72566a146">wrap</a> (gObject *object, bool owns_reference=false)
<dl class="el"><dd class="mdescRight">Wrap a GTK+ C object in as C++ wrapper class.  <a href="#e7604dd7798c71fd24c7c1b72566a146"></a><br></dl><li>template&lt;typename T, typename gObject&gt; static T * <a class="el" href="classXfc_1_1G_1_1Object.html#35b30133d4bfe56873907d65f80a7d93">wrap_new</a> (gObject *object, bool owns_reference=false)
<dl class="el"><dd class="mdescRight">Wrap a GTK+ C object in a C++ wrapper class.  <a href="#35b30133d4bfe56873907d65f80a7d93"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Base class for wrapped GTK+ objects and widgets. 
<p>
<a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> wraps the GTK+ stucture GObject and its associated functions. It is the base class from which most C++ wrappers for the various GTK+ objects and widgets are dervied. <a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> is derived from <a class="el" href="classXfc_1_1G_1_1TypeInstance.html">G::TypeInstance</a> and is a reference counted object. You reference a <a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> by calling <a class="el" href="classXfc_1_1G_1_1Object.html#47f87a1180f4950eba164d60aa281283">ref()</a>. This increments the internal reference counter. You unreference a <a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> by calling <a class="el" href="classXfc_1_1G_1_1Object.html#513fc400272db0db24d32f9a280e64a5">unref()</a>. This decrements the internal reference counter. Objects that derive directly from <a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> are created with a reference count of 1. This initial reference count is owned by you and must be unreferenced. Because you own the initial reference count you don't need to reference the object before using it, but you must remember to unreference it when your finished. When the reference count drops to zero the object is finialized and destroyed. If the object was a created on the heap, operator delete is called to destroy the object. <b>You must not call operator delete</b> yourself. To destroy an object you own a reference to you call <a class="el" href="classXfc_1_1G_1_1Object.html#513fc400272db0db24d32f9a280e64a5">unref()</a>. To destroy an object you don't own a reference to you must call <a class="el" href="classXfc_1_1G_1_1Object.html#480842af7bdb77d761ae926b1f5584f7">dispose()</a>; 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c5148d28e222759031fd0cdcc2208811"></a><!-- doxytag: member="Xfc::G::Object::Object" ref="c5148d28e222759031fd0cdcc2208811" args="(GObject *object, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::Object::Object           </td>
          <td>(</td>
          <td class="paramtype">GObject *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> from an existing GObject. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>A pointer to a GObject. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
This constructor is used to wrap GTK+ objects. <em>object</em> can be a pointer to newly created GObject or an existing GObject. If <em>owns_reference</em> is false the object's initial reference count is floating and must not be unreferenced, unless the object was first referenced. If <em>owns_reference</em> is true the gfcal reference is owned by you and must be unreferenced.<p>
Each derived class declares a similar constructor with a default value for <em>owns_reference</em> that indicates whether or not the gfcal reference count is floating. The XFC smart pointer, <a class="el" href="classXfc_1_1Pointer.html">Xfc::Pointer</a>, uses this value to determine if the object's initial reference count needs to be cleared. 
</div>
</div><p>
<a class="anchor" name="c5148d28e222759031fd0cdcc2208811"></a><!-- doxytag: member="Xfc::G::Object::Object" ref="c5148d28e222759031fd0cdcc2208811" args="(GObject *object, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::Object::Object           </td>
          <td>(</td>
          <td class="paramtype">GObject *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> from an existing GObject. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>A pointer to a GObject. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
This constructor is used to wrap GTK+ objects. <em>object</em> can be a pointer to newly created GObject or an existing GObject. If <em>owns_reference</em> is false the object's initial reference count is floating and must not be unreferenced, unless the object was first referenced. If <em>owns_reference</em> is true the gfcal reference is owned by you and must be unreferenced.<p>
Each derived class declares a similar constructor with a default value for <em>owns_reference</em> that indicates whether or not the gfcal reference count is floating. The XFC smart pointer, <a class="el" href="classXfc_1_1Pointer.html">Xfc::Pointer</a>, uses this value to determine if the object's initial reference count needs to be cleared. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="135b13900a2b1792a0b9740c16fb47a3"></a><!-- doxytag: member="Xfc::G::Object::get_property" ref="135b13900a2b1792a0b9740c16fb47a3" args="(const char *property_name, Value &amp;value) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Object::get_property           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Value.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a property of an object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property_name</em>&nbsp;</td><td>Name of property to get the value for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Reference to a <a class="el" href="classXfc_1_1G_1_1Value.html">G::Value</a> object that will hold the value for property_name. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5cd2be0de4548b8a905737713e444f26"></a><!-- doxytag: member="Xfc::G::Object::get_data" ref="5cd2be0de4548b8a905737713e444f26" args="(const Quark &amp;quark) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Xfc::G::Object::get_data           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1G_1_1Quark.html">Quark</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>quark</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a user data pointer set by calling set(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>quark</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1G_1_1Quark.html">G::Quark</a> naming the user data pointer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The user data pointer set, or null if none exists. </dd></dl>

</div>
</div><p>
<a class="anchor" name="91ca655f7f964355a7fc964f2d20602e"></a><!-- doxytag: member="Xfc::G::Object::get_data" ref="91ca655f7f964355a7fc964f2d20602e" args="(const String &amp;key) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Xfc::G::Object::get_data           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a user data pointer set by calling set(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>A string naming the user data pointer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The user data pointer set, or null if none exists. </dd></dl>

</div>
</div><p>
<a class="anchor" name="847246f6472dce1d5a5cbea98f6d6878"></a><!-- doxytag: member="Xfc::G::Object::pointer" ref="847246f6472dce1d5a5cbea98f6d6878" args="(GObject *object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1G_1_1Object.html">Object</a>* Xfc::G::Object::pointer           </td>
          <td>(</td>
          <td class="paramtype">GObject *&nbsp;</td>
          <td class="paramname"> <em>object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> pointer for the specified GTK+ object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>A pointer to a GTK+ C object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> pointer, or null if the GTK+ object has no C++ wrapper. </dd></dl>

</div>
</div><p>
<a class="anchor" name="47f87a1180f4950eba164d60aa281283"></a><!-- doxytag: member="Xfc::G::Object::ref" ref="47f87a1180f4950eba164d60aa281283" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Xfc::G::Object::ref           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Increase the reference count of the object. 
<p>
This method is declared virtual for XFC's use only. You are not meant to override it. 
<p>
Reimplemented from <a class="el" href="classXfc_1_1Trackable.html#dcb8707f7fa6dddef79a9d9b77eb669d">Xfc::Trackable</a>.
<p>
Reimplemented in <a class="el" href="classXfc_1_1Gtk_1_1Object.html#60fabe4bda00b4ef724a14fb67be5c45">Xfc::Gtk::Object</a>.
</div>
</div><p>
<a class="anchor" name="513fc400272db0db24d32f9a280e64a5"></a><!-- doxytag: member="Xfc::G::Object::unref" ref="513fc400272db0db24d32f9a280e64a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Xfc::G::Object::unref           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decrease the reference count of the object. 
<p>
This method is declared virtual for XFC's use only. You are not meant to override it. 
<p>
Reimplemented from <a class="el" href="classXfc_1_1Trackable.html#e3755b87fbff5a30350e2bf7492a62a0">Xfc::Trackable</a>.
</div>
</div><p>
<a class="anchor" name="480842af7bdb77d761ae926b1f5584f7"></a><!-- doxytag: member="Xfc::G::Object::dispose" ref="480842af7bdb77d761ae926b1f5584f7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Xfc::G::Object::dispose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finalize the object. 
<p>
This method is declared virtual for XFC's use only. 
<p>
Reimplemented in <a class="el" href="classXfc_1_1Gdk_1_1Window.html#72a272b6a99cee4484870642e8a431f7">Xfc::Gdk::Window</a>, and <a class="el" href="classXfc_1_1Gtk_1_1Object.html#93638147e17d681633280cd1acd27895">Xfc::Gtk::Object</a>.
</div>
</div><p>
<a class="anchor" name="9a2fe0562fae4691375fd929e8783699"></a><!-- doxytag: member="Xfc::G::Object::set_property" ref="9a2fe0562fae4691375fd929e8783699" args="(const char *property_name, const Value &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Object::set_property           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1G_1_1Value.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a property on an object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property_name</em>&nbsp;</td><td>Name of the property to set the value for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1G_1_1Value.html">G::Value</a> that holds the value of the propery being set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b7e610618dfb2e6b7cc27e3c2601752d"></a><!-- doxytag: member="Xfc::G::Object::set_data" ref="b7e610618dfb2e6b7cc27e3c2601752d" args="(const Quark &amp;quark, void *data, GDestroyNotify destroy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Object::set_data           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1G_1_1Quark.html">Quark</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>quark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDestroyNotify&nbsp;</td>
          <td class="paramname"> <em>destroy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an opaque named pointer on an object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>quark</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1G_1_1Quark.html">G::Quark</a>, naming the user data pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>An opaque user data pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destroy</em>&nbsp;</td><td>A static function to invoke with data as its argument, when data needs to be freed.</td></tr>
  </table>
</dl>
This sets an opaque, named pointer on an object. The name is specified through a <a class="el" href="classXfc_1_1G_1_1Quark.html">G::Quark</a>, and the pointer can be gotten back from the object with <a class="el" href="classXfc_1_1G_1_1Object.html#5cd2be0de4548b8a905737713e444f26">get_data()</a> until the object is finalized. Setting a previously set user data pointer, overrides (frees) the old pointer set, using null as the pointer essentially removes the data stored. 
</div>
</div><p>
<a class="anchor" name="fd13141ce1eff0667a7750239e7f301b"></a><!-- doxytag: member="Xfc::G::Object::set_data" ref="fd13141ce1eff0667a7750239e7f301b" args="(const String &amp;key, void *data, GDestroyNotify destroy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Object::set_data           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDestroyNotify&nbsp;</td>
          <td class="paramname"> <em>destroy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an opaque named pointer on an object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>A string naming the user data pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>An opaque user data pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destroy</em>&nbsp;</td><td>A static function to invoke with data as its argument, when data needs to be freed.</td></tr>
  </table>
</dl>
This sets an opaque, named pointer on an object. The name is specified through a <a class="el" href="classXfc_1_1String.html">String</a>, and the pointer can be gotten back from the object with <a class="el" href="classXfc_1_1G_1_1Object.html#5cd2be0de4548b8a905737713e444f26">get_data()</a> until the object is finalized. Setting a previously set user data pointer, overrides (frees) the old pointer set, using null as the pointer essentially removes the data stored. 
</div>
</div><p>
<a class="anchor" name="d7a5e227aaa1d02d7ff8f8facd6250a2"></a><!-- doxytag: member="Xfc::G::Object::remove_data" ref="d7a5e227aaa1d02d7ff8f8facd6250a2" args="(const Quark &amp;quark, bool notify=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Xfc::G::Object::remove_data           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1G_1_1Quark.html">Quark</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>quark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>notify</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an opaque named pointer previously set on an object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>quark</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1G_1_1Quark.html">G::Quark</a>, naming the user data pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>notify</em>&nbsp;</td><td>Set <em>true</em> if the destroy function should be invoked (if any was set). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The user data pointer set, or null if none exists or <em>notify</em> is true.</dd></dl>
This function gets back user data pointers stored via <a class="el" href="classXfc_1_1G_1_1Object.html#b7e610618dfb2e6b7cc27e3c2601752d">set_data()</a> and removes the data from object. If <em>notify</em> is true its destroy function is called (if any was set) and null is returned. Usually you wont use a destroy function so you can ignore <em>notify</em>. 
</div>
</div><p>
<a class="anchor" name="d5a7345858bd5910a8f566ea3b9941ef"></a><!-- doxytag: member="Xfc::G::Object::remove_data" ref="d5a7345858bd5910a8f566ea3b9941ef" args="(const String &amp;key, bool notify=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Xfc::G::Object::remove_data           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>notify</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an opaque named pointer previously set on an object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>A string naming the user data pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>notify</em>&nbsp;</td><td>Set <em>true</em> if the destroy function should be invoked (if any was set). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the user data pointer set, or null if none exists or <em>notify</em> is true.</dd></dl>
This function gets back user data pointers stored via <a class="el" href="classXfc_1_1G_1_1Object.html#b7e610618dfb2e6b7cc27e3c2601752d">set_data()</a> and removes the data from object. If <em>notify</em> is true its destroy function is called (if any was set) and null is returned. Usually you wont use a destroy function so you can ignore <em>notify</em>. 
</div>
</div><p>
<a class="anchor" name="690965e0ab31e8a61de67b6adf3698f5"></a><!-- doxytag: member="Xfc::G::Object::emit_by_name" ref="690965e0ab31e8a61de67b6adf3698f5" args="(const char *signal_name,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Object::emit_by_name           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>signal_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emit a signal by name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signal_name</em>&nbsp;</td><td>The name of the signal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>The parameters to pass to the signal handler, followed by a pointer to the return type, if any.</td></tr>
  </table>
</dl>
This causes the default handler and user-connected handlers to be run. 
</div>
</div><p>
<a class="anchor" name="6e1c25f770e4b171cf8202aa3db2e8af"></a><!-- doxytag: member="Xfc::G::Object::stop_emission_by_name" ref="6e1c25f770e4b171cf8202aa3db2e8af" args="(const char *detailed_signal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Object::stop_emission_by_name           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>detailed_signal</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Aborts a signal's current emission by name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>detailed_signal</em>&nbsp;</td><td>The name of the signal you wish to stop.</td></tr>
  </table>
</dl>
The name of the signal you wish to stop is the GTK+ name, not its XFC name. Signals in XFC are named by adding the "_signal" suffix to the GTK+ name. For example, the XFC name for the GTK+ "clicked" signal is "clicked_signal". 
</div>
</div><p>
<a class="anchor" name="98bc135924c0b1ba8b63ba0ea6155ae1"></a><!-- doxytag: member="Xfc::G::Object::disconnect_by_name" ref="98bc135924c0b1ba8b63ba0ea6155ae1" args="(const char *signal_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::Object::disconnect_by_name           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>signal_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disconnect a signal by name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signal_name</em>&nbsp;</td><td>The name of the signal. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the signal was disconnected, <em>false</em> if <em>signal_name</em> is not connected to this object.</dd></dl>
This is a convenience method that can be used to disconnect a signal when you don't want to use a Connection object. It looks up the signal_id for <em>signal name</em> and uses it to search for the first signal handler connected to the object. If found, it disconnects the handler and returns true. 
</div>
</div><p>
<a class="anchor" name="e7604dd7798c71fd24c7c1b72566a146"></a><!-- doxytag: member="Xfc::G::Object::wrap" ref="e7604dd7798c71fd24c7c1b72566a146" args="(gObject *object, bool owns_reference=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename gObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static T* Xfc::G::Object::wrap           </td>
          <td>(</td>
          <td class="paramtype">gObject *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrap a GTK+ C object in as C++ wrapper class. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>A pointer to a GTK+ C object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set <em>true</em> if the GTK+ object must be unreferenced. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the C++ class cast to a pointer of type T.</dd></dl>
If <em>object</em> was previously wrapped this function returns the existing C++ pointer cast to a pointer of type T. If no wrapper exists a new one is created. Each GTK+ C object can have only one wrapper. A smart pointer can be used to handle the returned pointer. Otherwise if T-&gt;is_referenced() is true, T-&gt;<a class="el" href="classXfc_1_1G_1_1Object.html#513fc400272db0db24d32f9a280e64a5">unref()</a> must be explicitly called. 
</div>
</div><p>
<a class="anchor" name="35b30133d4bfe56873907d65f80a7d93"></a><!-- doxytag: member="Xfc::G::Object::wrap_new" ref="35b30133d4bfe56873907d65f80a7d93" args="(gObject *object, bool owns_reference=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename gObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static T* Xfc::G::Object::wrap_new           </td>
          <td>(</td>
          <td class="paramtype">gObject *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrap a GTK+ C object in a C++ wrapper class. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>A pointer to a GTK+ C object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set <em>true</em> if the GTK+ object must be unreferenced. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the C++ class cast to a pointer of type T.</dd></dl>
Only use this if <em>object</em> has not been wrapped before. Usually <em>reference</em> is false. Set <em>reference</em> to true if the wrapped object must be unreferenced when finished. 
</div>
</div><p>
<a class="anchor" name="23d9be48be6cb44a0fee4cdec66114a9"></a><!-- doxytag: member="Xfc::G::Object::signal_notify" ref="23d9be48be6cb44a0fee4cdec66114a9" args="(const String &amp;property_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">NotifySignalProxy</a> Xfc::G::Object::signal_notify           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>property_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the notify_signal; emitted when a property on an object is changed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property_name</em>&nbsp;</td><td>The property name to be notified of changes to.</td></tr>
  </table>
</dl>
If <em>property_name</em> is provided it is appended to the signal name so that the signal connected to becomes "notify::property_name". What this does is ensure that your notification slot is only called if <em>property_name</em> matches the property name of the "notify" signal being emitted. 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="5aac9357199d33b29be75675611ce52b"></a><!-- doxytag: member="Xfc::G::Object::notify_signal" ref="5aac9357199d33b29be75675611ce52b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">NotifySignalType</a> <a class="el" href="classXfc_1_1G_1_1Object.html#5aac9357199d33b29be75675611ce52b">Xfc::G::Object::notify_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notify signal (see signal_notify()). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(GParamSpec *pspec);
&lt; <span class="comment">// pspec: A GParamSpec object that holds the meta data specifying the new property.</span>
&lt;
</pre></div> 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="libXFCcore_2xfc_2glib_2object_8hh.html">libXFCcore/xfc/glib/object.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
