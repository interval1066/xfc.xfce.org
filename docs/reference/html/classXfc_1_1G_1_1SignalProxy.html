<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SignalProxy</a></div>
<h1>Xfc::G::SignalProxy&lt; ObjectType, SignalType &gt; Class Template Reference</h1><!-- doxytag: class="Xfc::G::SignalProxy" -->A proxy object for manipulating a protected signal (connection, mostly).  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/signals.hh&gt;</code>
<p>
<a href="classXfc_1_1G_1_1SignalProxy-members.html">List of all members.</a><h2>Public Types</h2>
<ul>
<li><a class="anchor" name="512eaefbfd651fd6eb389300d05dbc3f"></a><!-- doxytag: member="Xfc::G::SignalProxy::SlotType" ref="512eaefbfd651fd6eb389300d05dbc3f" args="" -->
typedef SignalType::SlotType <a class="el" href="classXfc_1_1G_1_1SignalProxy.html#512eaefbfd651fd6eb389300d05dbc3f">SlotType</a>
<dl class="el"><dd class="mdescRight">The slot signature for slots connecting to the specified SignalType. <br></dl></ul>
<h2>Public Member Functions</h2>
<ul>
<li><a class="el" href="classXfc_1_1G_1_1SignalProxy.html#875926e740620d7c28b6c1af891241c9">SignalProxy</a> (ObjectType *object, const SignalType *signal, const char *detail=0)
<dl class="el"><dd class="mdescRight">Constructs a new signal proxy object.  <a href="#875926e740620d7c28b6c1af891241c9"></a><br></dl><li>sigc::connection <a class="el" href="classXfc_1_1G_1_1SignalProxy.html#dca0c1fce382707c9b45c9f590a8fa56">connect</a> (const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html#512eaefbfd651fd6eb389300d05dbc3f">SlotType</a> &amp;slot, bool after=false) const
<dl class="el"><dd class="mdescRight">Connect a slot to the signal.  <a href="#dca0c1fce382707c9b45c9f590a8fa56"></a><br></dl><li>template&lt;typename MethodObjectType, typename MethodType&gt; sigc::connection <a class="el" href="classXfc_1_1G_1_1SignalProxy.html#e2269758e5a97268937680b769c2609f">connect</a> (MethodObjectType *object, MethodType method, bool after=false) const
<dl class="el"><dd class="mdescRight">Connect a class method to the signal.  <a href="#e2269758e5a97268937680b769c2609f"></a><br></dl><li>template&lt;typename FunctionType&gt; sigc::connection <a class="el" href="classXfc_1_1G_1_1SignalProxy.html#20af0c36c0bec7096d8d39027095b23d">connect</a> (FunctionType function, bool after=false) const
<dl class="el"><dd class="mdescRight">Connect a free function to the signal.  <a href="#20af0c36c0bec7096d8d39027095b23d"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename ObjectType, typename SignalType&gt;<br>
 class Xfc::G::SignalProxy&lt; ObjectType, SignalType &gt;</h3>

A proxy object for manipulating a protected signal (connection, mostly). 
<p>
<a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SignalProxy</a> is used to access the connection method of a protected signal. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="875926e740620d7c28b6c1af891241c9"></a><!-- doxytag: member="Xfc::G::SignalProxy::SignalProxy" ref="875926e740620d7c28b6c1af891241c9" args="(ObjectType *object, const SignalType *signal, const char *detail=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType, typename SignalType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1G_1_1SignalProxy.html">Xfc::G::SignalProxy</a>&lt; ObjectType, SignalType &gt;::<a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SignalProxy</a>           </td>
          <td>(</td>
          <td class="paramtype">ObjectType *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignalType *&nbsp;</td>
          <td class="paramname"> <em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>detail</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new signal proxy object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>An object that contains <em>SignalType</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signal</em>&nbsp;</td><td>The signal object, usually a protected static member of a class. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detail</em>&nbsp;</td><td>The detail string to append to the signal name.</td></tr>
  </table>
</dl>
The <em>detail</em> is set as a filter on one of the following signals: <a class="el" href="classXfc_1_1G_1_1Object.html#5aac9357199d33b29be75675611ce52b">G::Object::notify_signal</a>, <a class="el" href="classXfc_1_1Gtk_1_1AccelMap.html#2a02700263450f72b36649d0be898836">Gtk::AccelMap::changed_signal</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ce6ef6a7cd9c70e3b335e157c8738d05">Gtk::Widget::child_notify_signal</a>. As a result, the signal name at connection time becomes 'namedetail' instead of 'name'. Specifying a detail on a signal, such as a property name for the <a class="el" href="classXfc_1_1G_1_1Object.html#5aac9357199d33b29be75675611ce52b">G::Object::notify_signal</a>, is a way of filtering out unwanted signal emissions on these frequently emitted signals. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="dca0c1fce382707c9b45c9f590a8fa56"></a><!-- doxytag: member="Xfc::G::SignalProxy::connect" ref="dca0c1fce382707c9b45c9f590a8fa56" args="(const SlotType &amp;slot, bool after=false) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType, typename SignalType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sigc::connection <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">Xfc::G::SignalProxy</a>&lt; ObjectType, SignalType &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html#512eaefbfd651fd6eb389300d05dbc3f">SlotType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>after</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect a slot to the signal. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>The sigc::slot object to connect to SignalType. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>after</em>&nbsp;</td><td>Set <em>true</em> to call the user-defined slot after the signal, or <em>false</em> to let the signal's default behavior preside. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A sigc::connection object.</dd></dl>
The connection object can be used to control the signal connection, either by calling block(), unblock() or disconnect(). You don't need to call discconnect() unless you have good reason to. GTK+ signals are automatically disconnected when an object gets destroyed. 
</div>
</div><p>
<a class="anchor" name="e2269758e5a97268937680b769c2609f"></a><!-- doxytag: member="Xfc::G::SignalProxy::connect" ref="e2269758e5a97268937680b769c2609f" args="(MethodObjectType *object, MethodType method, bool after=false) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType, typename SignalType&gt; </div>
<div class="memtemplate">
template&lt;typename MethodObjectType, typename MethodType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sigc::connection <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">Xfc::G::SignalProxy</a>&lt; ObjectType, SignalType &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">MethodObjectType *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MethodType&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>after</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect a class method to the signal. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>A pointer to the object that has <em>MethodType</em> as a member. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>The class method in <em>object</em> to connect to this signal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>after</em>&nbsp;</td><td>Set <em>true</em> to call the user-defined metho after the signal, or <em>false</em> to let the signal's default behavior preside. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A sigc::connection object.</dd></dl>
This is a convenience method that creates the sigc::slot for you. All you need to do is pass this function is a pointer to the object and the object method, just as you would when creating a slot. The returned connection object can be used to control the signal connection, either by calling block(), unblock() or disconnect(). You don't need to call discconnect() unless you have good reason to. GTK+ signals are automatically disconnected when an object gets destroyed. 
</div>
</div><p>
<a class="anchor" name="20af0c36c0bec7096d8d39027095b23d"></a><!-- doxytag: member="Xfc::G::SignalProxy::connect" ref="20af0c36c0bec7096d8d39027095b23d" args="(FunctionType function, bool after=false) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType, typename SignalType&gt; </div>
<div class="memtemplate">
template&lt;typename FunctionType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sigc::connection <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">Xfc::G::SignalProxy</a>&lt; ObjectType, SignalType &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">FunctionType&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>after</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect a free function to the signal. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>The free function to connect to this signal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>after</em>&nbsp;</td><td>Set <em>true</em> to call the user-defined slot after the signal, or <em>false</em> to let the signal's default behavior preside. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A sigc::connection object.</dd></dl>
This is a convenience method that creates the sigc::slot for you. All you need to do is pass a pointer to the function, just as you would when creating a slot. The returned connection object can be used to control the signal connection, either by calling block(), unblock() or disconnect(). You don't need to call discconnect() unless you have good reason to. GTK+ signals are automatically disconnected when an object gets destroyed. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="signals_8hh.html">signals.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
