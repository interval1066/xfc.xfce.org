<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="classXfc_1_1G_1_1SpawnAsync.html">SpawnAsync</a></div>
<h1>Xfc::G::SpawnAsync Class Reference</h1><!-- doxytag: class="Xfc::G::SpawnAsync" --><!-- doxytag: inherits="Xfc::G::Spawn" -->A C++ interface for the GLib asynchronous spawn functions.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/spawn.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::G::SpawnAsync:
<p><center><img src="classXfc_1_1G_1_1SpawnAsync.png" usemap="#Xfc::G::SpawnAsync_map" border="0" alt=""></center>
<map name="Xfc::G::SpawnAsync_map">
<area href="classXfc_1_1G_1_1Spawn.html" alt="Xfc::G::Spawn" shape="rect" coords="0,56,127,80">
<area href="classXfc_1_1StackObject.html" alt="Xfc::StackObject" shape="rect" coords="0,0,127,24">
</map>
<a href="classXfc_1_1G_1_1SpawnAsync-members.html">List of all members.</a><h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>GPid <a class="el" href="classXfc_1_1G_1_1SpawnAsync.html#43da84db0022195e95ff9caea4def2f7">child_pid</a> () const
<dl class="el"><dd class="mdescRight">Returns the child process ID or zero if an error occurs.  <a href="#43da84db0022195e95ff9caea4def2f7"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>bool <a class="el" href="classXfc_1_1G_1_1SpawnAsync.html#69a0e9c4e8377bad5f894aa2f95be49b">execute</a> (<a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Executes a child program asynchronously (that is, your program will not block waiting for the child to exit).  <a href="#69a0e9c4e8377bad5f894aa2f95be49b"></a><br></dl><li>bool <a class="el" href="classXfc_1_1G_1_1SpawnAsync.html#ca3984664f375d0a23101794869f467f">execute</a> (const <a class="el" href="classXfc_1_1G_1_1Spawn.html#9be754055174e7bea3fe1aa140dc6d52">ChildSetupSlot</a> &amp;slot, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Executes a child program asynchronously (that is, your program will not block waiting for the child to exit).  <a href="#ca3984664f375d0a23101794869f467f"></a><br></dl><li>bool <a class="el" href="classXfc_1_1G_1_1SpawnAsync.html#0ddf14ea3cde51bd7d9160f0f58caad9">execute</a> (const <a class="el" href="classXfc_1_1G_1_1Spawn.html#9be754055174e7bea3fe1aa140dc6d52">ChildSetupSlot</a> &amp;slot, int *std_input, int *std_output, int *std_error, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Executes a child program asynchronously (that is, your program will not block waiting for the child to exit).  <a href="#0ddf14ea3cde51bd7d9160f0f58caad9"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A C++ interface for the GLib asynchronous spawn functions. 
<p>
<a class="el" href="classXfc_1_1G_1_1SpawnAsync.html">SpawnAsync</a> executes a child program asynchronously (that is, your program will not block waiting for the child to exit). The child program is specified by the only argument that must be provided, argv. argv should be a vector of std::strings, to be passed as the argument vector for the child. The first string in argv is of course the name of the program to execute. By default, the name of the program must be a full path; the PATH shell variable will only be searched if you pass the <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4eb9cdb21ce5437c54ac1eb913e8110f53">G::SPAWN_SEARCH_PATH</a> flag. The first constructor takes an argv as a parameter and one or more optional spawn flags. The second constructor creates the argv argument for you from the passed in command line.<p>
SpawnFlagsField should be the bitwise OR of any flags you want to affect the child's behavior. On Unix, the <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4ee05fb4ed39dbe5ae8a307938600d2b88">G::SPAWN_DO_NOT_REAP_CHILD</a> means that the child will not be automatically reaped; you must call waitpid() or handle SIGCHLD yourself, or the child will become a zombie. On Windows, the flag means that a handle to the child will be returned child_pid. You must call CloseHandle() on it eventually (or exit the process), or the child processs will continue to take up some table space even after its death. Quite similar to zombies on Unix, actually.<p>
<a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4e3b383aa2c2c3afc2b1d75f8e088283be">G::SPAWN_LEAVE_DESCRIPTORS_OPEN</a> means that the parent's open file descriptors will be inherited by the child; otherwise all descriptors except stdin/stdout/stderr will be closed before calling exec() in the child. <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4eb9cdb21ce5437c54ac1eb913e8110f53">G::SPAWN_SEARCH_PATH</a> means that argv[0] need not be an absolute path, it will be looked for in the user's PATH. <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4e74ed456ccf30b5ccb4a663747312b526">G::SPAWN_STDOUT_TO_DEV_NULL</a> means that the child's standard output will be discarded, instead of going to the same location as the parent's standard output. If you use this flag, set_standard_output() is ignored. <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4e43501bf8c6b8d66dde0c5dbbb459dbcd">G::SPAWN_STDERR_TO_DEV_NULL</a> means that the child's standard error will be discarded, instead of going to the same location as the parent's standard error. If you use this flag, set_standard_error() will be ignored. <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4e585cb47f7861907ce178a25290aff3a0">G::SPAWN_CHILD_INHERITS_STDIN</a> means that the child will inherit the parent's standard input (by default, the child's standard input is attached to /dev/null). If you use this flag, set_standard_input() will be ignored. <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4ed7b82ad8bd441c606c227104f7f1602b">G::SPAWN_FILE_AND_ARGV_ZERO</a> means that the first element of argv is the file to execute, while the remaining elements are the actual argument vector to pass to the file. Normally <a class="el" href="classXfc_1_1G_1_1SpawnAsync.html">SpawnAsync</a> uses argv[0] as the file to execute, and passes all of argv to the child.<p>
ChildSetupSlot is a user-defined method. On POSIX platforms, the method is called in the child after GLib has performed all the setup it plans to perform (including creating pipes, closing file descriptors, etc.) but before calling exec(). That is, the ChildSetupSlot is called just before calling exec() in the child. Obviously actions taken in this method will only affect the child, not the parent. On Windows, there is no separate fork() and exec() functionality. Child processes are created and run right away with one API call, CreateProcess(). The ChildSetupSlot is called in the parent process just before creating the child process. You should carefully consider what you do in the ChildSetupSlot method if you intend your software to be portable to Windows.<p>
The process_id() method returns the child's process ID. You can use the process ID to send signals to the child, or to waitpid() if you specified the <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4ee05fb4ed39dbe5ae8a307938600d2b88">G::SPAWN_DO_NOT_REAP_CHILD</a> flag. On Windows, child_pid will be filled with a handle to the child process only if you specified the <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4ee05fb4ed39dbe5ae8a307938600d2b88">G::SPAWN_DO_NOT_REAP_CHILD</a> flag. You can then access the child process using the Win32 API, for example wait for its termination with the WaitFor*() functions, or examine its exit code with GetExitCodeProcess(). You should close the handle with CloseHandle() when you no longer need it.<p>
A <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> should be passed to <a class="el" href="classXfc_1_1G_1_1SpawnAsync.html#69a0e9c4e8377bad5f894aa2f95be49b">execute()</a> to report errors but can be null to ignore them. If the <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> is set, <a class="el" href="classXfc_1_1G_1_1SpawnAsync.html#69a0e9c4e8377bad5f894aa2f95be49b">execute()</a> returns false. Errors are reported even if they occur in the child (for example if the executable in argv[0] is not found). Typically the message field of returned errors should be displayed to users. Possible errors are those from the G_SPAWN_ERROR domain. If an error occurs the standard_input, standard_output, and standard_error file descriptors will not be filled with valid values, and process_id() will return zero.<p>
<b>Example:</b> A simple way to spawn an asynchronous child process. <div class="fragment"><pre class="fragment"> G::Error error;
 SpawnAsync child(command_line, &amp;error);
 <span class="keywordflow">if</span> (error.get())
 {
        <span class="comment">// handle error</span>
 }
 <span class="keywordflow">else</span>
 {
        <span class="keywordflow">if</span> (!child.execute(&amp;error))
        {
                <span class="comment">// handle error</span>
        }
 }
</pre></div> 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="79cbc6fb53a768ccee6d0e5562529541"></a><!-- doxytag: member="Xfc::G::SpawnAsync::SpawnAsync" ref="79cbc6fb53a768ccee6d0e5562529541" args="(const std::vector&lt; std::string &gt; &amp;argv, SpawnFlagsField flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::SpawnAsync::SpawnAsync           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1G.html#a0161249135e71fe1cbe1a7ce9da7caf">SpawnFlagsField</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs an asynchronous spawn object with the specified arguments <em>argv</em> and spawn <em>flags</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>argv</em>&nbsp;</td><td>A reference to a vector of std::string that holds the child's argument strings. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>One or more bitflags from the <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4e">G::SpawnFlags</a> enumeration.</td></tr>
  </table>
</dl>
The first string in argv (argv[0]) is of course the name of the program to execute. By default, the name of the program must be a full path; the PATH shell variable will only be searched if you pass the <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4eb9cdb21ce5437c54ac1eb913e8110f53">G::SPAWN_SEARCH_PATH</a> flag. 
</div>
</div><p>
<a class="anchor" name="eeb8cab6bf4749732e772971530f7e09"></a><!-- doxytag: member="Xfc::G::SpawnAsync::SpawnAsync" ref="eeb8cab6bf4749732e772971530f7e09" args="(const std::string &amp;command_line, G::Error *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::SpawnAsync::SpawnAsync           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>command_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs an asynchronous spawn object with the specified arguments in the <em>command_line</em> string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>command_line</em>&nbsp;</td><td>The command line string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>.</td></tr>
  </table>
</dl>
This constructor parses <em>command line</em> with g_shell_parse_argv() and passes it to GLib. If an error occurs it is set by the parsing function, and can be any of those from the G_SHELL_ERROR domain. Runs a <em>command_line</em> in the background. Unlike then other constructor, the <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4eb9cdb21ce5437c54ac1eb913e8110f53">G::SPAWN_SEARCH_PATH</a> flag is enabled, other flags are not. Note that <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4eb9cdb21ce5437c54ac1eb913e8110f53">G::SPAWN_SEARCH_PATH</a> can have security implications, so consider using the other constructor if appropriate. 
</div>
</div><p>
<a class="anchor" name="79cbc6fb53a768ccee6d0e5562529541"></a><!-- doxytag: member="Xfc::G::SpawnAsync::SpawnAsync" ref="79cbc6fb53a768ccee6d0e5562529541" args="(const std::vector&lt; std::string &gt; &amp;argv, SpawnFlagsField flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::SpawnAsync::SpawnAsync           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1G.html#a0161249135e71fe1cbe1a7ce9da7caf">SpawnFlagsField</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs an asynchronous spawn object with the specified arguments <em>argv</em> and spawn <em>flags</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>argv</em>&nbsp;</td><td>A reference to a vector of std::string that holds the child's argument strings. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>One or more bitflags from the <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4e">G::SpawnFlags</a> enumeration.</td></tr>
  </table>
</dl>
The first string in argv (argv[0]) is of course the name of the program to execute. By default, the name of the program must be a full path; the PATH shell variable will only be searched if you pass the <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4eb9cdb21ce5437c54ac1eb913e8110f53">G::SPAWN_SEARCH_PATH</a> flag. 
</div>
</div><p>
<a class="anchor" name="eeb8cab6bf4749732e772971530f7e09"></a><!-- doxytag: member="Xfc::G::SpawnAsync::SpawnAsync" ref="eeb8cab6bf4749732e772971530f7e09" args="(const std::string &amp;command_line, G::Error *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::SpawnAsync::SpawnAsync           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>command_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs an asynchronous spawn object with the specified arguments in the <em>command_line</em> string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>command_line</em>&nbsp;</td><td>The command line string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>.</td></tr>
  </table>
</dl>
This constructor parses <em>command line</em> with g_shell_parse_argv() and passes it to GLib. If an error occurs it is set by the parsing function, and can be any of those from the G_SHELL_ERROR domain. Runs a <em>command_line</em> in the background. Unlike then other constructor, the <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4eb9cdb21ce5437c54ac1eb913e8110f53">G::SPAWN_SEARCH_PATH</a> flag is enabled, other flags are not. Note that <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4eb9cdb21ce5437c54ac1eb913e8110f53">G::SPAWN_SEARCH_PATH</a> can have security implications, so consider using the other constructor if appropriate. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="43da84db0022195e95ff9caea4def2f7"></a><!-- doxytag: member="Xfc::G::SpawnAsync::child_pid" ref="43da84db0022195e95ff9caea4def2f7" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GPid Xfc::G::SpawnAsync::child_pid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the child process ID or zero if an error occurs. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The child process ID. </dd></dl>

</div>
</div><p>
<a class="anchor" name="69a0e9c4e8377bad5f894aa2f95be49b"></a><!-- doxytag: member="Xfc::G::SpawnAsync::execute" ref="69a0e9c4e8377bad5f894aa2f95be49b" args="(G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::SpawnAsync::execute           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes a child program asynchronously (that is, your program will not block waiting for the child to exit). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if successful, <em>false</em> if error is set. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca3984664f375d0a23101794869f467f"></a><!-- doxytag: member="Xfc::G::SpawnAsync::execute" ref="ca3984664f375d0a23101794869f467f" args="(const ChildSetupSlot &amp;slot, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::SpawnAsync::execute           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1G_1_1Spawn.html#9be754055174e7bea3fe1aa140dc6d52">ChildSetupSlot</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes a child program asynchronously (that is, your program will not block waiting for the child to exit). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>A sigc::slot to call in the child just before exec(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if successful, <em>false</em> if error is set. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ddf14ea3cde51bd7d9160f0f58caad9"></a><!-- doxytag: member="Xfc::G::SpawnAsync::execute" ref="0ddf14ea3cde51bd7d9160f0f58caad9" args="(const ChildSetupSlot &amp;slot, int *std_input, int *std_output, int *std_error, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::SpawnAsync::execute           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1G_1_1Spawn.html#9be754055174e7bea3fe1aa140dc6d52">ChildSetupSlot</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>std_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>std_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>std_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes a child program asynchronously (that is, your program will not block waiting for the child to exit). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>A sigc::slot to call in the child just before exec(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std_input</em>&nbsp;</td><td>The return location for the file descriptor to write to child's stdin. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std_output</em>&nbsp;</td><td>The return location for the file descriptor to read child's stdout. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std_error</em>&nbsp;</td><td>The return location for the file descriptor to read child's stderr. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if successful, <em>false</em> if error is set.</dd></dl>
The file descriptors <em>std_input</em>, <em>std_output</em>, and <em>std_error</em> are used for writing to the child's standard input or reading from its standard output or standard error, and must be closed by calling close() when no longer required.<p>
If <em>std_input</em> is null the child's standard input is attached to /dev/null unless <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4e585cb47f7861907ce178a25290aff3a0">G::SPAWN_CHILD_INHERITS_STDIN</a> is set. If <em>std_error</em> is null the child's standard error goes to the same location as the parent's standard error unless <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4e43501bf8c6b8d66dde0c5dbbb459dbcd">G::SPAWN_STDERR_TO_DEV_NULL</a> is set. If <em>std_output</em> is not called the child's standard output goes to the same location as the parent's standard output unless <a class="el" href="namespaceXfc_1_1G.html#b97f271818f84af5c80dde23c4937c4e74ed456ccf30b5ccb4a663747312b526">G::SPAWN_STDOUT_TO_DEV_NULL</a> is set. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="libXFCcore_2xfc_2glib_2spawn_8hh.html">libXFCcore/xfc/glib/spawn.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
