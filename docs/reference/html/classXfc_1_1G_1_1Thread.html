<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="classXfc_1_1G_1_1Thread.html">Thread</a></div>
<h1>Xfc::G::Thread Class Reference</h1><!-- doxytag: class="Xfc::G::Thread" -->A GThread C++ wrapper interface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/thread.hh&gt;</code>
<p>
<a href="classXfc_1_1G_1_1Thread-members.html">List of all members.</a><h2>Public Types</h2>
<ul>
<li>typedef sigc::slot&lt; void &gt; <a class="el" href="classXfc_1_1G_1_1Thread.html#bd15c15132652c528a540e813c47db97">ThreadSlot</a>
<dl class="el"><dd class="mdescRight">Signature of the callback slot to execute in the new thread.  <a href="#bd15c15132652c528a540e813c47db97"></a><br></dl></ul>
<h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="aff1147e4077299a8d8a6cf73abde0f5"></a><!-- doxytag: member="Xfc::G::Thread::g_thread" ref="aff1147e4077299a8d8a6cf73abde0f5" args="() const" -->
GThread * <a class="el" href="classXfc_1_1G_1_1Thread.html#aff1147e4077299a8d8a6cf73abde0f5">g_thread</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GThread structure. <br></dl><li>bool <a class="el" href="classXfc_1_1G_1_1Thread.html#5dff5a3f57081cd4fa0b3ed9a67bdbf9">is_joinable</a> () const
<dl class="el"><dd class="mdescRight">Determines whether the thread is joinable.  <a href="#5dff5a3f57081cd4fa0b3ed9a67bdbf9"></a><br></dl><li><a class="anchor" name="bc5965d5da19fa948ce466ef8733fac3"></a><!-- doxytag: member="Xfc::G::Thread::get_priority" ref="bc5965d5da19fa948ce466ef8733fac3" args="() const" -->
<a class="el" href="namespaceXfc_1_1G.html#e2d8660fec9c187772fd174fbf7f7338">ThreadPriority</a> <a class="el" href="classXfc_1_1G_1_1Thread.html#bc5965d5da19fa948ce466ef8733fac3">get_priority</a> () const
<dl class="el"><dd class="mdescRight">Returns the thread priority. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1G_1_1Thread.html#8f7ab69eef98db90185434a3ce59ddee">join</a> ()
<dl class="el"><dd class="mdescRight">Waits until the thread finishes, that is, the callback slot as given to the constructor returns, or <a class="el" href="classXfc_1_1G_1_1Thread.html#c673abdebce1efba269f1ea74255131b">exit()</a> is called by the thread.  <a href="#8f7ab69eef98db90185434a3ce59ddee"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1Thread.html#9df168ce8f09eee7730cb19b18e241f4">set_priority</a> (<a class="el" href="namespaceXfc_1_1G.html#e2d8660fec9c187772fd174fbf7f7338">ThreadPriority</a> priority)
<dl class="el"><dd class="mdescRight">Sets the priority of thread to <em>priority</em>.  <a href="#9df168ce8f09eee7730cb19b18e241f4"></a><br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1G_1_1Thread.html">Thread</a> * <a class="el" href="classXfc_1_1G_1_1Thread.html#df8591fb958d4daa5472e8f85c87ece8">create</a> (const <a class="el" href="classXfc_1_1G_1_1Thread.html#bd15c15132652c528a540e813c47db97">ThreadSlot</a> &amp;slot, bool joinable, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Create a new thread with the default priority.  <a href="#df8591fb958d4daa5472e8f85c87ece8"></a><br></dl><li>static <a class="el" href="classXfc_1_1G_1_1Thread.html">Thread</a> * <a class="el" href="classXfc_1_1G_1_1Thread.html#61d87518c7625cde669a504e84f1c0ac">create</a> (const <a class="el" href="classXfc_1_1G_1_1Thread.html#bd15c15132652c528a540e813c47db97">ThreadSlot</a> &amp;slot, unsigned long stack_size, bool joinable, bool bound, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Create a new thread with the default priority and the specified stack size.  <a href="#61d87518c7625cde669a504e84f1c0ac"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>static bool <a class="el" href="classXfc_1_1G_1_1Thread.html#60f2ab709cc00975f3a7271d028f229a">supported</a> ()
<dl class="el"><dd class="mdescRight">This method returns, whether the thread system is initialized or not.  <a href="#60f2ab709cc00975f3a7271d028f229a"></a><br></dl><li>static <a class="el" href="classXfc_1_1G_1_1Thread.html">Thread</a> * <a class="el" href="classXfc_1_1G_1_1Thread.html#67e76ee1f334f05e193d8afd850863f9">self</a> ()
<dl class="el"><dd class="mdescRight">This method returns the <a class="el" href="classXfc_1_1G_1_1Thread.html">Thread</a> corresponding to the calling thread.  <a href="#67e76ee1f334f05e193d8afd850863f9"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>static void <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">init</a> (GThreadFunctions *vtable=0)
<dl class="el"><dd class="mdescRight">Before you use a thread related method, call <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">init()</a> to initialize the thread system.  <a href="#8ebc56c3be96c382eea240242772fb97"></a><br></dl><li>static void <a class="el" href="classXfc_1_1G_1_1Thread.html#62b00eac60c045d89754c34aab9f73cc">yield</a> ()
<dl class="el"><dd class="mdescRight">Gives way to other threads waiting to be scheduled.  <a href="#62b00eac60c045d89754c34aab9f73cc"></a><br></dl><li>static void <a class="el" href="classXfc_1_1G_1_1Thread.html#c673abdebce1efba269f1ea74255131b">exit</a> ()
<dl class="el"><dd class="mdescRight">Exits the current thread.  <a href="#c673abdebce1efba269f1ea74255131b"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GThread C++ wrapper interface. 
<p>
Threads act almost like processes, but unlike processes all threads of one process share the same memory. This is good, as it provides easy communication between the involved threads via this shared memory, and it is bad, because strange things (so called Heisenbugs) might happen, when the program is not carefully designed. Especially bad is, that due to the concurrent nature of threads no assumptions on the order of execution of different threads can be done unless explicitly forced by the programmer through synchronization primitives.<p>
The aim of the thread related classes is to provide a portable means for writing multi-threaded software. There are primitives for mutexes to protect the access to portions of memory (<a class="el" href="classXfc_1_1G_1_1Mutex.html">Mutex</a>, <a class="el" href="structXfc_1_1G_1_1StaticMutex.html">StaticMutex</a>, <a class="el" href="classXfc_1_1G_1_1RecMutex.html">RecMutex</a>, <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html">StaticRecMutex</a>, <a class="el" href="classXfc_1_1G_1_1RWLock.html">RWLock</a> and <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html">StaticRWLock</a>), there are primitives for condition variables to allow synchronization of threads (<a class="el" href="classXfc_1_1G_1_1Condition.html">Condition</a>) and finally there are primitives for thread-private data, that every thread has a private instance of (<a class="el" href="classXfc_1_1G_1_1Private.html">Private</a>, <a class="el" href="structXfc_1_1G_1_1StaticPrivate.html">StaticPrivate</a>). Last but definitely not least there are primitives to portably create and manage threads (<a class="el" href="classXfc_1_1G_1_1Thread.html">Thread</a>).<p>
A thread of execution has an initial function. For the program's initial thread, the initial function is main(). For a <a class="el" href="classXfc_1_1G_1_1Thread.html">G::Thread</a>, the initial function is the call() or operator() function of the slot object passed to <a class="el" href="classXfc_1_1G_1_1Thread.html#df8591fb958d4daa5472e8f85c87ece8">G::Thread::create()</a>. A thread of execution is finished executing when its initial function returns or is terminated by calling <a class="el" href="classXfc_1_1G_1_1Thread.html#c673abdebce1efba269f1ea74255131b">exit()</a>.<p>
A <a class="el" href="classXfc_1_1G_1_1Thread.html">Thread</a> object has an associated state which is either joinable or non-joinable. If a thread is joinable you can wait for the threads termination by calling <a class="el" href="classXfc_1_1G_1_1Thread.html#8f7ab69eef98db90185434a3ce59ddee">join()</a>. If a thread is non-joinable, the thread will just disappear when its finished executing.<p>
The lifetime of a thread of execution may be different from the thread object. After a call to <a class="el" href="classXfc_1_1G_1_1Thread.html#8f7ab69eef98db90185434a3ce59ddee">join()</a>, the thread of execution will no longer exist even though the thread object will continue to exist until the end of its normal lifetime. The converse is also true; if a thread object is destroyed without a call to <a class="el" href="classXfc_1_1G_1_1Thread.html#8f7ab69eef98db90185434a3ce59ddee">join()</a>, the thread of execution continues until its initial function returns. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="bd15c15132652c528a540e813c47db97"></a><!-- doxytag: member="Xfc::G::Thread::ThreadSlot" ref="bd15c15132652c528a540e813c47db97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef sigc::slot&lt;void&gt; <a class="el" href="classXfc_1_1G_1_1Thread.html#bd15c15132652c528a540e813c47db97">Xfc::G::Thread::ThreadSlot</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signature of the callback slot to execute in the new thread. 
<p>
<b>Example:</b> Method signature for ThreadSlot. <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> method();
&lt;
</pre></div> 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="df8591fb958d4daa5472e8f85c87ece8"></a><!-- doxytag: member="Xfc::G::Thread::create" ref="df8591fb958d4daa5472e8f85c87ece8" args="(const ThreadSlot &amp;slot, bool joinable, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1G_1_1Thread.html">Thread</a>* Xfc::G::Thread::create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1G_1_1Thread.html#bd15c15132652c528a540e813c47db97">ThreadSlot</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>joinable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new thread with the default priority. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>The callback slot to execute in the new thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>joinable</em>&nbsp;</td><td>Should this thread be joinable? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>, or null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the new thread on success, or null if an error occurs.</dd></dl>
The new thread executes the callback slot <em>slot</em>. The <em>slot</em> is owned by this method and will be released when the thread terminates. This means that you can construct and pass a slot inline, as you would when pass a slot to a signal. If you want to keep the slot around you will have to store a referenced pointer to it somewhere. If <em>joinable</em> is true, you can wait for this threads termination by calling <a class="el" href="classXfc_1_1G_1_1Thread.html#8f7ab69eef98db90185434a3ce59ddee">join()</a>. Otherwise the thread will just disappear, when ready.<p>
The <em>error</em> argument can be null to ignore errors, or non-null to report errors. The error is set, if and only if the thread could not be created. 
</div>
</div><p>
<a class="anchor" name="61d87518c7625cde669a504e84f1c0ac"></a><!-- doxytag: member="Xfc::G::Thread::create" ref="61d87518c7625cde669a504e84f1c0ac" args="(const ThreadSlot &amp;slot, unsigned long stack_size, bool joinable, bool bound, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1G_1_1Thread.html">Thread</a>* Xfc::G::Thread::create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1G_1_1Thread.html#bd15c15132652c528a540e813c47db97">ThreadSlot</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>joinable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new thread with the default priority and the specified stack size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>The callback slot to execute in the new thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stack_size</em>&nbsp;</td><td>A stack size for the new thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>joinable</em>&nbsp;</td><td>Should this thread be joinable? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bound</em>&nbsp;</td><td>Should this thread be bound to a system thread? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the new thread on success, or null if an error occurs.</dd></dl>
The new thread executes the callback slot <em>slot</em>. The <em>slot</em> is owned by this method and will be released when the thread terminates. This means that you can construct and pass a slot inline, as you would when pass a slot to a signal. If you want to keep the slot around you will have to store a referenced pointer to it somewhere.<p>
The stack gets the size <em>stack_size</em> or the default value for the current platform, if <em>stack_size</em> is 0. If <em>joinable</em> is true, you can wait for this threads termination by calling <a class="el" href="classXfc_1_1G_1_1Thread.html#8f7ab69eef98db90185434a3ce59ddee">join()</a>. Otherwise the thread will just disappear, when ready. If <em>bound</em> is true, the thread will be scheduled in the system scope, otherwise the implementation is free to do scheduling in the process scope. The first variant is more expensive resource-wise, but generally faster. On some systems (e.g. Linux) all threads are bound. The new thread calls the callback slot <em>slot</em>. If the thread could not be created successfully, <em>error</em> is set.<p>
<b>Note:</b> Only use this method when you really have to. The <em>stack_size</em>, and <em>bound</em> arguments should only be used for cases where it's inevitable. 
</div>
</div><p>
<a class="anchor" name="5dff5a3f57081cd4fa0b3ed9a67bdbf9"></a><!-- doxytag: member="Xfc::G::Thread::is_joinable" ref="5dff5a3f57081cd4fa0b3ed9a67bdbf9" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::Thread::is_joinable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the thread is joinable. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the thread is joinable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="60f2ab709cc00975f3a7271d028f229a"></a><!-- doxytag: member="Xfc::G::Thread::supported" ref="60f2ab709cc00975f3a7271d028f229a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Xfc::G::Thread::supported           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns, whether the thread system is initialized or not. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the thread system is initialized. </dd></dl>

</div>
</div><p>
<a class="anchor" name="67e76ee1f334f05e193d8afd850863f9"></a><!-- doxytag: member="Xfc::G::Thread::self" ref="67e76ee1f334f05e193d8afd850863f9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1G_1_1Thread.html">Thread</a>* Xfc::G::Thread::self           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the <a class="el" href="classXfc_1_1G_1_1Thread.html">Thread</a> corresponding to the calling thread. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the current thread. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8f7ab69eef98db90185434a3ce59ddee"></a><!-- doxytag: member="Xfc::G::Thread::join" ref="8f7ab69eef98db90185434a3ce59ddee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Thread::join           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits until the thread finishes, that is, the callback slot as given to the constructor returns, or <a class="el" href="classXfc_1_1G_1_1Thread.html#c673abdebce1efba269f1ea74255131b">exit()</a> is called by the thread. 
<p>
All resources of thread including the GThread struct are released. The thread must have been created with joinable=true in the constructor. 
</div>
</div><p>
<a class="anchor" name="9df168ce8f09eee7730cb19b18e241f4"></a><!-- doxytag: member="Xfc::G::Thread::set_priority" ref="9df168ce8f09eee7730cb19b18e241f4" args="(ThreadPriority priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::Thread::set_priority           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1G.html#e2d8660fec9c187772fd174fbf7f7338">ThreadPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the priority of thread to <em>priority</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>A priority for the thread.</td></tr>
  </table>
</dl>
Note, it is not guaranteed that threads with different priorities really behave accordingly. On some systems (e.g. Linux) only root can increase priorities. On other systems (e.g. Solaris) there doesn't seem to be different scheduling for different priorities. All in all try to avoid being dependent on priorities. 
</div>
</div><p>
<a class="anchor" name="8ebc56c3be96c382eea240242772fb97"></a><!-- doxytag: member="Xfc::G::Thread::init" ref="8ebc56c3be96c382eea240242772fb97" args="(GThreadFunctions *vtable=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::G::Thread::init           </td>
          <td>(</td>
          <td class="paramtype">GThreadFunctions *&nbsp;</td>
          <td class="paramname"> <em>vtable</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Before you use a thread related method, call <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">init()</a> to initialize the thread system. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vtable</em>&nbsp;</td><td>A function table of type GThreadFunctions, that provides the entry points to the thread system to be used.</td></tr>
  </table>
</dl>
Most of the time you will only have to call init(null). Note you should only call <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">init()</a> with a non-null parameter if you really know what you are doing. <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">init()</a> must not be called directly or indirectly as a callback from GLib. Also no mutexes may be currently locked, while calling <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">init()</a>.<p>
Note, do not call gdk_threads_init(). This method calls gdk_threads_init() for you. <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">init()</a> can only be called once. On the second call it will abort with an error. If you want to make sure, that the thread system is initialized, you can do that too:<p>
<b>Example:</b> Checking if the thread system has been initialized. <div class="fragment"><pre class="fragment">&lt; <span class="keywordflow">if</span> (!<a class="code" href="classXfc_1_1G_1_1Thread.html#60f2ab709cc00975f3a7271d028f229a">G::Thread::supported</a>())
&lt;       <a class="code" href="namespaceXfc_1_1Main.html#8504c76067cdb92e95bd3f5f7e227896">G::Thread::init</a>();
&lt;
</pre></div><p>
After that line either the thread system is initialized or the program will abort, if no thread system is available in GLib, i.e. either G_THREADS_ENABLED is not defined or G_THREADS_IMPL_NONE is defined.<p>
If no thread system is available and vtable is null or if not all elements of vtable are non-null, then <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">G::Thread::init()</a> will abort. To Initialize the thread system with errorcheck mutexes vtable must be null and G_ERRORCHECK_MUTEXES must be defined. 
</div>
</div><p>
<a class="anchor" name="62b00eac60c045d89754c34aab9f73cc"></a><!-- doxytag: member="Xfc::G::Thread::yield" ref="62b00eac60c045d89754c34aab9f73cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::G::Thread::yield           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gives way to other threads waiting to be scheduled. 
<p>
This method is often used as a way to make a busy wait less evil. But in most cases, you will encounter, there are better ways to do that. So in general you shouldn't use this function. 
</div>
</div><p>
<a class="anchor" name="c673abdebce1efba269f1ea74255131b"></a><!-- doxytag: member="Xfc::G::Thread::exit" ref="c673abdebce1efba269f1ea74255131b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::G::Thread::exit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exits the current thread. 
<p>
If another thread is waiting for that thread using <a class="el" href="classXfc_1_1G_1_1Thread.html#8f7ab69eef98db90185434a3ce59ddee">join()</a> and the current thread is joinable, the waiting thread will be woken up.<p>
<b>Note:</b> Never call <a class="el" href="classXfc_1_1G_1_1Thread.html#c673abdebce1efba269f1ea74255131b">exit()</a> from within a thread of a <a class="el" href="classXfc_1_1G_1_1ThreadPool.html">ThreadPool</a>, as that will mess up the bookkeeping and lead to funny and unwanted results. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="thread_8hh.html">thread.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
