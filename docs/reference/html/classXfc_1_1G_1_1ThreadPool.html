<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="classXfc_1_1G_1_1ThreadPool.html">ThreadPool</a></div>
<h1>Xfc::G::ThreadPool Class Reference</h1><!-- doxytag: class="Xfc::G::ThreadPool" --><!-- doxytag: inherits="Xfc::Object" -->A GThreadPool C++ wrapper interface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/threadpool.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::G::ThreadPool:
<p><center><img src="classXfc_1_1G_1_1ThreadPool.png" usemap="#Xfc::G::ThreadPool_map" border="0" alt=""></center>
<map name="Xfc::G::ThreadPool_map">
<area href="classXfc_1_1Object.html" alt="Xfc::Object" shape="rect" coords="0,56,118,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,118,24">
</map>
<a href="classXfc_1_1G_1_1ThreadPool-members.html">List of all members.</a><h2>Public Types</h2>
<ul>
<li>typedef sigc::slot&lt; void &gt; <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#7011220b494c63ba43d4102cbe6a23fc">TaskSlot</a>
<dl class="el"><dd class="mdescRight">Signature of the callback slot to be executed in the threads of the thread pool.  <a href="#7011220b494c63ba43d4102cbe6a23fc"></a><br></dl></ul>
<h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="9a87d0842aea35df25336dba3883c11b"></a><!-- doxytag: member="Xfc::G::ThreadPool::g_thread_pool" ref="9a87d0842aea35df25336dba3883c11b" args="() const" -->
GThreadPool * <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#9a87d0842aea35df25336dba3883c11b">g_thread_pool</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GThreadPool object. <br></dl><li><a class="anchor" name="b34b0218f652bdee53c957b4e8e84b15"></a><!-- doxytag: member="Xfc::G::ThreadPool::operator GThreadPool *" ref="b34b0218f652bdee53c957b4e8e84b15" args="() const" -->
<a class="el" href="classXfc_1_1G_1_1ThreadPool.html#b34b0218f652bdee53c957b4e8e84b15">operator GThreadPool *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; Safely converts a <a class="el" href="classXfc_1_1G_1_1ThreadPool.html">G::ThreadPool</a> object into a GThreadPool pointer. <br></dl><li>int <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#e697408bcfb7ce8675f9dbb10a85a890">get_max_threads</a> () const
<dl class="el"><dd class="mdescRight">Gets the maximal number of threads for the pool.  <a href="#e697408bcfb7ce8675f9dbb10a85a890"></a><br></dl><li>unsigned int <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#6502c1af04bb706f786317404cb2ccfc">get_num_threads</a> () const
<dl class="el"><dd class="mdescRight">Gets the number of threads currently running in the pool.  <a href="#6502c1af04bb706f786317404cb2ccfc"></a><br></dl><li>unsigned int <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#e60c82c846cbfe2cac70ad2eb8fcb186">unprocessed</a> () const
<dl class="el"><dd class="mdescRight">Gets the number of tasks still unprocessed in the pool.  <a href="#e60c82c846cbfe2cac70ad2eb8fcb186"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#28418b11735d4988b6aaaaaebe133e21">push</a> (const <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#7011220b494c63ba43d4102cbe6a23fc">TaskSlot</a> &amp;slot, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Inserts <em>data</em> into the list of tasks to be executed by the pool.  <a href="#28418b11735d4988b6aaaaaebe133e21"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#852049b6987c6771babe94dd8fa39007">set_max_threads</a> (int max_threads, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Sets the maximal allowed number of threads for pool.  <a href="#852049b6987c6771babe94dd8fa39007"></a><br></dl><li>void <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#667ab42bc7b1d5ada7dd1837196a5b89">free</a> (bool immediate=false, bool wait=true)
<dl class="el"><dd class="mdescRight">Frees all resources allocated for the pool.  <a href="#667ab42bc7b1d5ada7dd1837196a5b89"></a><br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>static unsigned int <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#352660f6b998ed97ee956d18b65a8f08">get_num_unused_threads</a> ()
<dl class="el"><dd class="mdescRight">Gets the number of currently unused threads.  <a href="#352660f6b998ed97ee956d18b65a8f08"></a><br></dl><li>static int <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#f8460280b2af60fb0a4f7b06568d1156">get_max_unused_threads</a> ()
<dl class="el"><dd class="mdescRight">Gets the maximal allowed number of unused threads.  <a href="#f8460280b2af60fb0a4f7b06568d1156"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>static void <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#c7bf49b64682fe1631e5b56b14614ef8">set_max_unused_threads</a> (int max_threads)
<dl class="el"><dd class="mdescRight">Sets the maximal number of unused threads to max_threads.  <a href="#c7bf49b64682fe1631e5b56b14614ef8"></a><br></dl><li>static void <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#de54f4ec766de535fa2d327cd45c9d9e">stop_unused_threads</a> ()
<dl class="el"><dd class="mdescRight">Stops all currently unused threads.  <a href="#de54f4ec766de535fa2d327cd45c9d9e"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GThreadPool C++ wrapper interface. 
<p>
Sometimes you wish to asynchronously fork out the execution of work and continue working in your own thread. If that will happen often, the overhead of starting and destroying a thread each time might be to high. In such cases reusing already started threads seems like a good idea. And it indeed is, but implementing this can be tedious and error-prone.<p>
ThreadPools are provided for your convenience. An added advantage is, that the threads can be shared between the different subsystems of your program, when they are using GLib.<p>
There is only one constructor to create a thread pool and the pool is freed automatically when it goes out of scope. A <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#667ab42bc7b1d5ada7dd1837196a5b89">free()</a> method is provided for use either when you want to free the thread pool before it goes out of scope, or change the default values for <em>immediate</em> and <em>wait</em> that get passed to g_thread_pool_free().<p>
If you want to execute a certain task within a thread pool, you call <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#28418b11735d4988b6aaaaaebe133e21">push()</a>. To get the current number of running threads you call <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#6502c1af04bb706f786317404cb2ccfc">get_num_threads()</a>. To get the number of still unprocessed tasks you call <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#e60c82c846cbfe2cac70ad2eb8fcb186">unprocessed()</a>. To control the maximal number of threads for a thread pool, you use <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#e697408bcfb7ce8675f9dbb10a85a890">get_max_threads()</a> and <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#852049b6987c6771babe94dd8fa39007">set_max_threads()</a>.<p>
Finally you can control the number of unused threads, that are kept alive by GLib for future use. The current number can be fetched with <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#352660f6b998ed97ee956d18b65a8f08">get_num_unused_threads()</a>. The maximal number can be controlled by <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#f8460280b2af60fb0a4f7b06568d1156">get_max_unused_threads()</a> and <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#c7bf49b64682fe1631e5b56b14614ef8">set_max_unused_threads()</a>. All currently unused threads can be stopped by calling <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#de54f4ec766de535fa2d327cd45c9d9e">stop_unused_threads()</a>. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="7011220b494c63ba43d4102cbe6a23fc"></a><!-- doxytag: member="Xfc::G::ThreadPool::TaskSlot" ref="7011220b494c63ba43d4102cbe6a23fc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef sigc::slot&lt;void&gt; <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#7011220b494c63ba43d4102cbe6a23fc">Xfc::G::ThreadPool::TaskSlot</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signature of the callback slot to be executed in the threads of the thread pool. 
<p>
<b>Example:</b> Method signature for a TaskSlot. <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> method();
&lt;
</pre></div> 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="19f9f737bf5b11f317673323b31e325d"></a><!-- doxytag: member="Xfc::G::ThreadPool::ThreadPool" ref="19f9f737bf5b11f317673323b31e325d" args="(int max_threads=-1, bool exclusive=false, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::ThreadPool::ThreadPool           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_threads</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>exclusive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new thread pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max_threads</em>&nbsp;</td><td>The maximal number of threads to execute concurrently in the new thread pool, -1 means no limit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exclusive</em>&nbsp;</td><td>Should this thread pool be exclusive. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>.</td></tr>
  </table>
</dl>
Whenever you call <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#28418b11735d4988b6aaaaaebe133e21">push()</a>, either a new thread is created or an unused one is reused. At most <em>max_threads</em> threads are running concurrently for this thread pool. <em>max_threads</em> = -1 allows unlimited threads to be created for this thread pool.<p>
The parameter <em>exclusive</em> determines, whether the thread pool owns all threads exclusively or whether the threads are shared globally. If <em>exclusive</em> is true, <em>max_threads</em> threads are started immediately and they will run exclusively for this thread pool until it is destroyed. If <em>exclusive</em> is false, threads are created, when needed and shared between all non-exclusive thread pools. This implies that max_threads may not be -1 for exclusive thread pools.<p>
The error can be null to ignore errors, or non-null to report errors. An error can only occur when <em>exclusive</em> is set to true and not all <em>max_threads</em> threads could be created. 
</div>
</div><p>
<a class="anchor" name="2b8cd0c7c68b0f4acf6e4b35f3706bbb"></a><!-- doxytag: member="Xfc::G::ThreadPool::~ThreadPool" ref="2b8cd0c7c68b0f4acf6e4b35f3706bbb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::ThreadPool::~ThreadPool           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Frees the thread pool but not before the last task currently being processed is finished running. No new tasks are processed. 
</div>
</div><p>
<a class="anchor" name="19f9f737bf5b11f317673323b31e325d"></a><!-- doxytag: member="Xfc::G::ThreadPool::ThreadPool" ref="19f9f737bf5b11f317673323b31e325d" args="(int max_threads=-1, bool exclusive=false, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::ThreadPool::ThreadPool           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_threads</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>exclusive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new thread pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max_threads</em>&nbsp;</td><td>The maximal number of threads to execute concurrently in the new thread pool, -1 means no limit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exclusive</em>&nbsp;</td><td>Should this thread pool be exclusive. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>.</td></tr>
  </table>
</dl>
Whenever you call <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#28418b11735d4988b6aaaaaebe133e21">push()</a>, either a new thread is created or an unused one is reused. At most <em>max_threads</em> threads are running concurrently for this thread pool. <em>max_threads</em> = -1 allows unlimited threads to be created for this thread pool.<p>
The parameter <em>exclusive</em> determines, whether the thread pool owns all threads exclusively or whether the threads are shared globally. If <em>exclusive</em> is true, <em>max_threads</em> threads are started immediately and they will run exclusively for this thread pool until it is destroyed. If <em>exclusive</em> is false, threads are created, when needed and shared between all non-exclusive thread pools. This implies that max_threads may not be -1 for exclusive thread pools.<p>
The error can be null to ignore errors, or non-null to report errors. An error can only occur when <em>exclusive</em> is set to true and not all <em>max_threads</em> threads could be created. 
</div>
</div><p>
<a class="anchor" name="2b8cd0c7c68b0f4acf6e4b35f3706bbb"></a><!-- doxytag: member="Xfc::G::ThreadPool::~ThreadPool" ref="2b8cd0c7c68b0f4acf6e4b35f3706bbb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::G::ThreadPool::~ThreadPool           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Frees the thread pool but not before the last task currently being processed is finished running. No new tasks are processed. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e697408bcfb7ce8675f9dbb10a85a890"></a><!-- doxytag: member="Xfc::G::ThreadPool::get_max_threads" ref="e697408bcfb7ce8675f9dbb10a85a890" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::G::ThreadPool::get_max_threads           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the maximal number of threads for the pool. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the maximal number of threads. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6502c1af04bb706f786317404cb2ccfc"></a><!-- doxytag: member="Xfc::G::ThreadPool::get_num_threads" ref="6502c1af04bb706f786317404cb2ccfc" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Xfc::G::ThreadPool::get_num_threads           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of threads currently running in the pool. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of threads currently running. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e60c82c846cbfe2cac70ad2eb8fcb186"></a><!-- doxytag: member="Xfc::G::ThreadPool::unprocessed" ref="e60c82c846cbfe2cac70ad2eb8fcb186" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Xfc::G::ThreadPool::unprocessed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of tasks still unprocessed in the pool. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of unprocessed tasks. </dd></dl>

</div>
</div><p>
<a class="anchor" name="352660f6b998ed97ee956d18b65a8f08"></a><!-- doxytag: member="Xfc::G::ThreadPool::get_num_unused_threads" ref="352660f6b998ed97ee956d18b65a8f08" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int Xfc::G::ThreadPool::get_num_unused_threads           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of currently unused threads. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of currently unused threads. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f8460280b2af60fb0a4f7b06568d1156"></a><!-- doxytag: member="Xfc::G::ThreadPool::get_max_unused_threads" ref="f8460280b2af60fb0a4f7b06568d1156" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Xfc::G::ThreadPool::get_max_unused_threads           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the maximal allowed number of unused threads. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The maximal number of unused threads. </dd></dl>

</div>
</div><p>
<a class="anchor" name="28418b11735d4988b6aaaaaebe133e21"></a><!-- doxytag: member="Xfc::G::ThreadPool::push" ref="28418b11735d4988b6aaaaaebe133e21" args="(const TaskSlot &amp;slot, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::ThreadPool::push           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#7011220b494c63ba43d4102cbe6a23fc">TaskSlot</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <em>data</em> into the list of tasks to be executed by the pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>A new task to execute in the thread pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>.</td></tr>
  </table>
</dl>
When the number of currently running threads is lower than the maximal allowed number of threads, a new thread is started (or reused) with the properties given to the constructor. Otherwise <em>task</em> stays in the queue until a thread in this pool finishes its previous task and executes <em>task</em>. Do not <a class="el" href="classXfc_1_1Object.html#97861bfac97de2b84b18803c1bd560ca">unref()</a> the task slot when your finished. The pool will do this automatically when it gets destroyed.<p>
The <em>error</em> can be null to ignore errors, or non-null to report errors. An error can only occur when a new thread couldn't be created. In that case <em>task</em> is simply appended to the queue of work to do. 
</div>
</div><p>
<a class="anchor" name="852049b6987c6771babe94dd8fa39007"></a><!-- doxytag: member="Xfc::G::ThreadPool::set_max_threads" ref="852049b6987c6771babe94dd8fa39007" args="(int max_threads, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::ThreadPool::set_max_threads           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximal allowed number of threads for pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max_threads</em>&nbsp;</td><td>The new maximal number of threads for the pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>.</td></tr>
  </table>
</dl>
A value of -1 means, that the maximal number of threads is unlimited. Setting max_threads to 0 means stopping all work for pool. It is effectively frozen until max_threads is set to a non-zero value again. A thread is never terminated while calling a TaskSlot. Instead the maximal number of threads only has effect for the allocation of new threads in <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#28418b11735d4988b6aaaaaebe133e21">push()</a>. A new thread is allocated, whenever the number of currently running threads in pool is smaller than the maximal number.<p>
The <em>error</em> can be null to ignore errors, or non-null to report errors. An error can only occur when a new thread couldn't be created. In that case <em>data</em> is simply appended to the queue of work to do. 
</div>
</div><p>
<a class="anchor" name="667ab42bc7b1d5ada7dd1837196a5b89"></a><!-- doxytag: member="Xfc::G::ThreadPool::free" ref="667ab42bc7b1d5ada7dd1837196a5b89" args="(bool immediate=false, bool wait=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::ThreadPool::free           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>immediate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wait</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees all resources allocated for the pool. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>immediate</em>&nbsp;</td><td>Should pool shut down immediately (default is false)? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wait</em>&nbsp;</td><td>Should the pool wait for all tasks to finish (default is true)?</td></tr>
  </table>
</dl>
If <em>immediate</em> is true, no new task is processed for the pool. Otherwise the pool is not freed before the last task is processed. Note however, that no thread of the pool is interrupted, while processing a task. Instead at least all still running threads can finish their tasks before the pool is freed.<p>
If <em>wait</em> is true, the thread pool does not return before all tasks to be processed (dependent on immediate, whether all or only the currently running) are ready. Otherwise the thread pool returns immediately.<p>
Usually you wont need to call this method because the pool is automatically freed by the destructor when the pool object goes out of scope. The default values the destructor uses to free the pool are 'immediate == false' and 'wait == true'. The only reasons to call <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#667ab42bc7b1d5ada7dd1837196a5b89">free()</a> is either when you want to use different values for immediate and wait, or when you want to free a pool before the pool object goes out of scope. <a class="el" href="classXfc_1_1G_1_1ThreadPool.html#667ab42bc7b1d5ada7dd1837196a5b89">free()</a> is a wrapper around the C function call g_thread_pool_free() and doesn't <a class="el" href="classXfc_1_1Object.html#97861bfac97de2b84b18803c1bd560ca">unref()</a> the pool object. If you created the pool dynamically you still must call <a class="el" href="classXfc_1_1Object.html#97861bfac97de2b84b18803c1bd560ca">unref()</a>. However, as with all ReferencedObjects, if you created the pool on the stack you don't need to call <a class="el" href="classXfc_1_1Object.html#97861bfac97de2b84b18803c1bd560ca">unref()</a>. Note after calling this method the pool must not be used anymore. 
</div>
</div><p>
<a class="anchor" name="c7bf49b64682fe1631e5b56b14614ef8"></a><!-- doxytag: member="Xfc::G::ThreadPool::set_max_unused_threads" ref="c7bf49b64682fe1631e5b56b14614ef8" args="(int max_threads)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::G::ThreadPool::set_max_unused_threads           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_threads</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximal number of unused threads to max_threads. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max_threads</em>&nbsp;</td><td>The maximal number of unused threads.</td></tr>
  </table>
</dl>
If max_threads is -1, no limit is imposed on the number of unused threads. 
</div>
</div><p>
<a class="anchor" name="de54f4ec766de535fa2d327cd45c9d9e"></a><!-- doxytag: member="Xfc::G::ThreadPool::stop_unused_threads" ref="de54f4ec766de535fa2d327cd45c9d9e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::G::ThreadPool::stop_unused_threads           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stops all currently unused threads. 
<p>
This does not change the maximal number of unused threads. This method can be used to regularly stop all unused threads. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="threadpool_8hh.html">threadpool.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
