<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1Gdk.html">Gdk</a>::<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a></div>
<h1>Xfc::Gdk::Pixbuf Class Reference</h1><!-- doxytag: class="Xfc::Gdk::Pixbuf" --><!-- doxytag: inherits="Xfc::G::Object" -->A GdkPixbuf C++ wrapper class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/gdk-pixbuf/pixbuf.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::Gdk::Pixbuf:
<p><center><img src="classXfc_1_1Gdk_1_1Pixbuf.png" usemap="#Xfc::Gdk::Pixbuf_map" border="0" alt=""></center>
<map name="Xfc::Gdk::Pixbuf_map">
<area href="classXfc_1_1G_1_1Object.html" alt="Xfc::G::Object" shape="rect" coords="0,112,128,136">
<area href="classXfc_1_1G_1_1TypeInstance.html" alt="Xfc::G::TypeInstance" shape="rect" coords="0,56,128,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,128,24">
</map>
<a href="classXfc_1_1Gdk_1_1Pixbuf-members.html">List of all members.</a><h2>Public Types</h2>
<ul>
<li>typedef sigc::slot&lt; bool,<br>
 const char *, size_t, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> * &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#0c869e4a280cf35426aa8fbd0130fca1">SaveSlot</a>
<dl class="el"><dd class="mdescRight">Signature of the callback slot to be called when saving a pixbuf.  <a href="#0c869e4a280cf35426aa8fbd0130fca1"></a><br></dl></ul>
<h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="00786b5f4af61942e522a691e8949413"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::gdk_pixbuf" ref="00786b5f4af61942e522a691e8949413" args="() const" -->
GdkPixbuf * <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#00786b5f4af61942e522a691e8949413">gdk_pixbuf</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GdkPixbuf structure. <br></dl><li><a class="anchor" name="0b5cb47567cb0174ad11141ce48df268"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::operator GdkPixbuf *" ref="0b5cb47567cb0174ad11141ce48df268" args="() const" -->
<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#0b5cb47567cb0174ad11141ce48df268">operator GdkPixbuf *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; safely converts a <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> to a GdkPixbuf pointer. <br></dl><li><a class="anchor" name="d5f63234337cfa482af2c2fd5fde12e9"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::get_colorspace" ref="d5f63234337cfa482af2c2fd5fde12e9" args="() const" -->
<a class="el" href="namespaceXfc_1_1Gdk.html#fcd963ffba0a609e16c157cf4d2785b3">Colorspace</a> <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#d5f63234337cfa482af2c2fd5fde12e9">get_colorspace</a> () const
<dl class="el"><dd class="mdescRight">Returns the color space of a pixbuf. <br></dl><li><a class="anchor" name="2c1bb4402ec4a6e7cf469e6417404a03"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::get_n_channels" ref="2c1bb4402ec4a6e7cf469e6417404a03" args="() const" -->
int <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#2c1bb4402ec4a6e7cf469e6417404a03">get_n_channels</a> () const
<dl class="el"><dd class="mdescRight">Returns the number of channels of a pixbuf. <br></dl><li><a class="anchor" name="589d547dce89d8901d29de7c75fcedd3"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::get_has_alpha" ref="589d547dce89d8901d29de7c75fcedd3" args="() const" -->
bool <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#589d547dce89d8901d29de7c75fcedd3">get_has_alpha</a> () const
<dl class="el"><dd class="mdescRight">Returns true if a pixbuf has an alpha channel (opacity information). <br></dl><li><a class="anchor" name="a839c37816a591402a6f34e746a81ab0"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::get_bits_per_sample" ref="a839c37816a591402a6f34e746a81ab0" args="() const" -->
int <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#a839c37816a591402a6f34e746a81ab0">get_bits_per_sample</a> () const
<dl class="el"><dd class="mdescRight">Returns the number of bits per color sample in a pixbuf. <br></dl><li>unsigned char * <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#b60faa365196ef00ca7d2e999e9e6bb7">get_pixels</a> () const
<dl class="el"><dd class="mdescRight">Gets a pointer to the pixel data of a pixbuf.  <a href="#b60faa365196ef00ca7d2e999e9e6bb7"></a><br></dl><li><a class="anchor" name="92a7826ba0a3aaf5f3ed7783472753a9"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::get_width" ref="92a7826ba0a3aaf5f3ed7783472753a9" args="() const" -->
int <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#92a7826ba0a3aaf5f3ed7783472753a9">get_width</a> () const
<dl class="el"><dd class="mdescRight">Returns the width of a pixbuf in pixels. <br></dl><li><a class="anchor" name="586981840f98f6d51cce6b3808570730"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::get_height" ref="586981840f98f6d51cce6b3808570730" args="() const" -->
int <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#586981840f98f6d51cce6b3808570730">get_height</a> () const
<dl class="el"><dd class="mdescRight">Returns the height of a pixbuf in pixels. <br></dl><li><a class="anchor" name="f83955fdfb214510bd495486940c3827"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::get_rowstride" ref="f83955fdfb214510bd495486940c3827" args="() const" -->
int <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#f83955fdfb214510bd495486940c3827">get_rowstride</a> () const
<dl class="el"><dd class="mdescRight">Returns the rowstride of a pixbuf, which is the number of bytes between rows. <br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#2bda1fe36ab29b49d97b17a14bd1bd8f">get_option</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;key) const
<dl class="el"><dd class="mdescRight">Looks up <em>key</em> in the list of options that may have been attached to the pixbuf when it was loaded.  <a href="#2bda1fe36ab29b49d97b17a14bd1bd8f"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#b3686feb6c4e6e706cf6b50e3be6bac6">copy</a> () const
<dl class="el"><dd class="mdescRight">Creates a new pixbuf from a copy of the information in this pixbuf.  <a href="#b3686feb6c4e6e706cf6b50e3be6bac6"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#d96b2a544e2bd4cc00bab3745bc420af">fill</a> (unsigned int pixel)
<dl class="el"><dd class="mdescRight">Clears a pixbuf to the given RGBA value, converting the RGBA value into the pixbuf's pixel format.  <a href="#d96b2a544e2bd4cc00bab3745bc420af"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#7fb61ece09c334cc2ff6ff7872e953d8">save</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;filename, const char *type, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error,...)
<dl class="el"><dd class="mdescRight">Saves the pixbuf to a file in type, which is currently "jpeg" or "png".  <a href="#7fb61ece09c334cc2ff6ff7872e953d8"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#c33d69bcd6e021ba58b4b043b90ca83c">save</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;filename, const char *type, char **option_keys, char **option_values, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Saves the pixbuf to a file in type, which is currently "jpeg" or "png".  <a href="#c33d69bcd6e021ba58b4b043b90ca83c"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#c47e1fc41dfcdedda6b6b84c5a480611">save</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#0c869e4a280cf35426aa8fbd0130fca1">SaveSlot</a> &amp;slot, const char *type, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error,...)
<dl class="el"><dd class="mdescRight">Saves the pixbuf in format type by feeding the produced data to a callback slot.  <a href="#c47e1fc41dfcdedda6b6b84c5a480611"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#1338bd1926306ff3d0d7eda8d2aab36e">save</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#0c869e4a280cf35426aa8fbd0130fca1">SaveSlot</a> &amp;slot, const char *type, char **option_keys, char **option_values, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Saves the pixbuf to a callback slot in format type, which is currently "jpeg", "png" or "ico".  <a href="#1338bd1926306ff3d0d7eda8d2aab36e"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#b80a3dbbff8b45054c209f8ce41e34ab">save</a> (char **buffer, size_t *buffer_size, const char *type, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error,...)
<dl class="el"><dd class="mdescRight">Saves the pixbuf to a new buffer in format type, which is currently "jpeg", "png" or "ico".  <a href="#b80a3dbbff8b45054c209f8ce41e34ab"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#823b17de6715efb499274424f254caa4">save</a> (char **buffer, size_t *buffer_size, const char *type, char **option_keys, char **option_values, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Saves the pixbuf to a new buffer in format type, which is currently "jpeg", "png" or "ico".  <a href="#823b17de6715efb499274424f254caa4"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#cd5cabc67b92f57d7cd948dcc4018f35">add_alpha</a> (bool substitute_color, unsigned char red, unsigned char green, unsigned char blue)
<dl class="el"><dd class="mdescRight">Adds an alpha channel to this pixbuf and returns the result as a new pixbuf.  <a href="#cd5cabc67b92f57d7cd948dcc4018f35"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#6761994ad48e64d84ff8cb7c642b54bf">copy_area</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;src, int src_x, int src_y, int width, int height, int dest_x, int dest_y)
<dl class="el"><dd class="mdescRight">Copies a rectangular area from <em>src</em> to this pixbuf; conversion of pixbuf formats is done automatically.  <a href="#6761994ad48e64d84ff8cb7c642b54bf"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#35b31661976aa2c6d74c9b64ea0e2e98">copy_area</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;src, const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;src_rect, int dest_x, int dest_y)
<dl class="el"><dd class="mdescRight">Copies a rectangular area from <em>src</em> to this pixbuf; conversion of pixbuf formats is done automatically.  <a href="#35b31661976aa2c6d74c9b64ea0e2e98"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#9ea0ce7b23540ada8a6801437ad95b7a">saturate_and_pixelate</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;src, float saturation, bool pixelate)
<dl class="el"><dd class="mdescRight">Modifies saturation and optionally pixelates <em>src</em>, placing the result this pixbuf.  <a href="#9ea0ce7b23540ada8a6801437ad95b7a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#5f8bc787e45b5d50dfae1592e3f72a0f">saturate_and_pixelate</a> (float saturation, bool pixelate)
<dl class="el"><dd class="mdescRight">Modifies saturation and optionally pixelates the pixbuf.  <a href="#5f8bc787e45b5d50dfae1592e3f72a0f"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Transformation Methods</div></td></tr>
<ul>
<li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#209f0d7b871cba385bd044dcbd0db48c">scale_simple</a> (int width, int height, <a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a> interp_type)
<dl class="el"><dd class="mdescRight">Create a new pixbuf containing a copy of this pixbuf scaled to width x height.  <a href="#209f0d7b871cba385bd044dcbd0db48c"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#b59a5a2ef72431e1563f4b4c23563022">scale</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;src, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, <a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a> interp_type)
<dl class="el"><dd class="mdescRight">Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then renders the rectangle (dest_x, dest_y, dest_width, dest_height) of the resulting image onto the destination image replacing the previous contents.  <a href="#b59a5a2ef72431e1563f4b4c23563022"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#e502f0589eb18e7d565292aa0593bfd7">scale</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;src, const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;dest_rect, double offset_x, double offset_y, double scale_x, double scale_y, <a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a> interp_type)
<dl class="el"><dd class="mdescRight">Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then renders the rectangle <em>dest_rect</em> of the resulting image onto the destination image replacing the previous contents.  <a href="#e502f0589eb18e7d565292aa0593bfd7"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#e9f8f49037bc1438f84e03979bbe0f9d">composite_color_simple</a> (int width, int height, <a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a> interp_type, int overall_alpha, int check_size, unsigned int color1, unsigned int color2)
<dl class="el"><dd class="mdescRight">Creates a new pixbuf by scaling this pixbuf to <em>width</em> x <em>height</em> and compositing the result with a checkboard of colors <em>color1</em> and <em>color2</em>.  <a href="#e9f8f49037bc1438f84e03979bbe0f9d"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#6c9a709e03e9373d57713d24fe832596">composite</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;src, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, <a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a> interp_type, int overall_alpha)
<dl class="el"><dd class="mdescRight">Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then composites the rectangle (dest_x, dest_y, dest_width, dest_height) of the resulting image onto the destination image.  <a href="#6c9a709e03e9373d57713d24fe832596"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#86db49df03db32bb548d0b44d59b4873">composite</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;src, const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;dest_rect, double offset_x, double offset_y, double scale_x, double scale_y, <a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a> interp_type, int overall_alpha)
<dl class="el"><dd class="mdescRight">Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then composites the rectangle <em>dest_rect</em> of the resulting image onto the destination image.  <a href="#86db49df03db32bb548d0b44d59b4873"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#b927ccc3c7e3a45ec29909e4e58f783b">composite_color</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;src, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, <a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a> interp_type, int overall_alpha, int check_x, int check_y, int check_size, unsigned int color1, unsigned int color2)
<dl class="el"><dd class="mdescRight">Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then composites the rectangle (dest_x, dest_y, dest_width, dest_height) of the resulting image with a checkboard of the colors <em>color1</em> and <em>color2</em> and renders it onto the destination image.  <a href="#b927ccc3c7e3a45ec29909e4e58f783b"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#c3c9e1c6ae8fff4d63d8d4d8e40f01cc">composite_color</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;src, const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;dest_rect, double offset_x, double offset_y, double scale_x, double scale_y, <a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a> interp_type, int overall_alpha, const <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> &amp;check_offset, int check_size, unsigned int color1, unsigned int color2)
<dl class="el"><dd class="mdescRight">Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then composites the rectangle <em>dest_rect</em> of the resulting image with a checkboard of the colors <em>color1</em> and <em>color2</em> and renders it onto the destination image.  <a href="#c3c9e1c6ae8fff4d63d8d4d8e40f01cc"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#6e582932d5e25d092b9efc91255fa7eb">rotate_simple</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#870f127241c38f7f4ad019608c1770ac">PixbufRotation</a> angle)
<dl class="el"><dd class="mdescRight">Rotates a the pixbuf by a multiple of 90 degrees, and returns the result in a new pixbuf.  <a href="#6e582932d5e25d092b9efc91255fa7eb"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#089b81e0931952523e58aa12b5459db1">flip</a> (bool horizontal)
<dl class="el"><dd class="mdescRight">Flips the pixbuf horizontally or vertically and returns the result in a new pixbuf.  <a href="#089b81e0931952523e58aa12b5459db1"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">GDK Pixbuf Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#6aabc3b00a95e6cd269711d58990683a">render_threshold_alpha</a> (<a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Bitmap</a> &amp;bitmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height, int alpha_threshold)
<dl class="el"><dd class="mdescRight">Takes the opacity values in a rectangular portion of the pixbuf and thresholds them to produce a bi-level alpha mask that can be used as a clipping mask for a drawable.  <a href="#6aabc3b00a95e6cd269711d58990683a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#b176645cc3bb3c1bc08f143c959fed64">render_pixmap_and_mask</a> (<a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixmap.html">Pixmap</a> &gt; *pixmap_return, <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Bitmap</a> &gt; *mask_return, int alpha_threshold, <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a> *colormap=0)
<dl class="el"><dd class="mdescRight">Creates a pixmap and a mask bitmap which are returned in the pixmap_return and mask_return arguments, respectively, and renders a pixbuf and its corresponding thresholded alpha mask to them.  <a href="#b176645cc3bb3c1bc08f143c959fed64"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#4c69d0c63891d0361ed9855f2a9ee171">get_from_drawable</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Drawable.html">Drawable</a> &amp;src, int src_x, int src_y, int dest_x, int dest_y, int width, int height, <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a> *colormap=0)
<dl class="el"><dd class="mdescRight">Transfers (copies) image data from a server-side drawable to the client-side RGB(A) buffer inside this pixbuf.  <a href="#4c69d0c63891d0361ed9855f2a9ee171"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#a3744d86228dfac0f3b46b67f2fdca22">get_from_image</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Image.html">Image</a> &amp;src, int src_x, int src_y, int dest_x, int dest_y, int width, int height, <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a> *colormap=0)
<dl class="el"><dd class="mdescRight">Copies image data from an <a class="el" href="classXfc_1_1Gdk_1_1Image.html">Image</a> to this pixbuf (see <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#4c69d0c63891d0361ed9855f2a9ee171">get_from_drawable()</a> for details).  <a href="#a3744d86228dfac0f3b46b67f2fdca22"></a><br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#197760e293fe3786577a35c503dfd7b3">create</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;filename, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Creates a new pixbuf by loading an image from a file.  <a href="#197760e293fe3786577a35c503dfd7b3"></a><br></dl><li>static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#b239463ad71c4d750a61d8ad0c5180a2">create</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;filename, int width, int height, bool preserve_aspect_ratio, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Creates a new pixbuf by loading an image from a file.  <a href="#b239463ad71c4d750a61d8ad0c5180a2"></a><br></dl><li>static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#21013fd6b2d8f41a9474eb2df297ea11">create</a> (int width, int height, bool has_alpha, int bits_per_sample=8, <a class="el" href="namespaceXfc_1_1Gdk.html#fcd963ffba0a609e16c157cf4d2785b3">Colorspace</a> colorspace=COLORSPACE_RGB)
<dl class="el"><dd class="mdescRight">Creates a new (blank) pixbuf with an optimal rowstride and a new buffer.  <a href="#21013fd6b2d8f41a9474eb2df297ea11"></a><br></dl><li>static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#c62642c586dea085e6536967f0cd44b2">create</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Drawable.html">Drawable</a> &amp;drawable, int x, int y, int width, int height, <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a> *colormap=0)
<dl class="el"><dd class="mdescRight">Creates a new pixbuf with image data from a server-side drawable (see <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#4c69d0c63891d0361ed9855f2a9ee171">get_from_drawable()</a> for full details).  <a href="#c62642c586dea085e6536967f0cd44b2"></a><br></dl><li>static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#10bb97e9672844c95a3c031fa8f17cb1">create</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Image.html">Image</a> &amp;image, int x, int y, int width, int height, <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a> *colormap=0)
<dl class="el"><dd class="mdescRight">Creates a new pixbuf from the specified image (see <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#4c69d0c63891d0361ed9855f2a9ee171">get_from_drawable()</a> for full details).  <a href="#10bb97e9672844c95a3c031fa8f17cb1"></a><br></dl><li>static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#4352f108c6ae169350f6ccb20b830d58">create</a> (int data_length, const unsigned char *data, bool copy_pixels, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Creates a pixbuf from a flat representation that is suitable for storing as inline data in a program.  <a href="#4352f108c6ae169350f6ccb20b830d58"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GdkPixbuf C++ wrapper class. 
<p>
<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> is an object that contains information describing an image in memory.<p>
The XFC demo program has several examples of using <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> with Pixbufs. See &lt;demowindow.cc&gt; and &lt;image.cc&gt; in the &lt;demos/gfc-demo&gt; subdirectory.<p>
Note: <em>dynamically allocated objects must either be unreferenced or assigned to a smart pointer. Stack objects are automatically unreferenced when they go out of scope.</em> 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="0c869e4a280cf35426aa8fbd0130fca1"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::SaveSlot" ref="0c869e4a280cf35426aa8fbd0130fca1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef sigc::slot&lt;bool, const char*, size_t, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>*&gt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#0c869e4a280cf35426aa8fbd0130fca1">Xfc::Gdk::Pixbuf::SaveSlot</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signature of the callback slot to be called when saving a pixbuf. 
<p>
<b>Example:</b> Method signature for SaveSlot. <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> method(<span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, size_t count, G::Error *error);
&lt;
&lt; <span class="comment">// buffer: The bytes to be written. </span>
&lt; <span class="comment">// count:  The number of bytes in &lt;EM&gt;buffer&lt;/EM&gt;. </span>
&lt; <span class="comment">// error:  The return location for any error.</span>
&lt; <span class="comment">// return: true if successful, false (with error set) if failed. </span>
&lt;
</pre></div><p>
SaveSlot is called once for each block of bytes that is "written" by one of the overloaded save methods. If successful it should return true. If an error occurs it should set error and return false, in which case the save method will fail with the same error. 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6f7252edbe3dc8d4553ce7a1d4f702d1"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::Pixbuf" ref="6f7252edbe3dc8d4553ce7a1d4f702d1" args="(GdkPixbuf *pixbuf, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Pixbuf::Pixbuf           </td>
          <td>(</td>
          <td class="paramtype">GdkPixbuf *&nbsp;</td>
          <td class="paramname"> <em>pixbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> from an existing GdkPixbuf. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixbuf</em>&nbsp;</td><td>A pointer to a GdkPixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>pixbuf</em> can be a newly created GdkPixbuf or an existing GdkPixbuf. (see G::Object::Object). 
</div>
</div><p>
<a class="anchor" name="8dd1bbceed93a72ddc1a6993107fc698"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::Pixbuf" ref="8dd1bbceed93a72ddc1a6993107fc698" args="(const Pixbuf &amp;src, int src_x, int src_y, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Pixbuf::Pixbuf           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new pixbuf (a sub-pixbuf) which represents a sub-region of <em>src</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_x</em>&nbsp;</td><td>The source X coordinate in <em>src</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_y</em>&nbsp;</td><td>The source Y coordinate in <em>src</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of the region in <em>src</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of region in <em>src</em>.</td></tr>
  </table>
</dl>
The new pixbuf shares its pixels with the original pixbuf, so writing to one affects both. The new pixbuf holds a reference to <em>src</em> pixbuf, so <em>src</em> pixbuf will not be finalized until the new pixbuf is finalized. <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> is created with a reference count of 1 that the caller owns. 
</div>
</div><p>
<a class="anchor" name="e1802c1c80b111260ab32987b8385931"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::Pixbuf" ref="e1802c1c80b111260ab32987b8385931" args="(const unsigned char *data, int width, int height, int rowstride, bool has_alpha, GdkPixbufDestroyNotify destroy_fn=0, void *destroy_fn_data=0, int bits_per_sample=8, Colorspace colorspace=COLORSPACE_RGB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Pixbuf::Pixbuf           </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rowstride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>has_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GdkPixbufDestroyNotify&nbsp;</td>
          <td class="paramname"> <em>destroy_fn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>destroy_fn_data</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bits_per_sample</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#fcd963ffba0a609e16c157cf4d2785b3">Colorspace</a>&nbsp;</td>
          <td class="paramname"> <em>colorspace</em> = <code>COLORSPACE_RGB</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new pixbuf out of in-memory image data. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The image data in 8-bit/sample packed format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of the image in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of the image in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowstride</em>&nbsp;</td><td>The distance in bytes between rows. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>has_alpha</em>&nbsp;</td><td>Whether the data has an opacity channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destroy_fn</em>&nbsp;</td><td>The function used to free the data when the pixbuf's reference count drops to zero, or null if the data should not be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destroy_fn_data</em>&nbsp;</td><td>The closure data to pass to the destroy notification function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits_per_sample</em>&nbsp;</td><td>The number of bits per sample. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colorspace</em>&nbsp;</td><td>The <a class="el" href="namespaceXfc_1_1Gdk.html#fcd963ffba0a609e16c157cf4d2785b3">Gdk::Colorspace</a> for the image data.</td></tr>
  </table>
</dl>
Currently only RGB images with 8 bits per sample are supported. Wrapping an existing pixel buffer is the most basic way to construct a pixbuf. You need to specify the destroy notification function that will be called when the data buffer needs to be freed; this will happen when a <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> is finalized by the reference counting functions. If you have a chunk of static data compiled into your application, you can pass in null as the destroy notification function so that the data will not be freed. <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> is created with a reference count of 1 that the caller owns. 
</div>
</div><p>
<a class="anchor" name="9d76d7e527fac7ffed383c655c2f3a4e"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::Pixbuf" ref="9d76d7e527fac7ffed383c655c2f3a4e" args="(const char **data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Pixbuf::Pixbuf           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new pixbuf by parsing XPM data in memory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to inline XPM data.</td></tr>
  </table>
</dl>
This data is commonly the result of including an XPM file into a program's C source. <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> is created with a reference count of 1 that the caller owns. 
</div>
</div><p>
<a class="anchor" name="6f7252edbe3dc8d4553ce7a1d4f702d1"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::Pixbuf" ref="6f7252edbe3dc8d4553ce7a1d4f702d1" args="(GdkPixbuf *pixbuf, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Pixbuf::Pixbuf           </td>
          <td>(</td>
          <td class="paramtype">GdkPixbuf *&nbsp;</td>
          <td class="paramname"> <em>pixbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> from an existing GdkPixbuf. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixbuf</em>&nbsp;</td><td>A pointer to a GdkPixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>pixbuf</em> can be a newly created GdkPixbuf or an existing GdkPixbuf. (see G::Object::Object). 
</div>
</div><p>
<a class="anchor" name="8dd1bbceed93a72ddc1a6993107fc698"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::Pixbuf" ref="8dd1bbceed93a72ddc1a6993107fc698" args="(const Pixbuf &amp;src, int src_x, int src_y, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Pixbuf::Pixbuf           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new pixbuf (a sub-pixbuf) which represents a sub-region of <em>src</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_x</em>&nbsp;</td><td>The source X coordinate in <em>src</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_y</em>&nbsp;</td><td>The source Y coordinate in <em>src</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of the region in <em>src</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of region in <em>src</em>.</td></tr>
  </table>
</dl>
The new pixbuf shares its pixels with the original pixbuf, so writing to one affects both. The new pixbuf holds a reference to <em>src</em> pixbuf, so <em>src</em> pixbuf will not be finalized until the new pixbuf is finalized. <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> is created with a reference count of 1 that the caller owns. 
</div>
</div><p>
<a class="anchor" name="e1802c1c80b111260ab32987b8385931"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::Pixbuf" ref="e1802c1c80b111260ab32987b8385931" args="(const unsigned char *data, int width, int height, int rowstride, bool has_alpha, GdkPixbufDestroyNotify destroy_fn=0, void *destroy_fn_data=0, int bits_per_sample=8, Colorspace colorspace=COLORSPACE_RGB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Pixbuf::Pixbuf           </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rowstride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>has_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GdkPixbufDestroyNotify&nbsp;</td>
          <td class="paramname"> <em>destroy_fn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>destroy_fn_data</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bits_per_sample</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#fcd963ffba0a609e16c157cf4d2785b3">Colorspace</a>&nbsp;</td>
          <td class="paramname"> <em>colorspace</em> = <code>COLORSPACE_RGB</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new pixbuf out of in-memory image data. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The image data in 8-bit/sample packed format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of the image in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of the image in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowstride</em>&nbsp;</td><td>The distance in bytes between rows. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>has_alpha</em>&nbsp;</td><td>Whether the data has an opacity channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destroy_fn</em>&nbsp;</td><td>The function used to free the data when the pixbuf's reference count drops to zero, or null if the data should not be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destroy_fn_data</em>&nbsp;</td><td>The closure data to pass to the destroy notification function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits_per_sample</em>&nbsp;</td><td>The number of bits per sample. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colorspace</em>&nbsp;</td><td>The <a class="el" href="namespaceXfc_1_1Gdk.html#fcd963ffba0a609e16c157cf4d2785b3">Gdk::Colorspace</a> for the image data.</td></tr>
  </table>
</dl>
Currently only RGB images with 8 bits per sample are supported. Wrapping an existing pixel buffer is the most basic way to construct a pixbuf. You need to specify the destroy notification function that will be called when the data buffer needs to be freed; this will happen when a <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> is finalized by the reference counting functions. If you have a chunk of static data compiled into your application, you can pass in null as the destroy notification function so that the data will not be freed. <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> is created with a reference count of 1 that the caller owns. 
</div>
</div><p>
<a class="anchor" name="9d76d7e527fac7ffed383c655c2f3a4e"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::Pixbuf" ref="9d76d7e527fac7ffed383c655c2f3a4e" args="(const char **data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Pixbuf::Pixbuf           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new pixbuf by parsing XPM data in memory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to inline XPM data.</td></tr>
  </table>
</dl>
This data is commonly the result of including an XPM file into a program's C source. <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> is created with a reference count of 1 that the caller owns. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="197760e293fe3786577a35c503dfd7b3"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::create" ref="197760e293fe3786577a35c503dfd7b3" args="(const String &amp;filename, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new pixbuf by loading an image from a file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The name of file to load. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for an error. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A newly-created pixbuf, or null if any of several error conditions occurred.</dd></dl>
The file format is detected automatically. If an error occurs, then <em>error</em> will be set and <a class="el" href="classXfc_1_1G_1_1Error.html#3e07a615c48a30a599aa5946667c6d26">G::Error::get()</a> will return true. Possible errors are in the GDK_PIXBUF_ERROR and G_FILE_ERROR domains.<p>
The image is loaded from the file in a synchronous fashion. This means that the GDK-PIXBUF library takes control of the application while the file is being loaded; from the user's point of view, the application will block until the image is done loading. This constructor can be used by applications in which blocking is acceptable while an image is being loaded. It can also be used to load small images in general. Applications that need progressive loading can use the <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html">PixbufLoader</a> functionality instead. 
</div>
</div><p>
<a class="anchor" name="b239463ad71c4d750a61d8ad0c5180a2"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::create" ref="b239463ad71c4d750a61d8ad0c5180a2" args="(const String &amp;filename, int width, int height, bool preserve_aspect_ratio, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>preserve_aspect_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new pixbuf by loading an image from a file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The name of file to load. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width the image should have. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height the image should have. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>preserve_aspect_ratio</em>&nbsp;</td><td>Set to <em>true</em> to preserve the image's aspect ratio. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for an error. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A newly-created pixbuf, or null if any of several error conditions occurred.</dd></dl>
The file format is detected automatically. If an error occurs, then <em>error</em> will be set and <a class="el" href="classXfc_1_1G_1_1Error.html#3e07a615c48a30a599aa5946667c6d26">G::Error::get()</a> will return true. Possible errors are in the GDK_PIXBUF_ERROR and G_FILE_ERROR domains. The image will be scaled to fit in the requested size, preserving its aspect ratio.<p>
Possible error conditions include: the file could not be opened, there was no loader for the file's format, there was not enough memory to allocate the image buffer, or the image file contained invalid data. 
</div>
</div><p>
<a class="anchor" name="21013fd6b2d8f41a9474eb2df297ea11"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::create" ref="21013fd6b2d8f41a9474eb2df297ea11" args="(int width, int height, bool has_alpha, int bits_per_sample=8, Colorspace colorspace=COLORSPACE_RGB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::create           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>has_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bits_per_sample</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#fcd963ffba0a609e16c157cf4d2785b3">Colorspace</a>&nbsp;</td>
          <td class="paramname"> <em>colorspace</em> = <code>COLORSPACE_RGB</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new (blank) pixbuf with an optimal rowstride and a new buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of the image in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of the image in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>has_alpha</em>&nbsp;</td><td>Whether the image should have transparency information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits_per_sample</em>&nbsp;</td><td>The number of bits per color sample. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colorspace</em>&nbsp;</td><td>The <a class="el" href="namespaceXfc_1_1Gdk.html#fcd963ffba0a609e16c157cf4d2785b3">Gdk::Colorspace</a> for the image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the new pixbuf, or null if not enough memory could be allocated.</dd></dl>
Note that the buffer is not cleared; you will have to fill it completely yourself. This is a convenience constructor used to create a pixbuf with an empty buffer. This is equivalent to constructing a pixbuf with a newly allocating data buffer. It computes an optimal rowstride so that rendering can be performed with an efficient algorithm. 
</div>
</div><p>
<a class="anchor" name="c62642c586dea085e6536967f0cd44b2"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::create" ref="c62642c586dea085e6536967f0cd44b2" args="(const Drawable &amp;drawable, int x, int y, int width, int height, Colormap *colormap=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Drawable.html">Drawable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>drawable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a> *&nbsp;</td>
          <td class="paramname"> <em>colormap</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new pixbuf with image data from a server-side drawable (see <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#4c69d0c63891d0361ed9855f2a9ee171">get_from_drawable()</a> for full details). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>drawable</em>&nbsp;</td><td>The source drawable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The source X coordinate within <em>drawable</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The source Y coordinate within <em>drawable</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width in pixels of region to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height in pixels of region to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colormap</em>&nbsp;</td><td>A colormap if <em>drawable</em> doesn't have one set. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the new pixbuf, or null if an error occurs; The new pixbuf has no alpha channel. </dd></dl>

</div>
</div><p>
<a class="anchor" name="10bb97e9672844c95a3c031fa8f17cb1"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::create" ref="10bb97e9672844c95a3c031fa8f17cb1" args="(const Image &amp;image, int x, int y, int width, int height, Colormap *colormap=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a> *&nbsp;</td>
          <td class="paramname"> <em>colormap</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new pixbuf from the specified image (see <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#4c69d0c63891d0361ed9855f2a9ee171">get_from_drawable()</a> for full details). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The source image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The source X coordinate within <em>image</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The source Y coordinate within <em>image</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width in pixels of region to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height in pixels of region to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colormap</em>&nbsp;</td><td>A colormap if <em>image</em> doesn't have one set. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if successful, <em>false</em> if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4352f108c6ae169350f6ccb20b830d58"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::create" ref="4352f108c6ae169350f6ccb20b830d58" args="(int data_length, const unsigned char *data, bool copy_pixels, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::create           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>data_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copy_pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a pixbuf from a flat representation that is suitable for storing as inline data in a program. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data_length</em>&nbsp;</td><td>The length in bytes of the data argument. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The byte data containing a serialized GdkPixdata structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_pixels</em>&nbsp;</td><td>Set <em>true</em> to copy the pixel data, or use direct pointers data for the resulting pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> return location, may be null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A newly-created <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>, or null if an error occurred.</dd></dl>
This is useful if you want to ship a program with images, but don't want to depend on any external files. GTK+ ships with a program called gdk-pixbuf-csource which allows for conversion of GdkPixbufs into such a inline representation. In almost all cases, you should pass the --raw flag to gdk-pixbuf-csource. A sample invocation would be:<br>
 <div class="fragment"><pre class="fragment">&lt; gdk-pixbuf-csource --raw --name=myimage_inline myimage.png
&lt;
</pre></div> For the typical case where the inline pixbuf is read-only static data, you don't need to copy the pixel data unless you intend to write to it, so you can pass false for copy_pixels. (If you pass --rle to gdk-pixbuf-csource, a copy will be made even if copy_pixels is false, so using this option is generally a bad idea.)<p>
If you create a pixbuf from const inline data compiled into your program, it's probably safe to ignore errors, since things will always succeed. For non-const inline data, you could get out of memory. For untrusted inline data located at runtime, you could have corrupt inline data in addition. 
</div>
</div><p>
<a class="anchor" name="b60faa365196ef00ca7d2e999e9e6bb7"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::get_pixels" ref="b60faa365196ef00ca7d2e999e9e6bb7" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* Xfc::Gdk::Pixbuf::get_pixels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a pointer to the pixel data of a pixbuf. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the pixbuf's pixel data. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2bda1fe36ab29b49d97b17a14bd1bd8f"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::get_option" ref="2bda1fe36ab29b49d97b17a14bd1bd8f" args="(const String &amp;key) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Gdk::Pixbuf::get_option           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up <em>key</em> in the list of options that may have been attached to the pixbuf when it was loaded. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1String.html">String</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value associated with <em>key</em>, or a null <a class="el" href="classXfc_1_1String.html">String</a> if <em>key</em> was not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3686feb6c4e6e706cf6b50e3be6bac6"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::copy" ref="b3686feb6c4e6e706cf6b50e3be6bac6" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::copy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new pixbuf from a copy of the information in this pixbuf. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A newly created pixbuf, or null if not enough memory could be allocated.</dd></dl>
This is not the same as just doing a <a class="el" href="classXfc_1_1G_1_1Object.html#47f87a1180f4950eba164d60aa281283">ref()</a> on the old pixbuf; the copy method will actually duplicate the pixel data in memory and create a new <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> for it. 
</div>
</div><p>
<a class="anchor" name="d96b2a544e2bd4cc00bab3745bc420af"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::fill" ref="d96b2a544e2bd4cc00bab3745bc420af" args="(unsigned int pixel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::fill           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pixel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears a pixbuf to the given RGBA value, converting the RGBA value into the pixbuf's pixel format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixel</em>&nbsp;</td><td>The RGBA pixel to clear to (0xffffffff is opaque white, 0x00000000 transparent black).</td></tr>
  </table>
</dl>
The alpha will be ignored if the pixbuf doesn't have an alpha channel. 
</div>
</div><p>
<a class="anchor" name="7fb61ece09c334cc2ff6ff7872e953d8"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::save" ref="7fb61ece09c334cc2ff6ff7872e953d8" args="(const String &amp;filename, const char *type, G::Error *error,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Pixbuf::save           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the pixbuf to a file in type, which is currently "jpeg" or "png". 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The name of the file to save. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The name of the file format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for any error, or null to ignore errors. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>A variable list of key-value (char* / char*) save options. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if an error was set.</dd></dl>
If error is set, false will be returned. Possible errors include those in the GDK_PIXBUF_ERROR and the G_FILE_ERROR domains. The variable argument list should be null-terminated; if not empty, it should contain pairs of character strings that modify the save parameters. For example:<br>
 <div class="fragment"><pre class="fragment">&lt; G::Error error;
&lt; pixbuf-&gt;save(filename, <span class="stringliteral">"jpeg"</span>, &amp;error, <span class="stringliteral">"quality"</span>, <span class="stringliteral">"100"</span>, 0);
&lt;
</pre></div> Currently only a few parameters exist. JPEG images can be saved with a "quality" parameter with a value in the range [0,100]. Text chunks can be attached to PNG images by specifying parameters of the form  "tEXt::key", where key is an ASCII string of length 1-79. The values are UTF-8 encoded strings. 
</div>
</div><p>
<a class="anchor" name="c33d69bcd6e021ba58b4b043b90ca83c"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::save" ref="c33d69bcd6e021ba58b4b043b90ca83c" args="(const String &amp;filename, const char *type, char **option_keys, char **option_values, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Pixbuf::save           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>option_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>option_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the pixbuf to a file in type, which is currently "jpeg" or "png". 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The name of the file to save. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The name of the file format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option_keys</em>&nbsp;</td><td>The name of the options to set, null-terminated; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option_values</em>&nbsp;</td><td>The values for the named options. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for any error, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if an error was set.</dd></dl>
If error is set, false will be returned. Possible errors include those in the GDK_PIXBUF_ERROR and the G_FILE_ERROR domains. 
</div>
</div><p>
<a class="anchor" name="c47e1fc41dfcdedda6b6b84c5a480611"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::save" ref="c47e1fc41dfcdedda6b6b84c5a480611" args="(const SaveSlot &amp;slot, const char *type, G::Error *error,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Pixbuf::save           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#0c869e4a280cf35426aa8fbd0130fca1">SaveSlot</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the pixbuf in format type by feeding the produced data to a callback slot. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>A callback slot that is called to save each block of data that the save routine generates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The name of file format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for any error, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>A variable list of key-value (char* / char*) save options. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether an error was set.</dd></dl>
Can be used when you want to store the image to something other than a file, such as an in-memory buffer or a socket. If error is set, false will be returned. Possible errors include those in the GDK_PIXBUF_ERROR domain and whatever the save function generates. 
</div>
</div><p>
<a class="anchor" name="1338bd1926306ff3d0d7eda8d2aab36e"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::save" ref="1338bd1926306ff3d0d7eda8d2aab36e" args="(const SaveSlot &amp;slot, const char *type, char **option_keys, char **option_values, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Pixbuf::save           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#0c869e4a280cf35426aa8fbd0130fca1">SaveSlot</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>option_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>option_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the pixbuf to a callback slot in format type, which is currently "jpeg", "png" or "ico". 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>A callback slot that is called to save each block of data that the save routine generates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The name of file format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option_keys</em>&nbsp;</td><td>The name of options to set, null-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option_values</em>&nbsp;</td><td>The values for the named <em>options</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for any error, or null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether an error was set.</dd></dl>
If error is set, <em>false</em> will be returned. 
</div>
</div><p>
<a class="anchor" name="b80a3dbbff8b45054c209f8ce41e34ab"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::save" ref="b80a3dbbff8b45054c209f8ce41e34ab" args="(char **buffer, size_t *buffer_size, const char *type, G::Error *error,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Pixbuf::save           </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the pixbuf to a new buffer in format type, which is currently "jpeg", "png" or "ico". 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The location to receive a pointer to the new buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_size</em>&nbsp;</td><td>The location to receive the size of the new buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The name of file format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for any error, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>A variable list of key-value (char* / char*) save options. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether an error was set.</dd></dl>
This is a convenience function that uses gdk_pixbuf_save_to_callback() to do the real work. Note that the buffer is not null-terminated and may contain embedded nulls. If error is set, <em>false</em> will be returned and the string will be set to null. Possible errors include those in the GDK_PIXBUF_ERROR domain. 
</div>
</div><p>
<a class="anchor" name="823b17de6715efb499274424f254caa4"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::save" ref="823b17de6715efb499274424f254caa4" args="(char **buffer, size_t *buffer_size, const char *type, char **option_keys, char **option_values, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Pixbuf::save           </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>option_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>option_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the pixbuf to a new buffer in format type, which is currently "jpeg", "png" or "ico". 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The location to receive a pointer to the new buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_size</em>&nbsp;</td><td>The location to receive the size of the new buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The name of file format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option_keys</em>&nbsp;</td><td>The name of options to set, null-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option_values</em>&nbsp;</td><td>The values for the named <em>options</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for any error, or null. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cd5cabc67b92f57d7cd948dcc4018f35"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::add_alpha" ref="cd5cabc67b92f57d7cd948dcc4018f35" args="(bool substitute_color, unsigned char red, unsigned char green, unsigned char blue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::add_alpha           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>substitute_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an alpha channel to this pixbuf and returns the result as a new pixbuf. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>substitute_color</em>&nbsp;</td><td>Whether to set a color to zero opacity. If this is false, then the (r, g, b) arguments will be ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>red</em>&nbsp;</td><td>The red value to substitute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>green</em>&nbsp;</td><td>The green value to substitute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blue</em>&nbsp;</td><td>the blue value to substitute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A newly-created pixbuf.</dd></dl>
If the existing pixbuf already had an alpha channel, the channel values are copied from the original; otherwise, the alpha channel is initialized to 255 (full opacity). If substitute_color is true, then the color specified by (r, g, b) will be assigned zero opacity. That is, if you pass (255, 255, 255) for the substitute color, all white pixels will become fully transparent. 
</div>
</div><p>
<a class="anchor" name="6761994ad48e64d84ff8cb7c642b54bf"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::copy_area" ref="6761994ad48e64d84ff8cb7c642b54bf" args="(const Pixbuf &amp;src, int src_x, int src_y, int width, int height, int dest_x, int dest_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::copy_area           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies a rectangular area from <em>src</em> to this pixbuf; conversion of pixbuf formats is done automatically. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_x</em>&nbsp;</td><td>The source X coordinate within <em>src</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_y</em>&nbsp;</td><td>The source Y coordinate within <em>src</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of the area to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of the area to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_x</em>&nbsp;</td><td>The destination X coordinate within this pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_y</em>&nbsp;</td><td>The destination Y coordinate within this pixbuf. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="35b31661976aa2c6d74c9b64ea0e2e98"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::copy_area" ref="35b31661976aa2c6d74c9b64ea0e2e98" args="(const Pixbuf &amp;src, const Rectangle &amp;src_rect, int dest_x, int dest_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::copy_area           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies a rectangular area from <em>src</em> to this pixbuf; conversion of pixbuf formats is done automatically. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_rect</em>&nbsp;</td><td>The rectangular area within <em>src</em> to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_x</em>&nbsp;</td><td>The destination X coordinate within this pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_y</em>&nbsp;</td><td>The destination Y coordinate within this pixbuf. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9ea0ce7b23540ada8a6801437ad95b7a"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::saturate_and_pixelate" ref="9ea0ce7b23540ada8a6801437ad95b7a" args="(const Pixbuf &amp;src, float saturation, bool pixelate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::saturate_and_pixelate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>saturation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pixelate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modifies saturation and optionally pixelates <em>src</em>, placing the result this pixbuf. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>saturation</em>&nbsp;</td><td>The saturation factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelate</em>&nbsp;</td><td>Whether to pixelate.</td></tr>
  </table>
</dl>
If saturation is 1.0 then saturation is not changed. If it's less than 1.0, saturation is reduced (the image is darkened); if greater than 1.0, saturation is increased (the image is brightened). If pixelate is true, then pixels are faded in a checkerboard pattern to create a pixelated image. This pixbuf and <em>src</em> must have the same image format, size, and rowstride. 
</div>
</div><p>
<a class="anchor" name="5f8bc787e45b5d50dfae1592e3f72a0f"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::saturate_and_pixelate" ref="5f8bc787e45b5d50dfae1592e3f72a0f" args="(float saturation, bool pixelate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::saturate_and_pixelate           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>saturation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pixelate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modifies saturation and optionally pixelates the pixbuf. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>saturation</em>&nbsp;</td><td>The saturation factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelate</em>&nbsp;</td><td>Whether to pixelate.</td></tr>
  </table>
</dl>
If saturation is 1.0 then saturation is not changed. If it's less than 1.0, saturation is reduced (the image is darkened); if greater than 1.0, saturation is increased (the image is brightened). If pixelate is true, then pixels are faded in a checkerboard pattern to create a pixelated image. This pixbuf and <em>src</em> must have the same image format, size, and rowstride. 
</div>
</div><p>
<a class="anchor" name="209f0d7b871cba385bd044dcbd0db48c"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::scale_simple" ref="209f0d7b871cba385bd044dcbd0db48c" args="(int width, int height, InterpType interp_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::scale_simple           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a>&nbsp;</td>
          <td class="paramname"> <em>interp_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new pixbuf containing a copy of this pixbuf scaled to width x height. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of destination image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of destination image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interp_type</em>&nbsp;</td><td>The interpolation type for the transformation. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the new pixbuf, or null if not enough memory could be allocated for it.</dd></dl>
Leaves this pixbuf unaffected. interp_type should be <a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c34621427473032c0e9bf6be082ea14a41">Gdk::INTERP_NEAREST</a> if you want maximum speed (but when scaling down, <a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c34621427473032c0e9bf6be082ea14a41">Gdk::INTERP_NEAREST</a> is usually unusably ugly). The default interp_type should be <a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3993a3ecdf046f6d0a4d0cae938b78a7f">Gdk::INTERP_BILINEAR</a> which offers reasonable quality and speed. You can scale a sub-portion of this pixbuf by constructing a sub-pixbuf pointing into this pixbuf.<p>
For more complicated scaling/compositing see <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#b59a5a2ef72431e1563f4b4c23563022">scale()</a> and <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#6c9a709e03e9373d57713d24fe832596">composite()</a>. 
</div>
</div><p>
<a class="anchor" name="b59a5a2ef72431e1563f4b4c23563022"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::scale" ref="b59a5a2ef72431e1563f4b4c23563022" args="(const Pixbuf &amp;src, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, InterpType interp_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::scale           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a>&nbsp;</td>
          <td class="paramname"> <em>interp_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then renders the rectangle (dest_x, dest_y, dest_width, dest_height) of the resulting image onto the destination image replacing the previous contents. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_x</em>&nbsp;</td><td>The left coordinate for the region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_y</em>&nbsp;</td><td>The top coordinate for the region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_width</em>&nbsp;</td><td>The width of the region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_height</em>&nbsp;</td><td>The height of the region to render </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_x</em>&nbsp;</td><td>The offset in the X direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_y</em>&nbsp;</td><td>The offset in the Y direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_x</em>&nbsp;</td><td>The scale factor in the X direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_y</em>&nbsp;</td><td>The scale factor in the Y direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interp_type</em>&nbsp;</td><td>The interpolation type for the transformation.</td></tr>
  </table>
</dl>
Try to use <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#209f0d7b871cba385bd044dcbd0db48c">scale_simple()</a> first, this method is the industrial-strength power tool you can fall back to if <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#209f0d7b871cba385bd044dcbd0db48c">scale_simple()</a> isn't powerful enough. 
</div>
</div><p>
<a class="anchor" name="e502f0589eb18e7d565292aa0593bfd7"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::scale" ref="e502f0589eb18e7d565292aa0593bfd7" args="(const Pixbuf &amp;src, const Rectangle &amp;dest_rect, double offset_x, double offset_y, double scale_x, double scale_y, InterpType interp_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::scale           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a>&nbsp;</td>
          <td class="paramname"> <em>interp_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then renders the rectangle <em>dest_rect</em> of the resulting image onto the destination image replacing the previous contents. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_rect</em>&nbsp;</td><td>The rectangular region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_x</em>&nbsp;</td><td>The offset in the X direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_y</em>&nbsp;</td><td>The offset in the Y direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_x</em>&nbsp;</td><td>The scale factor in the X direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_y</em>&nbsp;</td><td>The scale factor in the Y direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interp_type</em>&nbsp;</td><td>The interpolation type for the transformation.</td></tr>
  </table>
</dl>
Try to use <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#209f0d7b871cba385bd044dcbd0db48c">scale_simple()</a> first, this method is the industrial-strength power tool you can fall back to if <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#209f0d7b871cba385bd044dcbd0db48c">scale_simple()</a> isn't powerful enough. 
</div>
</div><p>
<a class="anchor" name="e9f8f49037bc1438f84e03979bbe0f9d"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::composite_color_simple" ref="e9f8f49037bc1438f84e03979bbe0f9d" args="(int width, int height, InterpType interp_type, int overall_alpha, int check_size, unsigned int color1, unsigned int color2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::composite_color_simple           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a>&nbsp;</td>
          <td class="paramname"> <em>interp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>overall_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>check_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>color1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>color2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new pixbuf by scaling this pixbuf to <em>width</em> x <em>height</em> and compositing the result with a checkboard of colors <em>color1</em> and <em>color2</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of new image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of new image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interp_type</em>&nbsp;</td><td>The interpolation type for the transformation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overall_alpha</em>&nbsp;</td><td>The overall alpha for this (source) pixbuf (0..255). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check_size</em>&nbsp;</td><td>The size of checks in the checkboard (must be a power of two). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color1</em>&nbsp;</td><td>The color of check at upper left. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color2</em>&nbsp;</td><td>The color of the other check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the new pixbuf, or null if not enough memory could be allocated for it. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c9a709e03e9373d57713d24fe832596"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::composite" ref="6c9a709e03e9373d57713d24fe832596" args="(const Pixbuf &amp;src, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, InterpType interp_type, int overall_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::composite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a>&nbsp;</td>
          <td class="paramname"> <em>interp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>overall_alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then composites the rectangle (dest_x, dest_y, dest_width, dest_height) of the resulting image onto the destination image. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_x</em>&nbsp;</td><td>The left coordinate for the region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_y</em>&nbsp;</td><td>The top coordinate for the region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_width</em>&nbsp;</td><td>The width of the region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_height</em>&nbsp;</td><td>The height of the region to render </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_x</em>&nbsp;</td><td>The offset in the X direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_y</em>&nbsp;</td><td>The offset in the Y direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_x</em>&nbsp;</td><td>The scale factor in the X direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_y</em>&nbsp;</td><td>The scale factor in the Y direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interp_type</em>&nbsp;</td><td>The interpolation type for the transformation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overall_alpha</em>&nbsp;</td><td>The overall alpha for source image (0..255). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="86db49df03db32bb548d0b44d59b4873"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::composite" ref="86db49df03db32bb548d0b44d59b4873" args="(const Pixbuf &amp;src, const Rectangle &amp;dest_rect, double offset_x, double offset_y, double scale_x, double scale_y, InterpType interp_type, int overall_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::composite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a>&nbsp;</td>
          <td class="paramname"> <em>interp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>overall_alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then composites the rectangle <em>dest_rect</em> of the resulting image onto the destination image. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_rect</em>&nbsp;</td><td>The rectangular region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_x</em>&nbsp;</td><td>The offset in the X direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_y</em>&nbsp;</td><td>The offset in the Y direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_x</em>&nbsp;</td><td>The scale factor in the X direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_y</em>&nbsp;</td><td>The scale factor in the Y direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interp_type</em>&nbsp;</td><td>The interpolation type for the transformation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overall_alpha</em>&nbsp;</td><td>The overall alpha for source image (0..255). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b927ccc3c7e3a45ec29909e4e58f783b"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::composite_color" ref="b927ccc3c7e3a45ec29909e4e58f783b" args="(const Pixbuf &amp;src, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, InterpType interp_type, int overall_alpha, int check_x, int check_y, int check_size, unsigned int color1, unsigned int color2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::composite_color           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a>&nbsp;</td>
          <td class="paramname"> <em>interp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>overall_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>check_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>check_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>check_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>color1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>color2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then composites the rectangle (dest_x, dest_y, dest_width, dest_height) of the resulting image with a checkboard of the colors <em>color1</em> and <em>color2</em> and renders it onto the destination image. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_x</em>&nbsp;</td><td>The left coordinate for the region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_y</em>&nbsp;</td><td>The top coordinate for the region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_width</em>&nbsp;</td><td>The width of the region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_height</em>&nbsp;</td><td>The height of the region to render </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_x</em>&nbsp;</td><td>The offset in the X direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_y</em>&nbsp;</td><td>The offset in the Y direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_x</em>&nbsp;</td><td>The scale factor in the X direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_y</em>&nbsp;</td><td>The scale factor in the Y direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interp_type</em>&nbsp;</td><td>The interpolation type for the transformation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overall_alpha</em>&nbsp;</td><td>The overall alpha for source image (0..255). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check_x</em>&nbsp;</td><td>The X offset for the checkboard (origin of checkboard is at -check_x, -check_y). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check_y</em>&nbsp;</td><td>The Y offset for the checkboard. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check_size</em>&nbsp;</td><td>The size of checks in the checkboard (must be a power of two). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color1</em>&nbsp;</td><td>The color of check at upper left. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color2</em>&nbsp;</td><td>The color of the other check.</td></tr>
  </table>
</dl>
See <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#e9f8f49037bc1438f84e03979bbe0f9d">composite_color_simple()</a> for a simpler variant of this method suitable for many tasks. 
</div>
</div><p>
<a class="anchor" name="c3c9e1c6ae8fff4d63d8d4d8e40f01cc"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::composite_color" ref="c3c9e1c6ae8fff4d63d8d4d8e40f01cc" args="(const Pixbuf &amp;src, const Rectangle &amp;dest_rect, double offset_x, double offset_y, double scale_x, double scale_y, InterpType interp_type, int overall_alpha, const Point &amp;check_offset, int check_size, unsigned int color1, unsigned int color2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::composite_color           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#acc0f1101f7f7ce39dd28a13d0f821c3">InterpType</a>&nbsp;</td>
          <td class="paramname"> <em>interp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>overall_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>check_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>check_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>color1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>color2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a transformation of the source image <em>src</em> by scaling by <em>scale_x</em> and <em>scale_y</em> then translating by <em>offset_x</em> and <em>offset_y</em>, then composites the rectangle <em>dest_rect</em> of the resulting image with a checkboard of the colors <em>color1</em> and <em>color2</em> and renders it onto the destination image. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_rect</em>&nbsp;</td><td>The rectangular region to render. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_x</em>&nbsp;</td><td>The offset in the X direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_y</em>&nbsp;</td><td>The offset in the Y direction (currently rounded to an integer). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_x</em>&nbsp;</td><td>The scale factor in the X direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_y</em>&nbsp;</td><td>The scale factor in the Y direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interp_type</em>&nbsp;</td><td>The interpolation type for the transformation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overall_alpha</em>&nbsp;</td><td>The overall alpha for source image (0..255). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check_offset</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> holding the x, y offset for the checkboard (origin of the checkboard is at -check_offset.x, -check_offset.y). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check_size</em>&nbsp;</td><td>The size of checks in the checkboard (must be a power of two). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color1</em>&nbsp;</td><td>The color of check at upper left. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color2</em>&nbsp;</td><td>The color of the other check.</td></tr>
  </table>
</dl>
See <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#e9f8f49037bc1438f84e03979bbe0f9d">composite_color_simple()</a> for a simpler variant of this method suitable for many tasks. 
</div>
</div><p>
<a class="anchor" name="6e582932d5e25d092b9efc91255fa7eb"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::rotate_simple" ref="6e582932d5e25d092b9efc91255fa7eb" args="(PixbufRotation angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::rotate_simple           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#870f127241c38f7f4ad019608c1770ac">PixbufRotation</a>&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotates a the pixbuf by a multiple of 90 degrees, and returns the result in a new pixbuf. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>The angle to rotate by. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new pixbuf. </dd></dl>

</div>
</div><p>
<a class="anchor" name="089b81e0931952523e58aa12b5459db1"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::flip" ref="089b81e0931952523e58aa12b5459db1" args="(bool horizontal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::Pixbuf::flip           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>horizontal</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flips the pixbuf horizontally or vertically and returns the result in a new pixbuf. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>horizontal</em>&nbsp;</td><td>Set to <em>true</em> to flip horizontally, <em>false</em> to flip vertically. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new pixbuf. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6aabc3b00a95e6cd269711d58990683a"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::render_threshold_alpha" ref="6aabc3b00a95e6cd269711d58990683a" args="(Bitmap &amp;bitmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height, int alpha_threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::render_threshold_alpha           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Bitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>alpha_threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Takes the opacity values in a rectangular portion of the pixbuf and thresholds them to produce a bi-level alpha mask that can be used as a clipping mask for a drawable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bitmap</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Bitmap</a> where the bilevel mask will be painted to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_x</em>&nbsp;</td><td>The source X coordinate within the pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_y</em>&nbsp;</td><td>The source Y coordinate within the pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_x</em>&nbsp;</td><td>The destination X coordinate within the bitmap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_y</em>&nbsp;</td><td>The destination Y coordinate within the bitmap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of the region to threshold, or -1 to use the pixbuf width. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of the region to threshold, or -1 to use the pixbuf height. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha_threshold</em>&nbsp;</td><td>Opacity values below this will be painted as zero; all other values will be painted as one. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b176645cc3bb3c1bc08f143c959fed64"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::render_pixmap_and_mask" ref="b176645cc3bb3c1bc08f143c959fed64" args="(Pointer&lt; Pixmap &gt; *pixmap_return, Pointer&lt; Bitmap &gt; *mask_return, int alpha_threshold, Colormap *colormap=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Pixbuf::render_pixmap_and_mask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixmap.html">Pixmap</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>pixmap_return</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Bitmap</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>mask_return</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>alpha_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a> *&nbsp;</td>
          <td class="paramname"> <em>colormap</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a pixmap and a mask bitmap which are returned in the pixmap_return and mask_return arguments, respectively, and renders a pixbuf and its corresponding thresholded alpha mask to them. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixmap_return</em>&nbsp;</td><td>The location to store a pointer to the created pixmap, or null if the pixmap is not needed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask_return</em>&nbsp;</td><td>The location to store a pointer to the created mask, or null if the mask is not needed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha_threshold</em>&nbsp;</td><td>The threshold value for opacity values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colormap</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a>, or null to use the colormap returned by gdk_rgb_get_colormap().</td></tr>
  </table>
</dl>
This is merely a convenience method; applications that need to render pixbufs with dither offsets or to given drawables should use <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#6aabc3b00a95e6cd269711d58990683a">render_threshold_alpha()</a> or <a class="el" href="classXfc_1_1Gdk_1_1Drawable.html#5009821c8e0f9ee8a944f4aa93422649">Gdk::Drawable::draw_pixbuf()</a>.<p>
If <em>colormap</em> is null the pixmap is created with the <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a> returned by gdk_rgb_get_colormap(). Normally you will want to use the actual colormap for a widget instead. If the pixbuf does not have an alpha channel, then mask_return will be set to null. 
</div>
</div><p>
<a class="anchor" name="4c69d0c63891d0361ed9855f2a9ee171"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::get_from_drawable" ref="4c69d0c63891d0361ed9855f2a9ee171" args="(const Drawable &amp;src, int src_x, int src_y, int dest_x, int dest_y, int width, int height, Colormap *colormap=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Pixbuf::get_from_drawable           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Drawable.html">Drawable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a> *&nbsp;</td>
          <td class="paramname"> <em>colormap</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transfers (copies) image data from a server-side drawable to the client-side RGB(A) buffer inside this pixbuf. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source drawable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_x</em>&nbsp;</td><td>The source X coordinate within the <em>src</em> drawable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_y</em>&nbsp;</td><td>The source Y coordinate within the <em>src</em> drawable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_x</em>&nbsp;</td><td>The destination X coordinate in this pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_y</em>&nbsp;</td><td>The destination Y coordinate in this pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width in pixels of region to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height in pixels of region to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colormap</em>&nbsp;</td><td>A colormap if <em>src</em> doesn't have one set. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if successful, <em>false</em> if an error occurs.</dd></dl>
This allows you to efficiently read individual pixels on the client side. If the drawable is a pixmap, a colormap must be specified. If the <em>src</em> drawable src has no colormap (Gdk::drawable::get_colormap() returns null), then a suitable colormap must be specified. Typically a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> or a pixmap created from a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> will already have a colormap associated with it. If the drawable has a colormap, the <em>colormap</em> argument will be ignored. If the drawable is a bitmap (1 bit per pixel pixmap), then a colormap is not required; pixels with a value of 1 are assumed to be white, and pixels with a value of 0 are assumed to be black. For taking screenshots, <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html#38b4b4f355e8175b06ba995f2a2a7552">Gdk::Colormap::get_system()</a> returns the correct colormap to use. If this pixbuf contains alpha information, then the filled pixels will be set to full opacity (alpha = 255).<p>
If the specified drawable is a pixmap, then the requested source rectangle must be completely contained within the pixmap, otherwise the method will return false. For pixmaps only (not for windows) passing -1 for width or height is allowed to mean the full width or height of the pixmap.<p>
If the specified drawable is a window, and the window is off the screen, then there is no image data in the obscured/offscreen regions to be placed in the pixbuf. The contents of portions of the pixbuf corresponding to the offscreen region are undefined. If the window you're obtaining data from is partially obscured by other windows, then the contents of the pixbuf areas corresponding to the obscured regions are undefined.<p>
If the target drawable is not mapped (typically because it's iconified/minimized or not on the current workspace), then false will be returned. If memory can't be allocated for the return value, false will be returned instead.<p>
<b>Note:</b> There are several ways this method can fail, and if it fails it returns false; so check the return value.<p>
This method calls <a class="el" href="classXfc_1_1Gdk_1_1Drawable.html#1b8db21fcb094db275bdca8b76f5a479">Gdk::Drawable::get_image()</a> internally and converts the resulting image to a <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a>, so the documentation for <a class="el" href="classXfc_1_1Gdk_1_1Drawable.html#1b8db21fcb094db275bdca8b76f5a479">Gdk::Drawable::get_image()</a> may also be relevant. 
</div>
</div><p>
<a class="anchor" name="a3744d86228dfac0f3b46b67f2fdca22"></a><!-- doxytag: member="Xfc::Gdk::Pixbuf::get_from_image" ref="a3744d86228dfac0f3b46b67f2fdca22" args="(const Image &amp;src, int src_x, int src_y, int dest_x, int dest_y, int width, int height, Colormap *colormap=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Pixbuf::get_from_image           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Colormap</a> *&nbsp;</td>
          <td class="paramname"> <em>colormap</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies image data from an <a class="el" href="classXfc_1_1Gdk_1_1Image.html">Image</a> to this pixbuf (see <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html#4c69d0c63891d0361ed9855f2a9ee171">get_from_drawable()</a> for details). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_x</em>&nbsp;</td><td>The source X coordinate within the <em>src</em> image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_y</em>&nbsp;</td><td>The source Y coordinate within the <em>src</em> image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_x</em>&nbsp;</td><td>The destination X coordinate within this pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_y</em>&nbsp;</td><td>The destination Y coordinate within this pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width in pixels of region to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height in pixels of region to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colormap</em>&nbsp;</td><td>A colormap if <em>src</em> doesn't have one set. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if successful, <em>false</em> if an error occurs. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="pixbuf_8hh.html">pixbuf.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
