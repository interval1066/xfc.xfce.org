<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1Gdk.html">Gdk</a>::<a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html">PixbufLoader</a></div>
<h1>Xfc::Gdk::PixbufLoader Class Reference</h1><!-- doxytag: class="Xfc::Gdk::PixbufLoader" --><!-- doxytag: inherits="Xfc::G::Object" -->A GdkPixbufLoader C++ wrapper class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/gdk-pixbuf/pixbuf-loader.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::Gdk::PixbufLoader:
<p><center><img src="classXfc_1_1Gdk_1_1PixbufLoader.png" usemap="#Xfc::Gdk::PixbufLoader_map" border="0" alt=""></center>
<map name="Xfc::Gdk::PixbufLoader_map">
<area href="classXfc_1_1G_1_1Object.html" alt="Xfc::G::Object" shape="rect" coords="0,112,141,136">
<area href="classXfc_1_1G_1_1TypeInstance.html" alt="Xfc::G::TypeInstance" shape="rect" coords="0,56,141,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,141,24">
</map>
<a href="classXfc_1_1Gdk_1_1PixbufLoader-members.html">List of all members.</a><h2>Signal Prototypes</h2>
<ul>
<li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">SizePreparedSignalType</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#f8f5fed9e6058d497c870a30f993294c">size_prepared_signal</a>
<dl class="el"><dd class="mdescRight">Size prepared signal (see <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#80a294e9f494c2f61b624296e96d9b6b">signal_size_prepared()</a>).  <a href="#f8f5fed9e6058d497c870a30f993294c"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">AreaPreparedSignalType</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#55aab3a1e0544e3201343008d7d40f45">area_prepared_signal</a>
<dl class="el"><dd class="mdescRight">Area prepared signal (see <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#7d6128a1845735d7c9c5d83f1a43c5aa">signal_area_prepared()</a>).  <a href="#55aab3a1e0544e3201343008d7d40f45"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">AreaUpdatedSignalType</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#b054d38b247e0b185ab7c191e7e489b3">area_updated_signal</a>
<dl class="el"><dd class="mdescRight">Area updated signal (see <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e86d0eb107a22b97faa371c6e08989f2">signal_area_updated()</a>).  <a href="#b054d38b247e0b185ab7c191e7e489b3"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ClosedSignalType</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#707adb76bfc573727de9c749e05fe3d5">closed_signal</a>
<dl class="el"><dd class="mdescRight">Closed signal (see <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#2d7acab9ff447374e8a4edf91f981c4d">signal_closed()</a>).  <a href="#707adb76bfc573727de9c749e05fe3d5"></a><br></dl></ul>
<h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="a9e1709d3d710e4532b9f54e00d1ecbb"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::gdk_pixbuf_loader" ref="a9e1709d3d710e4532b9f54e00d1ecbb" args="() const" -->
GdkPixbufLoader * <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#a9e1709d3d710e4532b9f54e00d1ecbb">gdk_pixbuf_loader</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GdkPixbufLoader structure. <br></dl><li><a class="anchor" name="619669ca48900e7cbacc2ba1c95cf215"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::operator GdkPixbufLoader *" ref="619669ca48900e7cbacc2ba1c95cf215" args="() const" -->
<a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#619669ca48900e7cbacc2ba1c95cf215">operator GdkPixbufLoader *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; safely converts a <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html">PixbufLoader</a> to a GdkPixbufLoader pointer. <br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e2ec59b78274ec9445dbf7cbd8c9637f">get_pixbuf</a> () const
<dl class="el"><dd class="mdescRight">Queries the <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> that the pixbuf loader is currently creating.  <a href="#e2ec59b78274ec9445dbf7cbd8c9637f"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1PixbufAnimation.html">PixbufAnimation</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e9ab4ec80daa2406c118ddf8eb3fb362">get_animation</a> () const
<dl class="el"><dd class="mdescRight">Queries the <a class="el" href="classXfc_1_1Gdk_1_1PixbufAnimation.html">PixbufAnimation</a> that the pixbuf loader is currently creating.  <a href="#e9ab4ec80daa2406c118ddf8eb3fb362"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1PixbufFormat.html">PixbufFormat</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e96a60ec763358ad06b0aaa1c46e781f">get_format</a> () const
<dl class="el"><dd class="mdescRight">Obtains the available information about the format of the currently loading image file.  <a href="#e96a60ec763358ad06b0aaa1c46e781f"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#8877b334187224dcd1519c9e9368eba8">set_size</a> (int width, int height)
<dl class="el"><dd class="mdescRight">Causes the image to be scaled while it is loaded.  <a href="#8877b334187224dcd1519c9e9368eba8"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#accbe1d76db49abac4b8603d69be37e4">write</a> (const unsigned char *buffer, size_t count, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error)
<dl class="el"><dd class="mdescRight">This method will cause a pixbuf loader to parse the next count bytes of an image.  <a href="#accbe1d76db49abac4b8603d69be37e4"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e06d39fec62b7f14369776d960ae1aa0">close</a> (<a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Informs a pixbuf loader that no further writes with <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#accbe1d76db49abac4b8603d69be37e4">write()</a> will occur, so that it can free its internal loading structures.  <a href="#e06d39fec62b7f14369776d960ae1aa0"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Signal Proxies</div></td></tr>
<ul>
<li><a class="anchor" name="80a294e9f494c2f61b624296e96d9b6b"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::signal_size_prepared" ref="80a294e9f494c2f61b624296e96d9b6b" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SizePreparedSignalProxy</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#80a294e9f494c2f61b624296e96d9b6b">signal_size_prepared</a> ()
<dl class="el"><dd class="mdescRight">Connect to the size_prepared_signal; emitted when the pixbuf loader has been fed the initial amount of data that is required to figure out the size of the image that it will create. <br></dl><li><a class="anchor" name="7d6128a1845735d7c9c5d83f1a43c5aa"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::signal_area_prepared" ref="7d6128a1845735d7c9c5d83f1a43c5aa" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">AreaPreparedSignalProxy</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#7d6128a1845735d7c9c5d83f1a43c5aa">signal_area_prepared</a> ()
<dl class="el"><dd class="mdescRight">Connect to the area_prepared_signal; emitted when the pixbuf loader has allocated the pixbuf in the desired size. <br></dl><li><a class="anchor" name="e86d0eb107a22b97faa371c6e08989f2"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::signal_area_updated" ref="e86d0eb107a22b97faa371c6e08989f2" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">AreaUpdatedSignalProxy</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e86d0eb107a22b97faa371c6e08989f2">signal_area_updated</a> ()
<dl class="el"><dd class="mdescRight">Connect to the area_updated_signal; emitted when a significant area of the image being loaded has been updated. <br></dl><li><a class="anchor" name="2d7acab9ff447374e8a4edf91f981c4d"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::signal_closed" ref="2d7acab9ff447374e8a4edf91f981c4d" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ClosedSignalProxy</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#2d7acab9ff447374e8a4edf91f981c4d">signal_closed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the closed_signal; emitted when <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e06d39fec62b7f14369776d960ae1aa0">close()</a> is called. <br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html">PixbufLoader</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e77a1f4818508e59e69cd9b8ac2060c4">create_with_type</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;image_type, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Creates a new pixbuf loader object that always attempts to parse image data as if it were an image of type image_type, instead of identifying the type automatically.  <a href="#e77a1f4818508e59e69cd9b8ac2060c4"></a><br></dl><li>static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html">PixbufLoader</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#2663bbc1460bd555137ec92306edcdd0">create_with_mime_type</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;mime_type, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Creates a new pixbuf loader object that always attempts to parse image data as if it were an image of mime type <em>mime_type</em>, instead of identifying the type automatically.  <a href="#2663bbc1460bd555137ec92306edcdd0"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GdkPixbufLoader C++ wrapper class. 
<p>
<a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html">PixbufLoader</a> provides a way for applications to drive the process of loading an image, by letting them send the image data directly to the loader instead of having the loader read the data from a file. Applications can use this functionality instead of constructing a <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> or a <a class="el" href="classXfc_1_1Gdk_1_1PixbufAnimation.html">PixbufAnimation</a> directly from a file when they need to parse image data in small chunks. For example, it should be used when reading an image from a (potentially) slow network connection, or when loading an extremely large file.<p>
To use <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html">PixbufLoader</a> to load an image, just construct a new one, and call <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#accbe1d76db49abac4b8603d69be37e4">write()</a> to send the data to it. When done, <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e06d39fec62b7f14369776d960ae1aa0">close()</a> should be called to end the stream and finalize everything. The loader will emit three important signals throughout the process. The first, <em>size_prepared</em>, will be called as soon as the image has enough information to determine the size of the image to be used. If you want to scale the image while loading it, you can call <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#8877b334187224dcd1519c9e9368eba8">set_size()</a> in response to this signal.<p>
The second signal, <em>area_prepared</em>, will be called as soon as the pixbuf of the desired size has been allocated. You can obtain it by calling <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e2ec59b78274ec9445dbf7cbd8c9637f">get_pixbuf()</a>. If you want to use it, simply <a class="el" href="classXfc_1_1G_1_1Object.html#47f87a1180f4950eba164d60aa281283">ref()</a> it. In addition, no actual information will be passed in yet, so the pixbuf can be safely filled with any temporary graphics (or an initial color) as needed. You can also call <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e2ec59b78274ec9445dbf7cbd8c9637f">get_pixbuf()</a> later and get the same pixbuf.<p>
The last signal, <em>area_updated</em> gets called every time a region is updated. This way you can update a partially completed image. Note that you do not know anything about the completeness of an image from the area updated. For example, in an interlaced image, you need to make several passes before the image is done loading.<p>
Loading an animation is almost as easy as loading an image. Once the first <em>area_prepared</em> signal has been emitted, you can call <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e9ab4ec80daa2406c118ddf8eb3fb362">get_animation()</a> to get the <a class="el" href="classXfc_1_1Gdk_1_1PixbufAnimation.html">PixbufAnimation</a> object and get_iter() to get an <a class="el" href="classXfc_1_1Gdk_1_1PixbufAnimationIter.html">PixbufAnimationIter</a> for displaying it.<p>
Note: <em>dynamically allocated objects must either be unreferenced or assigned to a smart pointer. Stack objects are automatically unreferenced when they go out of scope.</em> 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="d41a758aba803f525f9ea4dc5732ccd3"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::PixbufLoader" ref="d41a758aba803f525f9ea4dc5732ccd3" args="(GdkPixbufLoader *pixbuf_loader, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::PixbufLoader::PixbufLoader           </td>
          <td>(</td>
          <td class="paramtype">GdkPixbufLoader *&nbsp;</td>
          <td class="paramname"> <em>pixbuf_loader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html">PixbufLoader</a> from an existing GdkPixbufLoader. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixbuf_loader</em>&nbsp;</td><td>A pointer to a GdkPixbufLoader. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>pixbuf_loader</em> can be a newly created GdkPixbufLoader or an existing GdkPixbufLoader. (see G::Object::Object). 
</div>
</div><p>
<a class="anchor" name="d41a758aba803f525f9ea4dc5732ccd3"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::PixbufLoader" ref="d41a758aba803f525f9ea4dc5732ccd3" args="(GdkPixbufLoader *pixbuf_loader, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::PixbufLoader::PixbufLoader           </td>
          <td>(</td>
          <td class="paramtype">GdkPixbufLoader *&nbsp;</td>
          <td class="paramname"> <em>pixbuf_loader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html">PixbufLoader</a> from an existing GdkPixbufLoader. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixbuf_loader</em>&nbsp;</td><td>A pointer to a GdkPixbufLoader. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>pixbuf_loader</em> can be a newly created GdkPixbufLoader or an existing GdkPixbufLoader. (see G::Object::Object). 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e77a1f4818508e59e69cd9b8ac2060c4"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::create_with_type" ref="e77a1f4818508e59e69cd9b8ac2060c4" args="(const String &amp;image_type, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html">PixbufLoader</a>&gt; Xfc::Gdk::PixbufLoader::create_with_type           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>image_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new pixbuf loader object that always attempts to parse image data as if it were an image of type image_type, instead of identifying the type automatically. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image_type</em>&nbsp;</td><td>The name of the image format to be loaded with the image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for an allocated <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A newly-created pixbuf loader, or null if any error occurs.</dd></dl>
Useful if you want an error if the image isn't the expected type, for loading image formats that can't be reliably identified by looking at the data, or if the user manually forces a specific type. The <em>image_type</em> can be png, jpeg, tiff, gif, xpm, pnm, ras, ico, bmp or wbmp. 
</div>
</div><p>
<a class="anchor" name="2663bbc1460bd555137ec92306edcdd0"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::create_with_mime_type" ref="2663bbc1460bd555137ec92306edcdd0" args="(const String &amp;mime_type, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html">PixbufLoader</a>&gt; Xfc::Gdk::PixbufLoader::create_with_mime_type           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mime_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new pixbuf loader object that always attempts to parse image data as if it were an image of mime type <em>mime_type</em>, instead of identifying the type automatically. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mime_type</em>&nbsp;</td><td>The mime type to be loaded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for an allocated <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A newly-created pixbuf loader, or null if any error occurs.</dd></dl>
This is useful if you want an error if the image isn't the expected mime type, for loading image formats that can't be reliably identified by looking at the data, or if the user manually forces a specific mime type. 
</div>
</div><p>
<a class="anchor" name="e2ec59b78274ec9445dbf7cbd8c9637f"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::get_pixbuf" ref="e2ec59b78274ec9445dbf7cbd8c9637f" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a>&gt; Xfc::Gdk::PixbufLoader::get_pixbuf           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queries the <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> that the pixbuf loader is currently creating. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the new <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> the loader is creating, or null if not enough data has been read to determine how to create the image buffer.</dd></dl>
In general it only makes sense to call this function after the <em>area_prepared</em> signal has been emitted by the loader; this means that enough data has been read to know the size of the image that will be allocated. If the loader has not received enough data via <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#accbe1d76db49abac4b8603d69be37e4">write()</a>, then this function returns null. The returned pixbuf will be the same in all future calls to the loader. If the loader is an animation, it will return the "static image" of the animation (see <a class="el" href="classXfc_1_1Gdk_1_1PixbufAnimation.html#4bcbb29c2bb20654c233970f362942b1">Gdk::PixbufAnimation::get_static_image()</a>). 
</div>
</div><p>
<a class="anchor" name="e9ab4ec80daa2406c118ddf8eb3fb362"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::get_animation" ref="e9ab4ec80daa2406c118ddf8eb3fb362" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1PixbufAnimation.html">PixbufAnimation</a>&gt; Xfc::Gdk::PixbufLoader::get_animation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queries the <a class="el" href="classXfc_1_1Gdk_1_1PixbufAnimation.html">PixbufAnimation</a> that the pixbuf loader is currently creating. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the <a class="el" href="classXfc_1_1Gdk_1_1PixbufAnimation.html">PixbufAnimation</a> that the loader is loading, or null if not enough data has been read to determine the information.</dd></dl>
In general it only makes sense to call this function after the <em>area_prepared</em> signal has been emitted by the loader. If the loader doesn't have enough bytes yet (hasn't emitted the area_prepared signal) this method will return null. 
</div>
</div><p>
<a class="anchor" name="e96a60ec763358ad06b0aaa1c46e781f"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::get_format" ref="e96a60ec763358ad06b0aaa1c46e781f" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1PixbufFormat.html">PixbufFormat</a>&gt; Xfc::Gdk::PixbufLoader::get_format           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the available information about the format of the currently loading image file. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the new <a class="el" href="classXfc_1_1Gdk_1_1PixbufFormat.html">PixbufFormat</a>, or null. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8877b334187224dcd1519c9e9368eba8"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::set_size" ref="8877b334187224dcd1519c9e9368eba8" args="(int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::PixbufLoader::set_size           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Causes the image to be scaled while it is loaded. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The desired width of the image being loaded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The desired height of the image being loaded.</td></tr>
  </table>
</dl>
The desired image size can be determined relative to the original size of the image by calling <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#8877b334187224dcd1519c9e9368eba8">set_size()</a> from a signal handler for the <em>size_prepared</em> signal. Attempts to set the desired image size are ignored after the emission of the <em>size_prepared</em> signal. 
</div>
</div><p>
<a class="anchor" name="accbe1d76db49abac4b8603d69be37e4"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::write" ref="accbe1d76db49abac4b8603d69be37e4" args="(const unsigned char *buffer, size_t count, G::Error *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::PixbufLoader::write           </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method will cause a pixbuf loader to parse the next count bytes of an image. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to the image data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The length of <em>buffer</em> in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the data was loaded successfully, <em>false</em> if an error occurred.</dd></dl>
If an error occurs, the loader will be closed, and will not accept further writes. If false is returned, error will be set to an error from the GDK_PIXBUF_ERROR or G_FILE_ERROR domains. 
</div>
</div><p>
<a class="anchor" name="e06d39fec62b7f14369776d960ae1aa0"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::close" ref="e06d39fec62b7f14369776d960ae1aa0" args="(G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::PixbufLoader::close           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Informs a pixbuf loader that no further writes with <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#accbe1d76db49abac4b8603d69be37e4">write()</a> will occur, so that it can free its internal loading structures. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if all image data written so far was successfully passed out via the <em>area_updated</em> signal.</dd></dl>
This method tries to parse any data that hasn't yet been parsed; if the remaining data is partial or corrupt, an error will be returned. If false is returned, error will be set to an error from the GDK_PIXBUF_ERROR or G_FILE_ERROR domains. If you're just cancelling a load rather than expecting it to be finished, passing null for error to ignore it is reasonable. 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="f8f5fed9e6058d497c870a30f993294c"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::size_prepared_signal" ref="f8f5fed9e6058d497c870a30f993294c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">SizePreparedSignalType</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#f8f5fed9e6058d497c870a30f993294c">Xfc::Gdk::PixbufLoader::size_prepared_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size prepared signal (see <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#80a294e9f494c2f61b624296e96d9b6b">signal_size_prepared()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height);
&lt; <span class="comment">// width: The width of the image the pixbuf loader will create.</span>
&lt; <span class="comment">// height: The height of the image the pixbuf loader will create.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="55aab3a1e0544e3201343008d7d40f45"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::area_prepared_signal" ref="55aab3a1e0544e3201343008d7d40f45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">AreaPreparedSignalType</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#55aab3a1e0544e3201343008d7d40f45">Xfc::Gdk::PixbufLoader::area_prepared_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Area prepared signal (see <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#7d6128a1845735d7c9c5d83f1a43c5aa">signal_area_prepared()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="b054d38b247e0b185ab7c191e7e489b3"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::area_updated_signal" ref="b054d38b247e0b185ab7c191e7e489b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">AreaUpdatedSignalType</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#b054d38b247e0b185ab7c191e7e489b3">Xfc::Gdk::PixbufLoader::area_updated_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Area updated signal (see <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#e86d0eb107a22b97faa371c6e08989f2">signal_area_updated()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height);
&lt; <span class="comment">// x: The X coordinate of the updated area.</span>
&lt; <span class="comment">// y: The Y coordinate of the updated area.</span>
&lt; <span class="comment">// width: The width of the updated area.</span>
&lt; <span class="comment">// height: The height of the updated area.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="707adb76bfc573727de9c749e05fe3d5"></a><!-- doxytag: member="Xfc::Gdk::PixbufLoader::closed_signal" ref="707adb76bfc573727de9c749e05fe3d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ClosedSignalType</a> <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#707adb76bfc573727de9c749e05fe3d5">Xfc::Gdk::PixbufLoader::closed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closed signal (see <a class="el" href="classXfc_1_1Gdk_1_1PixbufLoader.html#2d7acab9ff447374e8a4edf91f981c4d">signal_closed()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="pixbuf-loader_8hh.html">pixbuf-loader.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
