<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1Gdk.html">Gdk</a>::<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a></div>
<h1>Xfc::Gdk::Window Class Reference</h1><!-- doxytag: class="Xfc::Gdk::Window" --><!-- doxytag: inherits="Xfc::Gdk::Drawable" -->A GdkWindow C++ wrapper class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/gdk/window.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::Gdk::Window:
<p><center><img src="classXfc_1_1Gdk_1_1Window.png" usemap="#Xfc::Gdk::Window_map" border="0" alt=""></center>
<map name="Xfc::Gdk::Window_map">
<area href="classXfc_1_1Gdk_1_1Drawable.html" alt="Xfc::Gdk::Drawable" shape="rect" coords="0,168,128,192">
<area href="classXfc_1_1G_1_1Object.html" alt="Xfc::G::Object" shape="rect" coords="0,112,128,136">
<area href="classXfc_1_1G_1_1TypeInstance.html" alt="Xfc::G::TypeInstance" shape="rect" coords="0,56,128,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,128,24">
</map>
<a href="classXfc_1_1Gdk_1_1Window-members.html">List of all members.</a><h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="398c0a224268143ff496b242489544c9"></a><!-- doxytag: member="Xfc::Gdk::Window::gdk_window" ref="398c0a224268143ff496b242489544c9" args="() const" -->
GdkWindow * <a class="el" href="classXfc_1_1Gdk_1_1Window.html#398c0a224268143ff496b242489544c9">gdk_window</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GdkWindow structure. <br></dl><li><a class="anchor" name="d94fcbc7935da129970463c269163dca"></a><!-- doxytag: member="Xfc::Gdk::Window::gdk_window_object" ref="d94fcbc7935da129970463c269163dca" args="() const" -->
GdkWindowObject * <a class="el" href="classXfc_1_1Gdk_1_1Window.html#d94fcbc7935da129970463c269163dca">gdk_window_object</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GdkWindowObject structure. <br></dl><li><a class="anchor" name="a4ba0e9cfcd205fbb1fc1237207181a3"></a><!-- doxytag: member="Xfc::Gdk::Window::operator GdkWindow *" ref="a4ba0e9cfcd205fbb1fc1237207181a3" args="() const" -->
<a class="el" href="classXfc_1_1Gdk_1_1Window.html#a4ba0e9cfcd205fbb1fc1237207181a3">operator GdkWindow *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; safely converts an <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> to a GdkWindow pointer. <br></dl><li><a class="anchor" name="cbe588cc06bdd574cbd760d906d61f00"></a><!-- doxytag: member="Xfc::Gdk::Window::get_window_type" ref="cbe588cc06bdd574cbd760d906d61f00" args="() const" -->
<a class="el" href="namespaceXfc_1_1Gdk.html#a8753ba84f83dc5ca296dbd6823780f8">WindowType</a> <a class="el" href="classXfc_1_1Gdk_1_1Window.html#cbe588cc06bdd574cbd760d906d61f00">get_window_type</a> () const
<dl class="el"><dd class="mdescRight">Returns the type of the window (see <a class="el" href="namespaceXfc_1_1Gdk.html#a8753ba84f83dc5ca296dbd6823780f8">Gdk::WindowType</a>). <br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Window.html#efc31999f041eff95f42053d0ef56975">is_visible</a> () const
<dl class="el"><dd class="mdescRight">Gets whether the window has been mapped (with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#f6211ecd7c42c56d4509917a33e9557b">show()</a> or <a class="el" href="classXfc_1_1Gdk_1_1Window.html#7f842debe336cedca26ac9de41f32a12">show_unraised()</a>).  <a href="#efc31999f041eff95f42053d0ef56975"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Window.html#d59a80c5265f23902cbe48407556a356">is_viewable</a> () const
<dl class="el"><dd class="mdescRight">Checks if the window and all ancestors of the window are mapped.  <a href="#d59a80c5265f23902cbe48407556a356"></a><br></dl><li><a class="el" href="namespaceXfc_1_1Gdk.html#471e27156f88a96317d9f464f883bf5f">WindowState</a> <a class="el" href="classXfc_1_1Gdk_1_1Window.html#f3e268b4d3da7a4cb1e31bcbd05278cf">get_state</a> () const
<dl class="el"><dd class="mdescRight">Gets the bitwise OR of the currently active window state flags, from the <a class="el" href="namespaceXfc_1_1Gdk.html#471e27156f88a96317d9f464f883bf5f">Gdk::WindowState</a> enumeration.  <a href="#f3e268b4d3da7a4cb1e31bcbd05278cf"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#e47d2cd5dc5bbb87d913d505e4dafca4">get_user_data</a> (void *&amp;data) const 
<dl class="el"><dd class="mdescRight">Retrieves the user data for window, which is normally the widget that window belongs to (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#ed409014442400b9d19e550ecbddc2e9">set_user_data()</a>).  <a href="#e47d2cd5dc5bbb87d913d505e4dafca4"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#24e0d9980101efef6eb540853f9ba52c">get_geometry</a> (int *x, int *y, int *width, int *height, int *depth) const
<dl class="el"><dd class="mdescRight">Gets the current geometry of the window.  <a href="#24e0d9980101efef6eb540853f9ba52c"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3c64c695dccff5d175fd6b7b52dbc66f">get_geometry</a> (<a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;rectangle, int *depth) const
<dl class="el"><dd class="mdescRight">Gets the current geometry of the window.  <a href="#3c64c695dccff5d175fd6b7b52dbc66f"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#6cbd328c646de49eb69d5e108aa0f897">get_position</a> (int *x, int *y) const
<dl class="el"><dd class="mdescRight">Obtains the position of the window as reported in the most-recently-processed <a class="el" href="classXfc_1_1Gdk_1_1EventConfigure.html">Gdk::EventConfigure</a>.  <a href="#6cbd328c646de49eb69d5e108aa0f897"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> <a class="el" href="classXfc_1_1Gdk_1_1Window.html#af11f154c3dba99a06735fe0f233ba5c">get_position</a> () const
<dl class="el"><dd class="mdescRight">Obtains the position of the window as reported in the most-recently-processed <a class="el" href="classXfc_1_1Gdk_1_1EventConfigure.html">Gdk::EventConfigure</a> (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#6cbd328c646de49eb69d5e108aa0f897">get_position(int*, int*) const</a>).  <a href="#af11f154c3dba99a06735fe0f233ba5c"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Window.html#9f1b22bf649fef9b8f58225611f5da44">get_origin</a> (int *x, int *y) const
<dl class="el"><dd class="mdescRight">Obtains the position of a window in root window coordinates.  <a href="#9f1b22bf649fef9b8f58225611f5da44"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> <a class="el" href="classXfc_1_1Gdk_1_1Window.html#6fd77c325ba0e5e9a55b4970a472b6f9">get_origin</a> () const
<dl class="el"><dd class="mdescRight">Obtains the position of a window in root window coordinates.  <a href="#6fd77c325ba0e5e9a55b4970a472b6f9"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#dfa11ca456526c4850f2f9a8321a3d69">get_root_origin</a> (int *x, int *y) const
<dl class="el"><dd class="mdescRight">Obtains the top-left corner of the window manager frame in root window coordinates.  <a href="#dfa11ca456526c4850f2f9a8321a3d69"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> <a class="el" href="classXfc_1_1Gdk_1_1Window.html#436b6ffbb2fe25f07add4d5e97194882">get_root_origin</a> () const
<dl class="el"><dd class="mdescRight">Obtains the top-left corner of the window manager frame in root window coordinates.  <a href="#436b6ffbb2fe25f07add4d5e97194882"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> * <a class="el" href="classXfc_1_1Gdk_1_1Window.html#c40f9da9d50c7771a81edfe3b2615bcb">get_pointer</a> (int *x, int *y, <a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">ModifierTypeField</a> *mask) const
<dl class="el"><dd class="mdescRight">Obtains the current pointer position and modifier state.  <a href="#c40f9da9d50c7771a81edfe3b2615bcb"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> * <a class="el" href="classXfc_1_1Gdk_1_1Window.html#15b12c1c02791cce97fa3fffc5c4466a">get_parent</a> () const
<dl class="el"><dd class="mdescRight">Obtains the parent of window, as known to GDK.  <a href="#15b12c1c02791cce97fa3fffc5c4466a"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> * <a class="el" href="classXfc_1_1Gdk_1_1Window.html#441f19242379bd25fb489caa114f23b8">get_toplevel</a> () const
<dl class="el"><dd class="mdescRight">Gets the toplevel window that's an ancestor of the window.  <a href="#441f19242379bd25fb489caa114f23b8"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Window.html#8550e2ab943ad5928652dc8d321e7852">get_children</a> (std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> * &gt; &amp;child_list) const
<dl class="el"><dd class="mdescRight">Gets the list of children of the window known to GDK.  <a href="#8550e2ab943ad5928652dc8d321e7852"></a><br></dl><li><a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">EventMaskField</a> <a class="el" href="classXfc_1_1Gdk_1_1Window.html#c7867c2efc6d1a1fc9e107f80d3bc2ad">get_events</a> () const
<dl class="el"><dd class="mdescRight">Gets the event mask for window (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#7c446d6bac000bfb2e4bcc3bc80552a2">set_events()</a>).  <a href="#c7867c2efc6d1a1fc9e107f80d3bc2ad"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Window.html#c4296368bcc3fbdda2bba16ee92f0ea4">get_decorations</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#87db3b9f39ef0c2d4e996b4dbaed5fdb">WMDecorationField</a> *decorations) const
<dl class="el"><dd class="mdescRight">Gets the group leader window for this window (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#773b296b3ce236c7e349772b832fb8d3">set_group()</a>). Gets the decorations set on the window with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#8a41f0eb92974324b17942b2dae52761">set_decorations()</a>.  <a href="#c4296368bcc3fbdda2bba16ee92f0ea4"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Region.html">Region</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Window.html#287db64dcff1a9c70c5fddd50490f4c2">get_update_area</a> () const
<dl class="el"><dd class="mdescRight">Transfers ownership of the update area from the window to the caller of the method.  <a href="#287db64dcff1a9c70c5fddd50490f4c2"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> <a class="el" href="classXfc_1_1Gdk_1_1Window.html#079411ff10a2a25ff1c0382055733440">get_frame_extents</a> () const
<dl class="el"><dd class="mdescRight">Obtains the bounding box of the window, including window manager titlebar/borders if any.  <a href="#079411ff10a2a25ff1c0382055733440"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#d8f4518a8e5f8f282c430217c865c9bb">get_frame_extents</a> (<a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;rectangle) const 
<dl class="el"><dd class="mdescRight">Obtains the bounding box of the window, including window manager titlebar/borders if any.  <a href="#d8f4518a8e5f8f282c430217c865c9bb"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>virtual void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#72a272b6a99cee4484870642e8a431f7">dispose</a> ()
<dl class="el"><dd class="mdescRight">Destroys the window system resources associated with the window and decrements window's reference count.  <a href="#72a272b6a99cee4484870642e8a431f7"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#f6211ecd7c42c56d4509917a33e9557b">show</a> ()
<dl class="el"><dd class="mdescRight">Like <a class="el" href="classXfc_1_1Gdk_1_1Window.html#7f842debe336cedca26ac9de41f32a12">show_unraised()</a>, but also raises the window to the top of the window stack (moves the window to the front of the Z-order).  <a href="#f6211ecd7c42c56d4509917a33e9557b"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#7f842debe336cedca26ac9de41f32a12">show_unraised</a> ()
<dl class="el"><dd class="mdescRight">Shows a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> onscreen, but does not modify its stacking order.  <a href="#7f842debe336cedca26ac9de41f32a12"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#fe3a90e84b3d11f2c1d18dc8f38cfb25">hide</a> ()
<dl class="el"><dd class="mdescRight">For toplevel windows, withdraws them, so they will no longer be known to the window manager; for all windows, unmaps them, so they won't be displayed.  <a href="#fe3a90e84b3d11f2c1d18dc8f38cfb25"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#e537d074ab4037ab60efa9d376220383">withdraw</a> ()
<dl class="el"><dd class="mdescRight">Withdraws the window (unmaps it and asks the window manager to forget about it).  <a href="#e537d074ab4037ab60efa9d376220383"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#90c62a77ca9b76b10e1acd6701b61cc3">move</a> (int x, int y)
<dl class="el"><dd class="mdescRight">Repositions the window relative to its parent window.  <a href="#90c62a77ca9b76b10e1acd6701b61cc3"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#226d07e692693b913db0d84913a84e73">move</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> &amp;point)
<dl class="el"><dd class="mdescRight">Repositions the window relative to its parent window.  <a href="#226d07e692693b913db0d84913a84e73"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#e8a09b435ace3c108af1ad957369bfba">resize</a> (int width, int height)
<dl class="el"><dd class="mdescRight">Resizes the window; for toplevel windows, asks the window manager to resize the window.  <a href="#e8a09b435ace3c108af1ad957369bfba"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#cf892540e58ba72a438013a4fdf0a80a">move_resize</a> (int x, int y, int width, int height)
<dl class="el"><dd class="mdescRight">Equivalent to calling <a class="el" href="classXfc_1_1Gdk_1_1Window.html#90c62a77ca9b76b10e1acd6701b61cc3">move()</a> and <a class="el" href="classXfc_1_1Gdk_1_1Window.html#e8a09b435ace3c108af1ad957369bfba">resize()</a>, except that both operations are performed at once, avoiding strange visual effects.  <a href="#cf892540e58ba72a438013a4fdf0a80a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#4568281d46027f09d2a43b4ae63f7a30">move_resize</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;rectangle)
<dl class="el"><dd class="mdescRight">Equivalent to calling <a class="el" href="classXfc_1_1Gdk_1_1Window.html#90c62a77ca9b76b10e1acd6701b61cc3">move()</a> and <a class="el" href="classXfc_1_1Gdk_1_1Window.html#e8a09b435ace3c108af1ad957369bfba">resize()</a>, except that both operations are performed at once, avoiding strange visual effects.  <a href="#4568281d46027f09d2a43b4ae63f7a30"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#46b4e7ce3f262ffbf17377acd32ba382">reparent</a> (<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> &amp;new_parent, int x, int y)
<dl class="el"><dd class="mdescRight">Reparents the window into the given new_parent.  <a href="#46b4e7ce3f262ffbf17377acd32ba382"></a><br></dl><li><a class="anchor" name="036f01ec31a68d1354f3fc7d8b0d7e39"></a><!-- doxytag: member="Xfc::Gdk::Window::clear" ref="036f01ec31a68d1354f3fc7d8b0d7e39" args="()" -->
void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#036f01ec31a68d1354f3fc7d8b0d7e39">clear</a> ()
<dl class="el"><dd class="mdescRight">Clears the entire window to the background color or background pixmap. <br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#29011f68dd5dc0b0e5eb61899c5e7093">clear_area</a> (int x, int y, int width, int height, bool generate_expose=false)
<dl class="el"><dd class="mdescRight">Clears an area of the window to the background color or background pixmap.  <a href="#29011f68dd5dc0b0e5eb61899c5e7093"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3ef35f835e18b0b61c20f29c7606ec38">clear_area</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;rectangle, bool generate_expose=false)
<dl class="el"><dd class="mdescRight">Clears an area of the window to the background color or background pixmap.  <a href="#3ef35f835e18b0b61c20f29c7606ec38"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#deb6bbf6d03a29c747d8203d6eac64ce">raise</a> ()
<dl class="el"><dd class="mdescRight">Raises the window to the top of the Z-order (stacking order), so that other windows with the same parent window appear below the window.  <a href="#deb6bbf6d03a29c747d8203d6eac64ce"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#aad77599b313f0da21aded7742496498">lower</a> ()
<dl class="el"><dd class="mdescRight">Lowers the window to the bottom of the Z-order (stacking order), so that other windows with the same parent window appear above the window.  <a href="#aad77599b313f0da21aded7742496498"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#4a9894aa8812cfe0852981d731f37788">focus</a> (unsigned int timestamp)
<dl class="el"><dd class="mdescRight">Sets keyboard focus to the window.  <a href="#4a9894aa8812cfe0852981d731f37788"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#ed409014442400b9d19e550ecbddc2e9">set_user_data</a> (void *user_data)
<dl class="el"><dd class="mdescRight">For most purposes this method is deprecated in favor of <a class="el" href="classXfc_1_1G_1_1Object.html#b7e610618dfb2e6b7cc27e3c2601752d">G::Object::set_data()</a>.  <a href="#ed409014442400b9d19e550ecbddc2e9"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#6adc10200b441ab13ba45dcf86265c26">set_override_redirect</a> (bool override_redirect)
<dl class="el"><dd class="mdescRight">An override redirect window is not under the control of the window manager (this means it won't have a titlebar, won't be minimizable, etc., it will be entirely under the control of the application).  <a href="#6adc10200b441ab13ba45dcf86265c26"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#36661da73af25e1c3c3de820ce57f9f8">set_accept_focus</a> (bool accept_focus)
<dl class="el"><dd class="mdescRight">Setting accept_focus to <em>false</em> hints the desktop environment that the window doesn't want to receive the input focus.  <a href="#36661da73af25e1c3c3de820ce57f9f8"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#1a1bc1302fb39fb38ecf093c9f4d60fe">set_focus_on_map</a> (bool focus_on_map)
<dl class="el"><dd class="mdescRight">Setting <em>focus_on_map</em> to false hints the desktop environment that the window doesn't want to receive input focus when it is mapped.  <a href="#1a1bc1302fb39fb38ecf093c9f4d60fe"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#07de266ceebbff439bb0a5a1424a2c6d">scroll</a> (int dx, int dy)
<dl class="el"><dd class="mdescRight">Scroll the contents of window, both pixels and children, by the given amount.  <a href="#07de266ceebbff439bb0a5a1424a2c6d"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#df699f5e172fa8255f3a3b334ea9eb26">shape_combine_mask</a> (<a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Bitmap</a> *shape_mask, int x=0, int y=0)
<dl class="el"><dd class="mdescRight">Make a shaped partially transparent window using a bitmap mask.  <a href="#df699f5e172fa8255f3a3b334ea9eb26"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#418978bd4e112145fa056406d65d9285">shape_combine_region</a> (<a class="el" href="classXfc_1_1Gdk_1_1Region.html">Region</a> *shape_region, int offset_x=0, int offset_y=0)
<dl class="el"><dd class="mdescRight">Makes pixels in the window outside <em>shape_region</em> be transparent, so that the window may be non-rectangular (see also <a class="el" href="classXfc_1_1Gdk_1_1Window.html#df699f5e172fa8255f3a3b334ea9eb26">shape_combine_mask()</a> to use a bitmap as the mask.  <a href="#418978bd4e112145fa056406d65d9285"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#bf03f60968fce7768b1603b7c5c8411e">set_child_shapes</a> ()
<dl class="el"><dd class="mdescRight">Sets the shape mask of the window to the union of shape masks for all children of the window, ignoring the shape mask of the window itself.  <a href="#bf03f60968fce7768b1603b7c5c8411e"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5b85036c5bc9da46de329bfae5eb9b7a">merge_child_shapes</a> ()
<dl class="el"><dd class="mdescRight">Merges the shape masks for any child windows into the shape mask for this window (that is, the union of all masks for the window and its children will become the new mask for window (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#df699f5e172fa8255f3a3b334ea9eb26">shape_combine_mask()</a>).  <a href="#5b85036c5bc9da46de329bfae5eb9b7a"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gdk_1_1Window.html#b29d95ff4110d0bc2980ab2aafd4bcd5">set_static_gravities</a> (bool use_static)
<dl class="el"><dd class="mdescRight">Set the bit gravity of the window to static and flag it so all children get static subwindow gravity.  <a href="#b29d95ff4110d0bc2980ab2aafd4bcd5"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5db69418b80b20c127e26faf1c92d54d">set_type_hint</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#7bc9d7170459002f90922e5ece04678c">WindowTypeHint</a> hint)
<dl class="el"><dd class="mdescRight">The application can use this call to provide a hint to the window manager about the functionality of the window.  <a href="#5db69418b80b20c127e26faf1c92d54d"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#c18ae5fb58ff4250fef3790d5c6691f1">set_modal_hint</a> (bool modal)
<dl class="el"><dd class="mdescRight">The application can use this hint to tell the window manager that a certain window has modal behaviour.  <a href="#c18ae5fb58ff4250fef3790d5c6691f1"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#f3082611e8880b58db3b0c4ff0ce2a32">set_skip_taskbar_hint</a> (bool skips_taskbar)
<dl class="el"><dd class="mdescRight">Toggles whether the window should appear in a task list or window list.  <a href="#f3082611e8880b58db3b0c4ff0ce2a32"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#00993b332474ff81b6bb7a1941018d59">set_skip_pager_hint</a> (bool skips_pager)
<dl class="el"><dd class="mdescRight">Toggles whether the window should appear in a pager (workspace switcher, or other desktop utility program that displays a small thumbnail representation of the windows on the desktop).  <a href="#00993b332474ff81b6bb7a1941018d59"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#08725a29b9d49322ba77d2eeb773364a">set_geometry_hints</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Geometry.html">Geometry</a> *geometry)
<dl class="el"><dd class="mdescRight">Sets the geometry hints for the window.  <a href="#08725a29b9d49322ba77d2eeb773364a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#2de04b3845df711ee41d5a8de7b7b951">begin_paint</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;rectangle)
<dl class="el"><dd class="mdescRight">Indicates that you are beginning the process of redrawing a rectangular region.  <a href="#2de04b3845df711ee41d5a8de7b7b951"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3ea3ffce5cd2dc6957bfaaaea93b4d27">begin_paint</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Region.html">Region</a> &amp;region)
<dl class="el"><dd class="mdescRight">Indicates that you are beginning the process of redrawing region.  <a href="#3ea3ffce5cd2dc6957bfaaaea93b4d27"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0d2820164c0fdcc29ba8e95625f74bc0">end_paint</a> ()
<dl class="el"><dd class="mdescRight">Indicates that the backing store created by the most recent call to <a class="el" href="classXfc_1_1Gdk_1_1Window.html#2de04b3845df711ee41d5a8de7b7b951">begin_paint()</a> should be copied onscreen and deleted, leaving the next-most-recent backing store or no backing store at all as the active paint region (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3ea3ffce5cd2dc6957bfaaaea93b4d27">begin_paint(const Region&amp;)</a> for full details).  <a href="#0d2820164c0fdcc29ba8e95625f74bc0"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#1304aa01e60fa40c88178aede0d856a6">set_title</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;title)
<dl class="el"><dd class="mdescRight">Sets the title of a toplevel window, to be displayed in the titlebar.  <a href="#1304aa01e60fa40c88178aede0d856a6"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3facbf4b9bf39b9537a78b733bba8cc1">set_role</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;role)
<dl class="el"><dd class="mdescRight">Typically you should use Gtk::Window::set_role() instead of this low-level method.  <a href="#3facbf4b9bf39b9537a78b733bba8cc1"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3ea47db108882e7c5be3e48a6ae2d995">set_transient_for</a> (<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> &amp;parent)
<dl class="el"><dd class="mdescRight">Indicates to the window manager that window is a transient dialog associated with the application window parent.  <a href="#3ea47db108882e7c5be3e48a6ae2d995"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#bd83a705094053c926e2bcbe14c77aec">set_background</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Color.html">Color</a> &amp;color)
<dl class="el"><dd class="mdescRight">Sets the background color of the window.  <a href="#bd83a705094053c926e2bcbe14c77aec"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#68f91a87b5526231af9b2b740c9d9e7f">set_back_pixmap</a> (<a class="el" href="classXfc_1_1Gdk_1_1Pixmap.html">Pixmap</a> *pixmap, bool parent_relative=false)
<dl class="el"><dd class="mdescRight">Sets the background pixmap of the window.  <a href="#68f91a87b5526231af9b2b740c9d9e7f"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#1adaa48a8575a541069f9a1036098574">set_cursor</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Cursor.html">Cursor</a> &amp;cursor)
<dl class="el"><dd class="mdescRight">Sets the mouse pointer for the window.  <a href="#1adaa48a8575a541069f9a1036098574"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#7c446d6bac000bfb2e4bcc3bc80552a2">set_events</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">EventMaskField</a> event_mask)
<dl class="el"><dd class="mdescRight">Sets the event mask for the window.  <a href="#7c446d6bac000bfb2e4bcc3bc80552a2"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#c3876454f2add79fa8566c72c00251cc">set_icon_list</a> (const std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> * &gt; &amp;pixbufs)
<dl class="el"><dd class="mdescRight">Sets a list of icons for the window.  <a href="#c3876454f2add79fa8566c72c00251cc"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#e2070842284647d99c2cc5395786a917">set_icon</a> (<a class="el" href="classXfc_1_1Gdk_1_1Pixmap.html">Pixmap</a> *pixmap, <a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Bitmap</a> *mask, <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> *icon_window=0)
<dl class="el"><dd class="mdescRight">Sets the icon of the window as a pixmap or window.  <a href="#e2070842284647d99c2cc5395786a917"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3b6aefd8ff8f22e29d996b211ed0417d">set_icon_name</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;name)
<dl class="el"><dd class="mdescRight">Windows may have a name used while minimized, distinct from the name they display in their titlebar.  <a href="#3b6aefd8ff8f22e29d996b211ed0417d"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#773b296b3ce236c7e349772b832fb8d3">set_group</a> (<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> &amp;leader)
<dl class="el"><dd class="mdescRight">Sets the group leader window for the window.  <a href="#773b296b3ce236c7e349772b832fb8d3"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#8a41f0eb92974324b17942b2dae52761">set_decorations</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#87db3b9f39ef0c2d4e996b4dbaed5fdb">WMDecorationField</a> decorations)
<dl class="el"><dd class="mdescRight">"Decorations" are the features the window manager adds to a toplevel <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>.  <a href="#8a41f0eb92974324b17942b2dae52761"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#577771b2da679d9d9886ee398d248270">set_functions</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#6ca3bc981cb74955ac51d5b4bff609b6">WMFunctionField</a> functions)
<dl class="el"><dd class="mdescRight">Sets the traditional Motif window manager hint for which operations the window manager should allow on a toplevel window.  <a href="#577771b2da679d9d9886ee398d248270"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#172e208474427b0b5926863f748a7c80">iconify</a> ()
<dl class="el"><dd class="mdescRight">Asks to iconify (minimize) the window.  <a href="#172e208474427b0b5926863f748a7c80"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#e77228302a4743b942c3ee36df8e1bbd">deiconify</a> ()
<dl class="el"><dd class="mdescRight">Attempts to deiconify (unminimize) the window.  <a href="#e77228302a4743b942c3ee36df8e1bbd"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0b020abd689bf153123872b874eb9077">stick</a> ()
<dl class="el"><dd class="mdescRight">"Pins" the window such that it's on all workspaces and does not scroll with viewports, for window managers that have scrollable viewports.  <a href="#0b020abd689bf153123872b874eb9077"></a><br></dl><li><a class="anchor" name="5d2760a1e816c519280fb8c449bfbe4d"></a><!-- doxytag: member="Xfc::Gdk::Window::unstick" ref="5d2760a1e816c519280fb8c449bfbe4d" args="()" -->
void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5d2760a1e816c519280fb8c449bfbe4d">unstick</a> ()
<dl class="el"><dd class="mdescRight">Reverse operation for <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0b020abd689bf153123872b874eb9077">stick()</a>; see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0b020abd689bf153123872b874eb9077">Gdk::Window::stick()</a>, and <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c2d77af7104e871e2787984d014d62e6">Gtk::Window::unstick()</a>. <br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#319a5ad6ce2ebf23d65fc073c2a6da5c">maximize</a> ()
<dl class="el"><dd class="mdescRight">Maximizes the window.  <a href="#319a5ad6ce2ebf23d65fc073c2a6da5c"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#8443b27c8d2f75bd2ad50508ce876a2d">unmaximize</a> ()
<dl class="el"><dd class="mdescRight">Unmaximizes the window.  <a href="#8443b27c8d2f75bd2ad50508ce876a2d"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#34a2d439d0a55c7bc529a939f14ae8d0">fullscreen</a> ()
<dl class="el"><dd class="mdescRight">Moves the window into fullscreen mode.  <a href="#34a2d439d0a55c7bc529a939f14ae8d0"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#fc372a5fec6da91874b470ac026830bf">unfullscreen</a> ()
<dl class="el"><dd class="mdescRight">Moves the window out of fullscreen mode.  <a href="#fc372a5fec6da91874b470ac026830bf"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#ba85a872fcbe8ea17da5e538935e4ce2">set_keep_above</a> (bool setting)
<dl class="el"><dd class="mdescRight">Set if the window must be kept above other windows.  <a href="#ba85a872fcbe8ea17da5e538935e4ce2"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#265cf94e1998441ef184a38fa77ed1a0">set_keep_below</a> (bool setting)
<dl class="el"><dd class="mdescRight">Set if the window must be kept below other windows.  <a href="#265cf94e1998441ef184a38fa77ed1a0"></a><br></dl><li><a class="anchor" name="b0524e44773f78fd3328095e32e43f91"></a><!-- doxytag: member="Xfc::Gdk::Window::register_dnd" ref="b0524e44773f78fd3328095e32e43f91" args="()" -->
void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#b0524e44773f78fd3328095e32e43f91">register_dnd</a> ()
<dl class="el"><dd class="mdescRight">Registers a window as a potential drop destination. <br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#dc407eb56aff778e0180c699be5dbf37">begin_resize_drag</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#0e823b84cf97c36c12abce34415e9e39">WindowEdge</a> edge, int button, int root_x, int root_y, unsigned int timestamp)
<dl class="el"><dd class="mdescRight">Begins a window resize operation (for a toplevel window).  <a href="#dc407eb56aff778e0180c699be5dbf37"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#092e8c816b414076e0618816c0aeab16">begin_move_drag</a> (int button, int root_x, int root_y, unsigned int timestamp)
<dl class="el"><dd class="mdescRight">Begins a window move operation (for a toplevel window).  <a href="#092e8c816b414076e0618816c0aeab16"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#c339f7f349b7213e85d02a7e81ecb7b2">invalidate</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;rectangle, bool invalidate_children)
<dl class="el"><dd class="mdescRight">Adds <em>rectangle</em> to the update area for the window.  <a href="#c339f7f349b7213e85d02a7e81ecb7b2"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#97e405dab8885c0bd80f3d134bff2eba">invalidate</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Region.html">Region</a> &amp;region, bool invalidate_children)
<dl class="el"><dd class="mdescRight">Adds <em>region</em> to the update area for the window.  <a href="#97e405dab8885c0bd80f3d134bff2eba"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#cdb0211dde80aac9fbd6f128ca6b1eea">freeze_updates</a> ()
<dl class="el"><dd class="mdescRight">Temporarily freezes a window such that it won't receive expose events.  <a href="#cdb0211dde80aac9fbd6f128ca6b1eea"></a><br></dl><li><a class="anchor" name="44ca52d2e727b9042ac69c822674691d"></a><!-- doxytag: member="Xfc::Gdk::Window::thaw_updates" ref="44ca52d2e727b9042ac69c822674691d" args="()" -->
void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#44ca52d2e727b9042ac69c822674691d">thaw_updates</a> ()
<dl class="el"><dd class="mdescRight">Thaws a window frozen with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#cdb0211dde80aac9fbd6f128ca6b1eea">freeze_updates()</a>. <br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5250420ef05e8ed00cee17450263a6b4">process_updates</a> (bool update_children)
<dl class="el"><dd class="mdescRight">Sends one or more expose events to the window.  <a href="#5250420ef05e8ed00cee17450263a6b4"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#7ac6128a4ce529f83ce358961362acbe">set_debug_updates</a> (bool setting)
<dl class="el"><dd class="mdescRight">With update debugging enabled, calls to <a class="el" href="classXfc_1_1Gdk_1_1Window.html#97e405dab8885c0bd80f3d134bff2eba">invalidate(const Region&amp;, bool)</a> clear the invalidated region of the screen to a noticeable color, and GDK pauses for a short time before sending exposes to windows during <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5250420ef05e8ed00cee17450263a6b4">process_updates()</a>.  <a href="#7ac6128a4ce529f83ce358961362acbe"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#68bc38f96eed6e2b277ba377bfca7177">enable_synchronized_configure</a> ()
<dl class="el"><dd class="mdescRight">Indicates that the application will cooperate with the window system in synchronizing the window repaint with the window manager during resizing operations.  <a href="#68bc38f96eed6e2b277ba377bfca7177"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3edde69831c0395e0299c1cab5f9e492">configure_finished</a> ()
<dl class="el"><dd class="mdescRight">Signal to the window system that the application has finished handling "configure" events it has received.  <a href="#3edde69831c0395e0299c1cab5f9e492"></a><br></dl><li><a class="el" href="namespaceXfc_1_1Gdk.html#a122cdf630b777e48fce8da9f57a01b6">GrabStatus</a> <a class="el" href="classXfc_1_1Gdk_1_1Window.html#fffc194ea371388241e754b1abe025db">keyboard_grab</a> (bool owner_events=false, unsigned int time=GDK_CURRENT_TIME)
<dl class="el"><dd class="mdescRight">This window grabs the keyboard so that all events are passed to this application until the keyboard is ungrabbed with <a class="el" href="namespaceXfc_1_1Gdk.html#18d3b377328e00747fe591469bdc91f6">Gdk::keyboard_ungrab()</a>.  <a href="#fffc194ea371388241e754b1abe025db"></a><br></dl><li><a class="el" href="namespaceXfc_1_1Gdk.html#a122cdf630b777e48fce8da9f57a01b6">GrabStatus</a> <a class="el" href="classXfc_1_1Gdk_1_1Window.html#08c01838fd6c5ca6fda03fba0567f969">pointer_grab</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">EventMaskField</a> event_mask, <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> *confine_to=0, <a class="el" href="classXfc_1_1Gdk_1_1Cursor.html">Cursor</a> *cursor=0, bool owner_events=false, unsigned int time=GDK_CURRENT_TIME)
<dl class="el"><dd class="mdescRight">This window grabs the pointer (usualy a mouse) so that all events are passed to this application until the pointer is ungrabbed with <a class="el" href="namespaceXfc_1_1Gdk.html#c01264f9bd5744449473c344b96ae9b8">Gdk::pointer_ungrab()</a>, or the grab window becomes unviewable.  <a href="#08c01838fd6c5ca6fda03fba0567f969"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Input methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#14ad4e31494a187d2e4c524d92c0e2a5">set_extension_events</a> (int mask, <a class="el" href="namespaceXfc_1_1Gdk.html#6a40c7183f0539c8c67394dc8a22a917">ExtensionMode</a> mode)
<dl class="el"><dd class="mdescRight">Turns extension events on or off for a particular window, and specifies the event mask for extension events.  <a href="#14ad4e31494a187d2e4c524d92c0e2a5"></a><br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> &gt; <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5c8094a114b957254f509e5de334c6e8">create</a> (GdkNativeWindow anid, const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Display</a> *display=0)
<dl class="el"><dd class="mdescRight">Wraps a native window in a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>.  <a href="#5c8094a114b957254f509e5de334c6e8"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> * <a class="el" href="classXfc_1_1Gdk_1_1Window.html#1a7a37729368739b3a07581f4a745f3d">lookup</a> (GdkNativeWindow anid, const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Display</a> *display=0)
<dl class="el"><dd class="mdescRight">Looks up the <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> that wraps the given native window handle.  <a href="#1a7a37729368739b3a07581f4a745f3d"></a><br></dl><li>static <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> * <a class="el" href="classXfc_1_1Gdk_1_1Window.html#d8ec7bb2f9ac093b1b2d67ad1e92f95e">at_pointer</a> (int *win_x, int *win_y, const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Display</a> *display=0)
<dl class="el"><dd class="mdescRight">Obtains the window underneath the mouse pointer on <em>display</em>, returning the location of that window in win_x, win_y.  <a href="#d8ec7bb2f9ac093b1b2d67ad1e92f95e"></a><br></dl><li>static <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> * <a class="el" href="classXfc_1_1Gdk_1_1Window.html#fd79f7bef1e61993d2c6d19f6e874d99">at_pointer</a> (<a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> &amp;point, const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Display</a> *display=0)
<dl class="el"><dd class="mdescRight">Obtains the window underneath the mouse pointer on <em>display</em>, returning the location of that window in <em>point</em>.  <a href="#fd79f7bef1e61993d2c6d19f6e874d99"></a><br></dl><li>static bool <a class="el" href="classXfc_1_1Gdk_1_1Window.html#03aefbe86638b307eaeaf590c877f959">get_toplevels</a> (std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> * &gt; &amp;toplevels)
<dl class="el"><dd class="mdescRight">Obtains a list of all toplevel windows known to GDK on the default screen (see get_toplevels_for_screen()).  <a href="#03aefbe86638b307eaeaf590c877f959"></a><br></dl><li><a class="anchor" name="bfcda13fe554d94ad90555c8a4a4332e"></a><!-- doxytag: member="Xfc::Gdk::Window::process_all_updates" ref="bfcda13fe554d94ad90555c8a4a4332e" args="()" -->
static void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#bfcda13fe554d94ad90555c8a4a4332e">process_all_updates</a> ()
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5250420ef05e8ed00cee17450263a6b4">process_updates()</a> for all the GDK windows in the application (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5250420ef05e8ed00cee17450263a6b4">process_updates()</a>). <br></dl><li>static void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#ecd34eef21679991cbef2877e89b761f">add_filter</a> (<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> *window, GdkFilterFunc function, void *data)
<dl class="el"><dd class="mdescRight">Adds an event filter for <em>window</em>, allowing you to intercept events before they reach GDK.  <a href="#ecd34eef21679991cbef2877e89b761f"></a><br></dl><li>static void <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3d72515961b48e6c2a116955306e3ed1">remove_filter</a> (<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> *window, GdkFilterFunc function, void *data)
<dl class="el"><dd class="mdescRight">Remove a filter previously added with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#ecd34eef21679991cbef2877e89b761f">add_filter()</a>.  <a href="#3d72515961b48e6c2a116955306e3ed1"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GdkWindow C++ wrapper class. 
<p>
A <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> is a rectangular region on the screen. It's a low-level object, used to implement high-level objects such as <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a> and <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a>. A <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> is a toplevel window, the thing a user might think of as a "window" with a titlebar and so on; a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> may contain many <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>. For example, each <a class="el" href="classXfc_1_1Gtk_1_1Button.html">Gtk::Button</a> has a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> associated with it. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="7bbf1ed26d915a72a00e8f9e53cbc2b7"></a><!-- doxytag: member="Xfc::Gdk::Window::Window" ref="7bbf1ed26d915a72a00e8f9e53cbc2b7" args="(GdkWindow *window, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Window::Window           </td>
          <td>(</td>
          <td class="paramtype">GdkWindow *&nbsp;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> from an existing GdkWindow. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>window</em>&nbsp;</td><td>A pointer to a GdkWindow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>window</em> can be a newly created GdkWindow or an existing GdkWindow. (see G::Object::Object). 
</div>
</div><p>
<a class="anchor" name="e08e839811cb65de7162d0b0645a5df7"></a><!-- doxytag: member="Xfc::Gdk::Window::Window" ref="e08e839811cb65de7162d0b0645a5df7" args="(const WindowAttr &amp;attributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Window::Window           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1WindowAttr.html">WindowAttr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attributes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new window with the root window of the default display as the parent. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&nbsp;</td><td>The attributes of the new window.</td></tr>
  </table>
</dl>
A <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> must be explicitly destroyed by calling <a class="el" href="classXfc_1_1Gdk_1_1Window.html#72a272b6a99cee4484870642e8a431f7">dispose()</a>. 
</div>
</div><p>
<a class="anchor" name="b431bf01b549d03079751a336da579a1"></a><!-- doxytag: member="Xfc::Gdk::Window::Window" ref="b431bf01b549d03079751a336da579a1" args="(const Window &amp;parent, const WindowAttr &amp;attributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Window::Window           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1WindowAttr.html">WindowAttr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attributes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new window with <em>parent</em> as the parent. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&nbsp;</td><td>The attributes of the new window.</td></tr>
  </table>
</dl>
This is the constructor to use to create a new window on a display other than the default display. A <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> must be explicitly destroyed by calling <a class="el" href="classXfc_1_1Gdk_1_1Window.html#72a272b6a99cee4484870642e8a431f7">dispose()</a>. 
</div>
</div><p>
<a class="anchor" name="7bbf1ed26d915a72a00e8f9e53cbc2b7"></a><!-- doxytag: member="Xfc::Gdk::Window::Window" ref="7bbf1ed26d915a72a00e8f9e53cbc2b7" args="(GdkWindow *window, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Window::Window           </td>
          <td>(</td>
          <td class="paramtype">GdkWindow *&nbsp;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> from an existing GdkWindow. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>window</em>&nbsp;</td><td>A pointer to a GdkWindow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>window</em> can be a newly created GdkWindow or an existing GdkWindow. (see G::Object::Object). 
</div>
</div><p>
<a class="anchor" name="e08e839811cb65de7162d0b0645a5df7"></a><!-- doxytag: member="Xfc::Gdk::Window::Window" ref="e08e839811cb65de7162d0b0645a5df7" args="(const WindowAttr &amp;attributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Window::Window           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1WindowAttr.html">WindowAttr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attributes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new window with the root window of the default display as the parent. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&nbsp;</td><td>The attributes of the new window.</td></tr>
  </table>
</dl>
A <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> must be explicitly destroyed by calling <a class="el" href="classXfc_1_1Gdk_1_1Window.html#72a272b6a99cee4484870642e8a431f7">dispose()</a>. 
</div>
</div><p>
<a class="anchor" name="b431bf01b549d03079751a336da579a1"></a><!-- doxytag: member="Xfc::Gdk::Window::Window" ref="b431bf01b549d03079751a336da579a1" args="(const Window &amp;parent, const WindowAttr &amp;attributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gdk::Window::Window           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1WindowAttr.html">WindowAttr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attributes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new window with <em>parent</em> as the parent. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&nbsp;</td><td>The attributes of the new window.</td></tr>
  </table>
</dl>
This is the constructor to use to create a new window on a display other than the default display. A <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> must be explicitly destroyed by calling <a class="el" href="classXfc_1_1Gdk_1_1Window.html#72a272b6a99cee4484870642e8a431f7">dispose()</a>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5c8094a114b957254f509e5de334c6e8"></a><!-- doxytag: member="Xfc::Gdk::Window::create" ref="5c8094a114b957254f509e5de334c6e8" args="(GdkNativeWindow anid, const Display *display=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a>&gt; Xfc::Gdk::Window::create           </td>
          <td>(</td>
          <td class="paramtype">GdkNativeWindow&nbsp;</td>
          <td class="paramname"> <em>anid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Display</a> *&nbsp;</td>
          <td class="paramname"> <em>display</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wraps a native window in a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>anid</em>&nbsp;</td><td>A native window handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>display</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Display</a> where the window handle comes from, or null for the default display. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the newly-created <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> wrapper for the native window, or null if the window has been destroyed.</dd></dl>
In the X backend, a native window handle is an Xlib XID. This method fail if the pixmap has been destroyed. 
</div>
</div><p>
<a class="anchor" name="efc31999f041eff95f42053d0ef56975"></a><!-- doxytag: member="Xfc::Gdk::Window::is_visible" ref="efc31999f041eff95f42053d0ef56975" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Window::is_visible           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets whether the window has been mapped (with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#f6211ecd7c42c56d4509917a33e9557b">show()</a> or <a class="el" href="classXfc_1_1Gdk_1_1Window.html#7f842debe336cedca26ac9de41f32a12">show_unraised()</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the window is mapped. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d59a80c5265f23902cbe48407556a356"></a><!-- doxytag: member="Xfc::Gdk::Window::is_viewable" ref="d59a80c5265f23902cbe48407556a356" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Window::is_viewable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the window and all ancestors of the window are mapped. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the window is viewable.</dd></dl>
This is not necessarily "viewable" in the X sense, since we only check as far as we have GDK window parents, not to the root window. 
</div>
</div><p>
<a class="anchor" name="f3e268b4d3da7a4cb1e31bcbd05278cf"></a><!-- doxytag: member="Xfc::Gdk::Window::get_state" ref="f3e268b4d3da7a4cb1e31bcbd05278cf" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1Gdk.html#471e27156f88a96317d9f464f883bf5f">WindowState</a> Xfc::Gdk::Window::get_state           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the bitwise OR of the currently active window state flags, from the <a class="el" href="namespaceXfc_1_1Gdk.html#471e27156f88a96317d9f464f883bf5f">Gdk::WindowState</a> enumeration. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The window state bitfield. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e47d2cd5dc5bbb87d913d505e4dafca4"></a><!-- doxytag: member="Xfc::Gdk::Window::get_user_data" ref="e47d2cd5dc5bbb87d913d505e4dafca4" args="(void *&amp;data) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::get_user_data           </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the user data for window, which is normally the widget that window belongs to (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#ed409014442400b9d19e550ecbddc2e9">set_user_data()</a>). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A reference to the return location for the user data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="24e0d9980101efef6eb540853f9ba52c"></a><!-- doxytag: member="Xfc::Gdk::Window::get_geometry" ref="24e0d9980101efef6eb540853f9ba52c" args="(int *x, int *y, int *width, int *height, int *depth) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::get_geometry           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current geometry of the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The return location for the X coordinate of the window (relative to its parent). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The return location for the Y coordinate of the window (relative to its parent). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The return location for the width of the window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The return location for the height of the window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>The return location for the bit depth of the window.</td></tr>
  </table>
</dl>
Any of the return location arguments to this method may be null, if you aren't interested in getting the value of that field. The X and Y coordinates returned are relative to the parent window of window, which for toplevels usually means relative to the window decorations (titlebar, etc.) rather than relative to the root window (screen-size background window).<p>
On the X11 platform, the geometry is obtained from the X server, so reflects the latest position of window; this may be out-of-sync with the position of window delivered in the most-recently-processed <a class="el" href="classXfc_1_1Gdk_1_1EventConfigure.html">Gdk::EventConfigure</a>. <a class="el" href="classXfc_1_1Gdk_1_1Window.html#6cbd328c646de49eb69d5e108aa0f897">get_position()</a> in contrast gets the position from the most recent configure event. 
</div>
</div><p>
<a class="anchor" name="3c64c695dccff5d175fd6b7b52dbc66f"></a><!-- doxytag: member="Xfc::Gdk::Window::get_geometry" ref="3c64c695dccff5d175fd6b7b52dbc66f" args="(Rectangle &amp;rectangle, int *depth) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::get_geometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rectangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current geometry of the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rectangle</em>&nbsp;</td><td>The return location for the x, y coordinates, width and height of the window (relative to its parent). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>The return location for the bit depth of the window.</td></tr>
  </table>
</dl>
The depth argument may be null, if you aren't interested in getting the depth. The X and Y coordinates returned are relative to the parent window of window, which for toplevels usually means relative to the window decorations (titlebar, etc.) rather than relative to the root window (screen-size background window).<p>
On the X11 platform, the geometry is obtained from the X server, so reflects the latest position of window; this may be out-of-sync with the position of window delivered in the most-recently-processed <a class="el" href="classXfc_1_1Gdk_1_1EventConfigure.html">Gdk::EventConfigure</a>. <a class="el" href="classXfc_1_1Gdk_1_1Window.html#6cbd328c646de49eb69d5e108aa0f897">get_position()</a> in contrast gets the position from the most recent configure event. 
</div>
</div><p>
<a class="anchor" name="6cbd328c646de49eb69d5e108aa0f897"></a><!-- doxytag: member="Xfc::Gdk::Window::get_position" ref="6cbd328c646de49eb69d5e108aa0f897" args="(int *x, int *y) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::get_position           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the position of the window as reported in the most-recently-processed <a class="el" href="classXfc_1_1Gdk_1_1EventConfigure.html">Gdk::EventConfigure</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X coordinate of the window relative to the window's parent window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y coordinate of the window relative to the window's parent window.</td></tr>
  </table>
</dl>
Contrast with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#24e0d9980101efef6eb540853f9ba52c">get_geometry()</a> which queries the X server for the current window position, regardless of which events have been received or processed. The position coordinates are relative to the window's parent window. 
</div>
</div><p>
<a class="anchor" name="af11f154c3dba99a06735fe0f233ba5c"></a><!-- doxytag: member="Xfc::Gdk::Window::get_position" ref="af11f154c3dba99a06735fe0f233ba5c" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> Xfc::Gdk::Window::get_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the position of the window as reported in the most-recently-processed <a class="el" href="classXfc_1_1Gdk_1_1EventConfigure.html">Gdk::EventConfigure</a> (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#6cbd328c646de49eb69d5e108aa0f897">get_position(int*, int*) const</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> containing the x, y coordinates of the window relative to the parent window.</dd></dl>
Contrast with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#24e0d9980101efef6eb540853f9ba52c">get_geometry()</a> which queries the X server for the current window position, regardless of which events have been received or processed. The position coordinates are relative to the window's parent window. 
</div>
</div><p>
<a class="anchor" name="9f1b22bf649fef9b8f58225611f5da44"></a><!-- doxytag: member="Xfc::Gdk::Window::get_origin" ref="9f1b22bf649fef9b8f58225611f5da44" args="(int *x, int *y) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Window::get_origin           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the position of a window in root window coordinates. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The return location for X coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The return location for Y coordinate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Nothing meaningful, ignore it.</dd></dl>
Compare with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#6cbd328c646de49eb69d5e108aa0f897">get_position()</a> and <a class="el" href="classXfc_1_1Gdk_1_1Window.html#24e0d9980101efef6eb540853f9ba52c">get_geometry()</a> which return the position of a window relative to its parent window. 
</div>
</div><p>
<a class="anchor" name="6fd77c325ba0e5e9a55b4970a472b6f9"></a><!-- doxytag: member="Xfc::Gdk::Window::get_origin" ref="6fd77c325ba0e5e9a55b4970a472b6f9" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> Xfc::Gdk::Window::get_origin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the position of a window in root window coordinates. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> holding the x, y coordinates.</dd></dl>
Compare with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#6cbd328c646de49eb69d5e108aa0f897">get_position()</a> and <a class="el" href="classXfc_1_1Gdk_1_1Window.html#24e0d9980101efef6eb540853f9ba52c">get_geometry()</a> which return the position of a window relative to its parent window. 
</div>
</div><p>
<a class="anchor" name="dfa11ca456526c4850f2f9a8321a3d69"></a><!-- doxytag: member="Xfc::Gdk::Window::get_root_origin" ref="dfa11ca456526c4850f2f9a8321a3d69" args="(int *x, int *y) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::get_root_origin           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the top-left corner of the window manager frame in root window coordinates. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The return location for X position of the window frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The return location for Y position of the window frame. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="436b6ffbb2fe25f07add4d5e97194882"></a><!-- doxytag: member="Xfc::Gdk::Window::get_root_origin" ref="436b6ffbb2fe25f07add4d5e97194882" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> Xfc::Gdk::Window::get_root_origin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the top-left corner of the window manager frame in root window coordinates. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> containing the x, y position of the window frame. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c40f9da9d50c7771a81edfe3b2615bcb"></a><!-- doxytag: member="Xfc::Gdk::Window::get_pointer" ref="c40f9da9d50c7771a81edfe3b2615bcb" args="(int *x, int *y, ModifierTypeField *mask) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a>* Xfc::Gdk::Window::get_pointer           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">ModifierTypeField</a> *&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the current pointer position and modifier state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The return location for X coordinate of the pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The return location for Y coordinate of the pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The return location for modifier mask. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The window containing the pointer (as with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#d8ec7bb2f9ac093b1b2d67ad1e92f95e">at_pointer()</a>), or null if the window containing the pointer isn't known to GDK</dd></dl>
The position is given in coordinates relative to the window. 
</div>
</div><p>
<a class="anchor" name="15b12c1c02791cce97fa3fffc5c4466a"></a><!-- doxytag: member="Xfc::Gdk::Window::get_parent" ref="15b12c1c02791cce97fa3fffc5c4466a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a>* Xfc::Gdk::Window::get_parent           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the parent of window, as known to GDK. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The parent of the window.</dd></dl>
Does not query the X server; thus this returns the parent as passed to the <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> constructor, not the actual parent. This should never matter unless you're using Xlib calls mixed with GDK calls on the X11 platform. It may also matter for toplevel windows, because the window manager may choose to reparent them. 
</div>
</div><p>
<a class="anchor" name="441f19242379bd25fb489caa114f23b8"></a><!-- doxytag: member="Xfc::Gdk::Window::get_toplevel" ref="441f19242379bd25fb489caa114f23b8" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a>* Xfc::Gdk::Window::get_toplevel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the toplevel window that's an ancestor of the window. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The toplevel window containing the window. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8550e2ab943ad5928652dc8d321e7852"></a><!-- doxytag: member="Xfc::Gdk::Window::get_children" ref="8550e2ab943ad5928652dc8d321e7852" args="(std::vector&lt; Window * &gt; &amp;child_list) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Window::get_children           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>child_list</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the list of children of the window known to GDK. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>child_list</em>&nbsp;</td><td>A reference to a vector of Window* to hold the child windows. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the vector is not empty.</dd></dl>
This method only returns children created via GDK, so for example it's useless when used with the root window; it only returns windows an application created itself. 
</div>
</div><p>
<a class="anchor" name="c7867c2efc6d1a1fc9e107f80d3bc2ad"></a><!-- doxytag: member="Xfc::Gdk::Window::get_events" ref="c7867c2efc6d1a1fc9e107f80d3bc2ad" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">EventMaskField</a> Xfc::Gdk::Window::get_events           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the event mask for window (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#7c446d6bac000bfb2e4bcc3bc80552a2">set_events()</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The event mask for window. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c4296368bcc3fbdda2bba16ee92f0ea4"></a><!-- doxytag: member="Xfc::Gdk::Window::get_decorations" ref="c4296368bcc3fbdda2bba16ee92f0ea4" args="(WMDecorationField *decorations) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Window::get_decorations           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#87db3b9f39ef0c2d4e996b4dbaed5fdb">WMDecorationField</a> *&nbsp;</td>
          <td class="paramname"> <em>decorations</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the group leader window for this window (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#773b296b3ce236c7e349772b832fb8d3">set_group()</a>). Gets the decorations set on the window with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#8a41f0eb92974324b17942b2dae52761">set_decorations()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The group leader window for the window. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>decorations</em>&nbsp;</td><td>The return location for the window's <a class="el" href="namespaceXfc_1_1Gdk.html#3bd329235da47b9706518873a473b779">Gdk::WMDecoration</a> bitfield. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the window has decorations set, false otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="287db64dcff1a9c70c5fddd50490f4c2"></a><!-- doxytag: member="Xfc::Gdk::Window::get_update_area" ref="287db64dcff1a9c70c5fddd50490f4c2" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Region.html">Region</a>&gt; Xfc::Gdk::Window::get_update_area           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transfers ownership of the update area from the window to the caller of the method. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The update area for the window, or null if there is no update area.</dd></dl>
After calling this method the window will no longer have an invalid/dirty region; the update area is removed from the window and handed to you. 
</div>
</div><p>
<a class="anchor" name="079411ff10a2a25ff1c0382055733440"></a><!-- doxytag: member="Xfc::Gdk::Window::get_frame_extents" ref="079411ff10a2a25ff1c0382055733440" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> Xfc::Gdk::Window::get_frame_extents           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the bounding box of the window, including window manager titlebar/borders if any. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> filled with bounding box of the window frame.</dd></dl>
The frame position is given in root window coordinates. To get the position of the window itself (rather than the frame) in root window coordinates, use <a class="el" href="classXfc_1_1Gdk_1_1Window.html#9f1b22bf649fef9b8f58225611f5da44">get_origin()</a>. 
</div>
</div><p>
<a class="anchor" name="d8f4518a8e5f8f282c430217c865c9bb"></a><!-- doxytag: member="Xfc::Gdk::Window::get_frame_extents" ref="d8f4518a8e5f8f282c430217c865c9bb" args="(Rectangle &amp;rectangle) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::get_frame_extents           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rectangle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the bounding box of the window, including window manager titlebar/borders if any. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rectangle</em>&nbsp;</td><td>The rectangle to fill with bounding box of the window frame.</td></tr>
  </table>
</dl>
The frame position is given in root window coordinates. To get the position of the window itself (rather than the frame) in root window coordinates, use <a class="el" href="classXfc_1_1Gdk_1_1Window.html#9f1b22bf649fef9b8f58225611f5da44">get_origin()</a>. 
</div>
</div><p>
<a class="anchor" name="1a7a37729368739b3a07581f4a745f3d"></a><!-- doxytag: member="Xfc::Gdk::Window::lookup" ref="1a7a37729368739b3a07581f4a745f3d" args="(GdkNativeWindow anid, const Display *display=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a>* Xfc::Gdk::Window::lookup           </td>
          <td>(</td>
          <td class="paramtype">GdkNativeWindow&nbsp;</td>
          <td class="paramname"> <em>anid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Display</a> *&nbsp;</td>
          <td class="paramname"> <em>display</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> that wraps the given native window handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>anid</em>&nbsp;</td><td>A native pixmap handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>display</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Display</a> corresponding to the window handle, or null for the default display. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> wrapper for the native window, or null if there is none.</dd></dl>
In the X backend, a native window handle is an Xlib XID. 
</div>
</div><p>
<a class="anchor" name="d8ec7bb2f9ac093b1b2d67ad1e92f95e"></a><!-- doxytag: member="Xfc::Gdk::Window::at_pointer" ref="d8ec7bb2f9ac093b1b2d67ad1e92f95e" args="(int *win_x, int *win_y, const Display *display=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a>* Xfc::Gdk::Window::at_pointer           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>win_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>win_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Display</a> *&nbsp;</td>
          <td class="paramname"> <em>display</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the window underneath the mouse pointer on <em>display</em>, returning the location of that window in win_x, win_y. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win_x</em>&nbsp;</td><td>The return location for the X coordinate of the origin of the window under the pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>win_y</em>&nbsp;</td><td>The return location for the Y coordinate of the origin of the window under the pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>display</em>&nbsp;</td><td>The display to use, or null for the default display. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> under the mouse pointer.</dd></dl>
Returns null if the window under the mouse pointer is not known to GDK (if the window belongs to another application and a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> hasn't been created for it with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5c8094a114b957254f509e5de334c6e8">create()</a>). 
</div>
</div><p>
<a class="anchor" name="fd79f7bef1e61993d2c6d19f6e874d99"></a><!-- doxytag: member="Xfc::Gdk::Window::at_pointer" ref="fd79f7bef1e61993d2c6d19f6e874d99" args="(Point &amp;point, const Display *display=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a>* Xfc::Gdk::Window::at_pointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Display</a> *&nbsp;</td>
          <td class="paramname"> <em>display</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the window underneath the mouse pointer on <em>display</em>, returning the location of that window in <em>point</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>The return location for the x, y coordinates of the origin of the window under the pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>display</em>&nbsp;</td><td>The display to use, or null for the default display. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> under the mouse pointer.</dd></dl>
Returns null if the window under the mouse pointer is not known to GDK (if the window belongs to another application and a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> hasn't been created for it with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5c8094a114b957254f509e5de334c6e8">create()</a>). 
</div>
</div><p>
<a class="anchor" name="03aefbe86638b307eaeaf590c877f959"></a><!-- doxytag: member="Xfc::Gdk::Window::get_toplevels" ref="03aefbe86638b307eaeaf590c877f959" args="(std::vector&lt; Window * &gt; &amp;toplevels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Xfc::Gdk::Window::get_toplevels           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>toplevels</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains a list of all toplevel windows known to GDK on the default screen (see get_toplevels_for_screen()). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>toplevels</em>&nbsp;</td><td>A reference to a vector of Window* to hold the list of toplevel windows. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the vector is not empty.</dd></dl>
A toplevel window is a child of the root window (see <a class="el" href="namespaceXfc_1_1Gdk.html#2340089fec0834b7e46352aa59879a6f">Gdk::get_default_root_window()</a>). 
</div>
</div><p>
<a class="anchor" name="ecd34eef21679991cbef2877e89b761f"></a><!-- doxytag: member="Xfc::Gdk::Window::add_filter" ref="ecd34eef21679991cbef2877e89b761f" args="(Window *window, GdkFilterFunc function, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Gdk::Window::add_filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> *&nbsp;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GdkFilterFunc&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an event filter for <em>window</em>, allowing you to intercept events before they reach GDK. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>window</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> to get the events for, or null for all windows. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>The filter callback to call on each event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Data to pass to filter callback.</td></tr>
  </table>
</dl>
This is a low-level operation and makes it easy to break GDK and/or GTK+, so you have to know what you're doing. 
</div>
</div><p>
<a class="anchor" name="3d72515961b48e6c2a116955306e3ed1"></a><!-- doxytag: member="Xfc::Gdk::Window::remove_filter" ref="3d72515961b48e6c2a116955306e3ed1" args="(Window *window, GdkFilterFunc function, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Gdk::Window::remove_filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> *&nbsp;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GdkFilterFunc&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a filter previously added with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#ecd34eef21679991cbef2877e89b761f">add_filter()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>window</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> the filter was added to, or null for all windows. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>The filter callback to call on each event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Data to pass to filter callback. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="72a272b6a99cee4484870642e8a431f7"></a><!-- doxytag: member="Xfc::Gdk::Window::dispose" ref="72a272b6a99cee4484870642e8a431f7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Xfc::Gdk::Window::dispose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys the window system resources associated with the window and decrements window's reference count. 
<p>
The window system resources for all children of window are also destroyed, but the children's reference counts are not decremented.<p>
<b>Note:</b> A <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> will not be destroyed automatically when its reference count reaches zero. You must call this method yourself before that happens. This method is declared virtual for XFC's use only. 
<p>
Reimplemented from <a class="el" href="classXfc_1_1G_1_1Object.html#480842af7bdb77d761ae926b1f5584f7">Xfc::G::Object</a>.
</div>
</div><p>
<a class="anchor" name="f6211ecd7c42c56d4509917a33e9557b"></a><!-- doxytag: member="Xfc::Gdk::Window::show" ref="f6211ecd7c42c56d4509917a33e9557b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::show           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classXfc_1_1Gdk_1_1Window.html#7f842debe336cedca26ac9de41f32a12">show_unraised()</a>, but also raises the window to the top of the window stack (moves the window to the front of the Z-order). 
<p>
This method maps a window so it's visible onscreen. It's opposite is <a class="el" href="classXfc_1_1Gdk_1_1Window.html#fe3a90e84b3d11f2c1d18dc8f38cfb25">hide()</a>.<p>
<b>Note:</b> When implementing a <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a>, you should call this method on the widget's <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> as part of the "map" method. 
</div>
</div><p>
<a class="anchor" name="7f842debe336cedca26ac9de41f32a12"></a><!-- doxytag: member="Xfc::Gdk::Window::show_unraised" ref="7f842debe336cedca26ac9de41f32a12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::show_unraised           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shows a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> onscreen, but does not modify its stacking order. 
<p>
In contrast, <a class="el" href="classXfc_1_1Gdk_1_1Window.html#f6211ecd7c42c56d4509917a33e9557b">show()</a> will raise the window to the top of the window stack. On the X11 platform, in Xlib terms, this function calls XMapWindow() (it also updates some internal GDK state, which means that you can't really use XMapWindow() directly on a GDK window). 
</div>
</div><p>
<a class="anchor" name="fe3a90e84b3d11f2c1d18dc8f38cfb25"></a><!-- doxytag: member="Xfc::Gdk::Window::hide" ref="fe3a90e84b3d11f2c1d18dc8f38cfb25" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::hide           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For toplevel windows, withdraws them, so they will no longer be known to the window manager; for all windows, unmaps them, so they won't be displayed. 
<p>
Normally done automatically as part of <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#18467883235d80a8b6f4b7c61ddbd4a9">Gtk::Widget::hide()</a>. 
</div>
</div><p>
<a class="anchor" name="e537d074ab4037ab60efa9d376220383"></a><!-- doxytag: member="Xfc::Gdk::Window::withdraw" ref="e537d074ab4037ab60efa9d376220383" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::withdraw           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Withdraws the window (unmaps it and asks the window manager to forget about it). 
<p>
This function is not really useful as <a class="el" href="classXfc_1_1Gdk_1_1Window.html#fe3a90e84b3d11f2c1d18dc8f38cfb25">hide()</a> automatically withdraws toplevel windows before hiding them. 
</div>
</div><p>
<a class="anchor" name="90c62a77ca9b76b10e1acd6701b61cc3"></a><!-- doxytag: member="Xfc::Gdk::Window::move" ref="90c62a77ca9b76b10e1acd6701b61cc3" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::move           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Repositions the window relative to its parent window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X coordinate relative to window's parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y coordinate relative to window's parent.</td></tr>
  </table>
</dl>
For toplevel windows, window managers may ignore or modify the move; you should probably use Gtk::Window_move() on a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> widget anyway, instead of using GDK methods. For child windows, the move will reliably succeed. If you're also planning to resize the window, use <a class="el" href="classXfc_1_1Gdk_1_1Window.html#cf892540e58ba72a438013a4fdf0a80a">move_resize()</a> to both move and resize simultaneously, for a nicer visual effect. 
</div>
</div><p>
<a class="anchor" name="226d07e692693b913db0d84913a84e73"></a><!-- doxytag: member="Xfc::Gdk::Window::move" ref="226d07e692693b913db0d84913a84e73" args="(const Point &amp;point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::move           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Point</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Repositions the window relative to its parent window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>The x, y coordinates relative to window's parent.</td></tr>
  </table>
</dl>
For toplevel windows, window managers may ignore or modify the move; you should probably use Gtk::Window_move() on a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> widget anyway, instead of using GDK methods. For child windows, the move will reliably succeed. If you're also planning to resize the window, use <a class="el" href="classXfc_1_1Gdk_1_1Window.html#cf892540e58ba72a438013a4fdf0a80a">move_resize()</a> to both move and resize simultaneously, for a nicer visual effect. 
</div>
</div><p>
<a class="anchor" name="e8a09b435ace3c108af1ad957369bfba"></a><!-- doxytag: member="Xfc::Gdk::Window::resize" ref="e8a09b435ace3c108af1ad957369bfba" args="(int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::resize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resizes the window; for toplevel windows, asks the window manager to resize the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The new width of the window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The new height of the window.</td></tr>
  </table>
</dl>
The window manager may not allow the resize. Use <a class="el" href="classXfc_1_1Gtk_1_1Window.html#45111b49a7d1569a6f3f5b1c6cb9a86a">Gtk::Window::resize()</a> instead of this low-level method. Windows may not be resized below 1x1. If you're also planning to move the window, use <a class="el" href="classXfc_1_1Gdk_1_1Window.html#cf892540e58ba72a438013a4fdf0a80a">move_resize()</a> to both move and resize simultaneously, for a nicer visual effect. 
</div>
</div><p>
<a class="anchor" name="cf892540e58ba72a438013a4fdf0a80a"></a><!-- doxytag: member="Xfc::Gdk::Window::move_resize" ref="cf892540e58ba72a438013a4fdf0a80a" args="(int x, int y, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::move_resize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to calling <a class="el" href="classXfc_1_1Gdk_1_1Window.html#90c62a77ca9b76b10e1acd6701b61cc3">move()</a> and <a class="el" href="classXfc_1_1Gdk_1_1Window.html#e8a09b435ace3c108af1ad957369bfba">resize()</a>, except that both operations are performed at once, avoiding strange visual effects. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X coordinate relative to window's parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y coordinate relative to window's parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The new width of the window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The new height of the window.</td></tr>
  </table>
</dl>
The user may be able to see the window first move, then resize, if you don't use <a class="el" href="classXfc_1_1Gdk_1_1Window.html#cf892540e58ba72a438013a4fdf0a80a">move_resize()</a>. 
</div>
</div><p>
<a class="anchor" name="4568281d46027f09d2a43b4ae63f7a30"></a><!-- doxytag: member="Xfc::Gdk::Window::move_resize" ref="4568281d46027f09d2a43b4ae63f7a30" args="(const Rectangle &amp;rectangle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::move_resize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rectangle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to calling <a class="el" href="classXfc_1_1Gdk_1_1Window.html#90c62a77ca9b76b10e1acd6701b61cc3">move()</a> and <a class="el" href="classXfc_1_1Gdk_1_1Window.html#e8a09b435ace3c108af1ad957369bfba">resize()</a>, except that both operations are performed at once, avoiding strange visual effects. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rectangle</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Gdk::Rectangle</a> holding the new x, y coordinates relative to window's parent, and the new width and height. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="46b4e7ce3f262ffbf17377acd32ba382"></a><!-- doxytag: member="Xfc::Gdk::Window::reparent" ref="46b4e7ce3f262ffbf17377acd32ba382" args="(Window &amp;new_parent, int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::reparent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>new_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reparents the window into the given new_parent. 
<p>
The window being reparented will be unmapped as a side effect. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_parent</em>&nbsp;</td><td>The new parent to move window into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X location inside the new parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y location inside the new parent. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="29011f68dd5dc0b0e5eb61899c5e7093"></a><!-- doxytag: member="Xfc::Gdk::Window::clear_area" ref="29011f68dd5dc0b0e5eb61899c5e7093" args="(int x, int y, int width, int height, bool generate_expose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::clear_area           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>generate_expose</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears an area of the window to the background color or background pixmap. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X coordinate of the origin of rectangle to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y coordinate of the origin of rectangle to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of the rectangle to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of the rectangle to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>generate_expose</em>&nbsp;</td><td>If <em>true</em> generates an expose event for the cleared area. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3ef35f835e18b0b61c20f29c7606ec38"></a><!-- doxytag: member="Xfc::Gdk::Window::clear_area" ref="3ef35f835e18b0b61c20f29c7606ec38" args="(const Rectangle &amp;rectangle, bool generate_expose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::clear_area           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rectangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>generate_expose</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears an area of the window to the background color or background pixmap. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rectangle</em>&nbsp;</td><td>The rectangle to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>generate_expose</em>&nbsp;</td><td>If <em>true</em> generates an expose event for the cleared area. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="deb6bbf6d03a29c747d8203d6eac64ce"></a><!-- doxytag: member="Xfc::Gdk::Window::raise" ref="deb6bbf6d03a29c747d8203d6eac64ce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::raise           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raises the window to the top of the Z-order (stacking order), so that other windows with the same parent window appear below the window. 
<p>
This method works whether or not the windows are visible. If window is a toplevel, the window manager may choose to deny the request to move the window in the Z-order, <a class="el" href="classXfc_1_1Gdk_1_1Window.html#deb6bbf6d03a29c747d8203d6eac64ce">raise()</a> only requests the restack, does not guarantee it. 
</div>
</div><p>
<a class="anchor" name="aad77599b313f0da21aded7742496498"></a><!-- doxytag: member="Xfc::Gdk::Window::lower" ref="aad77599b313f0da21aded7742496498" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::lower           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lowers the window to the bottom of the Z-order (stacking order), so that other windows with the same parent window appear above the window. 
<p>
This is true whether or not the other windows are visible. If the window is a toplevel, the window manager may choose to deny the request to move the window in the Z-order, <a class="el" href="classXfc_1_1Gdk_1_1Window.html#aad77599b313f0da21aded7742496498">lower()</a> only requests the restack, does not guarantee it.<p>
Note that <a class="el" href="classXfc_1_1Gdk_1_1Window.html#f6211ecd7c42c56d4509917a33e9557b">show()</a> raises the window again, so don't call this function before <a class="el" href="classXfc_1_1Gdk_1_1Window.html#f6211ecd7c42c56d4509917a33e9557b">show()</a> (try <a class="el" href="classXfc_1_1Gdk_1_1Window.html#7f842debe336cedca26ac9de41f32a12">show_unraised()</a>). 
</div>
</div><p>
<a class="anchor" name="4a9894aa8812cfe0852981d731f37788"></a><!-- doxytag: member="Xfc::Gdk::Window::focus" ref="4a9894aa8812cfe0852981d731f37788" args="(unsigned int timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::focus           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets keyboard focus to the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>A timestamp of the event triggering the window focus.</td></tr>
  </table>
</dl>
If window is not onscreen this method will not work. In most cases, <a class="el" href="classXfc_1_1Gtk_1_1Window.html#989fb247d36058c20ff009ef3ffe3266">Gtk::Window::present()</a> should be used on a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a>, rather than calling this method. 
</div>
</div><p>
<a class="anchor" name="ed409014442400b9d19e550ecbddc2e9"></a><!-- doxytag: member="Xfc::Gdk::Window::set_user_data" ref="ed409014442400b9d19e550ecbddc2e9" args="(void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_user_data           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For most purposes this method is deprecated in favor of <a class="el" href="classXfc_1_1G_1_1Object.html#b7e610618dfb2e6b7cc27e3c2601752d">G::Object::set_data()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>The user_data.</td></tr>
  </table>
</dl>
For historical reasons GTK+ stores the GtkWidget that owns a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> as user data on the <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>. So, custom widget implementations should use this method for that. If GTK+ receives an event for a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>, and the user data for the window is non-null, GTK+ will assume the user data is a GtkWidget, and forward the event to that widget. 
</div>
</div><p>
<a class="anchor" name="6adc10200b441ab13ba45dcf86265c26"></a><!-- doxytag: member="Xfc::Gdk::Window::set_override_redirect" ref="6adc10200b441ab13ba45dcf86265c26" args="(bool override_redirect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_override_redirect           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>override_redirect</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An override redirect window is not under the control of the window manager (this means it won't have a titlebar, won't be minimizable, etc., it will be entirely under the control of the application). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>override_redirect</em>&nbsp;</td><td><em>true</em> if window should be override redirect.</td></tr>
  </table>
</dl>
The window manager can't see the override redirect window at all. Override redirect should only be used for short-lived temporary windows, such as popup menus. <a class="el" href="classXfc_1_1Gtk_1_1Menu.html">Gtk::Menu</a> uses an override redirect window in its implementation, for example. 
</div>
</div><p>
<a class="anchor" name="36661da73af25e1c3c3de820ce57f9f8"></a><!-- doxytag: member="Xfc::Gdk::Window::set_accept_focus" ref="36661da73af25e1c3c3de820ce57f9f8" args="(bool accept_focus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_accept_focus           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>accept_focus</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setting accept_focus to <em>false</em> hints the desktop environment that the window doesn't want to receive the input focus. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>accept_focus</em>&nbsp;</td><td>Set <em>true</em> if the window should receive input focus.</td></tr>
  </table>
</dl>
On X, it is the responsibility of the window manager to interpret this hint. ICCCM-compliant window managers usually respect it. 
</div>
</div><p>
<a class="anchor" name="1a1bc1302fb39fb38ecf093c9f4d60fe"></a><!-- doxytag: member="Xfc::Gdk::Window::set_focus_on_map" ref="1a1bc1302fb39fb38ecf093c9f4d60fe" args="(bool focus_on_map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_focus_on_map           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>focus_on_map</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setting <em>focus_on_map</em> to false hints the desktop environment that the window doesn't want to receive input focus when it is mapped. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>focus_on_map</em>&nbsp;</td><td>Set to <em>true</em> if the window should receive input focus when mapped.</td></tr>
  </table>
</dl>
The <em>focus_on_map</em> property should be turned off for windows that aren't triggered interactively (such as popups from network activity). On X, it is the responsibility of the window manager to interpret this hint. <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> managers following the freedesktop.org window manager extension specification should respect it. 
</div>
</div><p>
<a class="anchor" name="07de266ceebbff439bb0a5a1424a2c6d"></a><!-- doxytag: member="Xfc::Gdk::Window::scroll" ref="07de266ceebbff439bb0a5a1424a2c6d" args="(int dx, int dy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::scroll           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scroll the contents of window, both pixels and children, by the given amount. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dx</em>&nbsp;</td><td>The amount to scroll in the X direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dy</em>&nbsp;</td><td>The amount to scroll in the Y direction.</td></tr>
  </table>
</dl>
The window itself does not move. Portions of the window that the scroll operation brings in from offscreen areas are invalidated. The invalidated region may be bigger than what would strictly be necessary. (For X11, a minimum area will be invalidated if the window has no subwindows, or if the edges of the window's parent do not extend beyond the edges of the window. In other cases, a multi-step process is used to scroll the window which may produce temporary visual artifacts and unnecessary invalidations.) 
</div>
</div><p>
<a class="anchor" name="df699f5e172fa8255f3a3b334ea9eb26"></a><!-- doxytag: member="Xfc::Gdk::Window::shape_combine_mask" ref="df699f5e172fa8255f3a3b334ea9eb26" args="(Bitmap *shape_mask, int x=0, int y=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::shape_combine_mask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Bitmap</a> *&nbsp;</td>
          <td class="paramname"> <em>shape_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a shaped partially transparent window using a bitmap mask. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shape_mask</em>&nbsp;</td><td>The shape mask, or null to unset a previously set shape mask. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X position of <em>shape_mask</em> with respect to the window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y position of <em>shape_mask</em> with respect to the window.</td></tr>
  </table>
</dl>
Applies <em>shape_mask</em> to the window. Pixels in the window corresponding to set bits in the mask will be visible; pixels in the window corresponding to unset bits in the mask will be transparent. This gives a non-rectangular window. If <em>shape_mask</em> is null, the shape mask will be unset, and the x/y parameters are not used.<p>
On the X11 platform, this uses an X server extension which is widely available on most common platforms, but not available on very old X servers, and occasionally the implementation will be buggy. On servers without the shape extension, this method will do nothing.<p>
<b>Note:</b> This method works on both toplevel and child windows. 
</div>
</div><p>
<a class="anchor" name="418978bd4e112145fa056406d65d9285"></a><!-- doxytag: member="Xfc::Gdk::Window::shape_combine_region" ref="418978bd4e112145fa056406d65d9285" args="(Region *shape_region, int offset_x=0, int offset_y=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::shape_combine_region           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Region.html">Region</a> *&nbsp;</td>
          <td class="paramname"> <em>shape_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset_x</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset_y</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes pixels in the window outside <em>shape_region</em> be transparent, so that the window may be non-rectangular (see also <a class="el" href="classXfc_1_1Gdk_1_1Window.html#df699f5e172fa8255f3a3b334ea9eb26">shape_combine_mask()</a> to use a bitmap as the mask. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shape_region</em>&nbsp;</td><td>The region of the window to be non-transparent, or null to unset a previously set <em>shape_region</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_x</em>&nbsp;</td><td>The X position of <em>shape_region</em> in window coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_y</em>&nbsp;</td><td>The Y position of <em>shape_region</em> in window coordinates.</td></tr>
  </table>
</dl>
If <em>shape_region</em> is null, the shape will be unset, so the whole window will be opaque again. <em>offset_x</em> and <em>offset_y</em> are ignored if <em>shape_region</em> is null.<p>
On the X11 platform, this uses an X server extension which is widely available on most common platforms, but not available on very old X servers, and occasionally the implementation will be buggy. On servers without the shape extension, this method will do nothing.<p>
<b>Note:</b> This method works on both toplevel and child windows. 
</div>
</div><p>
<a class="anchor" name="bf03f60968fce7768b1603b7c5c8411e"></a><!-- doxytag: member="Xfc::Gdk::Window::set_child_shapes" ref="bf03f60968fce7768b1603b7c5c8411e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_child_shapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the shape mask of the window to the union of shape masks for all children of the window, ignoring the shape mask of the window itself. 
<p>
Contrast with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5b85036c5bc9da46de329bfae5eb9b7a">merge_child_shapes()</a> which includes the shape mask of the window in the masks to be merged. This method quickly takes the shapes of all the child windows and uses their shapes as the shape mask for this window. 
</div>
</div><p>
<a class="anchor" name="5b85036c5bc9da46de329bfae5eb9b7a"></a><!-- doxytag: member="Xfc::Gdk::Window::merge_child_shapes" ref="5b85036c5bc9da46de329bfae5eb9b7a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::merge_child_shapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merges the shape masks for any child windows into the shape mask for this window (that is, the union of all masks for the window and its children will become the new mask for window (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#df699f5e172fa8255f3a3b334ea9eb26">shape_combine_mask()</a>). 
<p>
This method is distinct from <a class="el" href="classXfc_1_1Gdk_1_1Window.html#bf03f60968fce7768b1603b7c5c8411e">set_child_shapes()</a> because it includes window's shape mask in the set of shapes to be merged. 
</div>
</div><p>
<a class="anchor" name="b29d95ff4110d0bc2980ab2aafd4bcd5"></a><!-- doxytag: member="Xfc::Gdk::Window::set_static_gravities" ref="b29d95ff4110d0bc2980ab2aafd4bcd5" args="(bool use_static)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gdk::Window::set_static_gravities           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_static</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the bit gravity of the window to static and flag it so all children get static subwindow gravity. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>use_static</em>&nbsp;</td><td>set <em>true</em> to turn on static gravity. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the server supports static gravity.</dd></dl>
This is used if you are implementing scary features that involve deep knowledge of the windowing system. Don't worry about it unless you have to. 
</div>
</div><p>
<a class="anchor" name="5db69418b80b20c127e26faf1c92d54d"></a><!-- doxytag: member="Xfc::Gdk::Window::set_type_hint" ref="5db69418b80b20c127e26faf1c92d54d" args="(WindowTypeHint hint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_type_hint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#7bc9d7170459002f90922e5ece04678c">WindowTypeHint</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The application can use this call to provide a hint to the window manager about the functionality of the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hint</em>&nbsp;</td><td>A hint of the function this window will have.</td></tr>
  </table>
</dl>
The window manager can use this information when determining the decoration and behaviour of the window. The hint must be set before the window is mapped. 
</div>
</div><p>
<a class="anchor" name="c18ae5fb58ff4250fef3790d5c6691f1"></a><!-- doxytag: member="Xfc::Gdk::Window::set_modal_hint" ref="c18ae5fb58ff4250fef3790d5c6691f1" args="(bool modal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_modal_hint           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>modal</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The application can use this hint to tell the window manager that a certain window has modal behaviour. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>modal</em>&nbsp;</td><td>Set <em>true</em> if the window is modal, <em>false</em> otherwise.</td></tr>
  </table>
</dl>
The window manager can use this information to handle modal windows in a special way. You should only use this on windows for which you have previously called <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3ea47db108882e7c5be3e48a6ae2d995">set_transient_for()</a>. 
</div>
</div><p>
<a class="anchor" name="f3082611e8880b58db3b0c4ff0ce2a32"></a><!-- doxytag: member="Xfc::Gdk::Window::set_skip_taskbar_hint" ref="f3082611e8880b58db3b0c4ff0ce2a32" args="(bool skips_taskbar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_skip_taskbar_hint           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>skips_taskbar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles whether the window should appear in a task list or window list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>skips_taskbar</em>&nbsp;</td><td>Set <em>true</em> to skip the taskbar.</td></tr>
  </table>
</dl>
If a window's semantic type as specified with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5db69418b80b20c127e26faf1c92d54d">set_type_hint()</a> already fully describes the window, this method should NOT be called in addition, instead you should allow the window to be treated according to standard policy for its semantic type. 
</div>
</div><p>
<a class="anchor" name="00993b332474ff81b6bb7a1941018d59"></a><!-- doxytag: member="Xfc::Gdk::Window::set_skip_pager_hint" ref="00993b332474ff81b6bb7a1941018d59" args="(bool skips_pager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_skip_pager_hint           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>skips_pager</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles whether the window should appear in a pager (workspace switcher, or other desktop utility program that displays a small thumbnail representation of the windows on the desktop). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>skips_pager</em>&nbsp;</td><td>Set <em>true</em> to skip the pager.</td></tr>
  </table>
</dl>
If a window's semantic type as specified with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5db69418b80b20c127e26faf1c92d54d">set_type_hint()</a> already fully describes the window, this function should NOT be called in addition, instead you should allow the window to be treated according to standard policy for its semantic type. 
</div>
</div><p>
<a class="anchor" name="08725a29b9d49322ba77d2eeb773364a"></a><!-- doxytag: member="Xfc::Gdk::Window::set_geometry_hints" ref="08725a29b9d49322ba77d2eeb773364a" args="(const Geometry *geometry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_geometry_hints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Geometry.html">Geometry</a> *&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the geometry hints for the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geometry</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Geometry.html">Geometry</a> object containing geometry information, or null to unset all hints.</td></tr>
  </table>
</dl>
<a class="el" href="classXfc_1_1Gdk_1_1Geometry.html">Geometry</a> hints not specifically set in geometry will be unset. To unset all hints pass a geometry of null.<p>
This method provides hints to the windowing system about acceptable sizes for a toplevel window. The purpose of this is to constrain user resizing, but the windowing system will typically (but is not required to) also constrain the current size of the window to the provided values and constrain programatic resizing via <a class="el" href="classXfc_1_1Gdk_1_1Window.html#e8a09b435ace3c108af1ad957369bfba">resize()</a> or <a class="el" href="classXfc_1_1Gdk_1_1Window.html#cf892540e58ba72a438013a4fdf0a80a">move_resize()</a>.<p>
Note that on X11, this effect has no effect on windows of type WINDOW_TEMP or windows where override_redirect has been turned on via <a class="el" href="classXfc_1_1Gdk_1_1Window.html#6adc10200b441ab13ba45dcf86265c26">set_override_redirect()</a> since these windows are not resizable by the user.<p>
Since you can't count on the windowing system doing the constraints for programmatic resizes, you should generally call <a class="el" href="classXfc_1_1Gdk_1_1Geometry.html#bb897d7bdcd56769108e333e466e94b0">Gdk::Geometry::constrain_size()</a> yourself to determine appropriate sizes. 
</div>
</div><p>
<a class="anchor" name="2de04b3845df711ee41d5a8de7b7b951"></a><!-- doxytag: member="Xfc::Gdk::Window::begin_paint" ref="2de04b3845df711ee41d5a8de7b7b951" args="(const Rectangle &amp;rectangle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::begin_paint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rectangle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates that you are beginning the process of redrawing a rectangular region. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rectangle</em>&nbsp;</td><td>The rectangualr region you intend to draw to.</td></tr>
  </table>
</dl>
This method is a convenience wrapper around <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3ea3ffce5cd2dc6957bfaaaea93b4d27">begin_paint(const Region&amp;)</a>) which creates a rectangular region for you. 
</div>
</div><p>
<a class="anchor" name="3ea3ffce5cd2dc6957bfaaaea93b4d27"></a><!-- doxytag: member="Xfc::Gdk::Window::begin_paint" ref="3ea3ffce5cd2dc6957bfaaaea93b4d27" args="(const Region &amp;region)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::begin_paint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Region.html">Region</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates that you are beginning the process of redrawing region. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>The region you intend to draw to.</td></tr>
  </table>
</dl>
A backing store (offscreen buffer) large enough to contain region will be created. The backing store will be initialized with the background color or background pixmap for the window. Then, all drawing operations performed on window will be diverted to the backing store. When you call <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0d2820164c0fdcc29ba8e95625f74bc0">end_paint()</a>, the backing store will be copied to the window, making it visible onscreen. Only the part of the window contained in the region will be modified; that is, drawing operations are clipped to the region. The net result of all this is to remove flicker, because the user sees the finished product appear all at once when you call <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0d2820164c0fdcc29ba8e95625f74bc0">end_paint()</a>. If you draw to the window directly without calling <a class="el" href="classXfc_1_1Gdk_1_1Window.html#2de04b3845df711ee41d5a8de7b7b951">begin_paint()</a>, the user may see flicker as individual drawing operations are performed in sequence. The clipping and background-initializing features of <a class="el" href="classXfc_1_1Gdk_1_1Window.html#2de04b3845df711ee41d5a8de7b7b951">begin_paint()</a> are conveniences for the programmer, so you can avoid doing that work yourself.<p>
The GTK+ widget system automatically places calls to <a class="el" href="classXfc_1_1Gdk_1_1Window.html#2de04b3845df711ee41d5a8de7b7b951">begin_paint()</a> and <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0d2820164c0fdcc29ba8e95625f74bc0">end_paint()</a> around emissions of the <em>expose_event</em> signal. That is, if you're writing an expose event handler, you can assume that the exposed area in <a class="el" href="classXfc_1_1Gdk_1_1EventExpose.html">Gdk::EventExpose</a> has already been cleared to the window background, is already set as the clip region, and already has a backing store. Therefore in most cases, application code need not call <a class="el" href="classXfc_1_1Gdk_1_1Window.html#2de04b3845df711ee41d5a8de7b7b951">begin_paint()</a>. You can disable the automatic calls around expose events on a widget-by-widget basis by calling <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#46da3ae55128596cbd64744859fd35a5">Gtk::Widget::set_double_buffered()</a>.<p>
If you call this method multiple times before calling the matching <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0d2820164c0fdcc29ba8e95625f74bc0">end_paint()</a>, the backing stores are pushed onto a stack. <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0d2820164c0fdcc29ba8e95625f74bc0">end_paint()</a> copies the topmost backing store onscreen, subtracts the topmost region from all other regions in the stack, and pops the stack. All drawing operations affect only the topmost backing store in the stack. One matching call to <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0d2820164c0fdcc29ba8e95625f74bc0">end_paint()</a> is required for each call to <a class="el" href="classXfc_1_1Gdk_1_1Window.html#2de04b3845df711ee41d5a8de7b7b951">begin_paint()</a>. 
</div>
</div><p>
<a class="anchor" name="0d2820164c0fdcc29ba8e95625f74bc0"></a><!-- doxytag: member="Xfc::Gdk::Window::end_paint" ref="0d2820164c0fdcc29ba8e95625f74bc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::end_paint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates that the backing store created by the most recent call to <a class="el" href="classXfc_1_1Gdk_1_1Window.html#2de04b3845df711ee41d5a8de7b7b951">begin_paint()</a> should be copied onscreen and deleted, leaving the next-most-recent backing store or no backing store at all as the active paint region (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3ea3ffce5cd2dc6957bfaaaea93b4d27">begin_paint(const Region&amp;)</a> for full details). 
<p>
It is an error to call this method without a matching <a class="el" href="classXfc_1_1Gdk_1_1Window.html#2de04b3845df711ee41d5a8de7b7b951">begin_paint()</a> first. 
</div>
</div><p>
<a class="anchor" name="1304aa01e60fa40c88178aede0d856a6"></a><!-- doxytag: member="Xfc::Gdk::Window::set_title" ref="1304aa01e60fa40c88178aede0d856a6" args="(const String &amp;title)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_title           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>title</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the title of a toplevel window, to be displayed in the titlebar. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>title</em>&nbsp;</td><td>The title of the window.</td></tr>
  </table>
</dl>
If you haven't explicitly set the icon name for the window (using set_icon_name()), the icon name will be set to title as well. 
</div>
</div><p>
<a class="anchor" name="3facbf4b9bf39b9537a78b733bba8cc1"></a><!-- doxytag: member="Xfc::Gdk::Window::set_role" ref="3facbf4b9bf39b9537a78b733bba8cc1" args="(const String &amp;role)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_role           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>role</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Typically you should use Gtk::Window::set_role() instead of this low-level method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>role</em>&nbsp;</td><td>A string indicating its role.</td></tr>
  </table>
</dl>
The window manager and session manager use a window's role to distinguish it from other kinds of window in the same application. When an application is restarted after being saved in a previous session, all windows with the same title and role are treated as interchangeable. So if you have two windows with the same title that should be distinguished for session management purposes, you should set the role on those windows. It doesn't matter what string you use for the role, as long as you have a different role for each non-interchangeable kind of window. 
</div>
</div><p>
<a class="anchor" name="3ea47db108882e7c5be3e48a6ae2d995"></a><!-- doxytag: member="Xfc::Gdk::Window::set_transient_for" ref="3ea47db108882e7c5be3e48a6ae2d995" args="(Window &amp;parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_transient_for           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates to the window manager that window is a transient dialog associated with the application window parent. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Another toplevel <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>.</td></tr>
  </table>
</dl>
This allows the window manager to do things like center window on parent and keep window above parent. See <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c0784ba51aebb9dc07972a40776f8dc5">Gtk::Window::set_transient_for()</a> if you're using <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> or <a class="el" href="classXfc_1_1Gtk_1_1Dialog.html">Gtk::Dialog</a>. 
</div>
</div><p>
<a class="anchor" name="bd83a705094053c926e2bcbe14c77aec"></a><!-- doxytag: member="Xfc::Gdk::Window::set_background" ref="bd83a705094053c926e2bcbe14c77aec" args="(const Color &amp;color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_background           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Color.html">Color</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>color</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the background color of the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>An allocated <a class="el" href="classXfc_1_1Gdk_1_1Color.html">Color</a>.</td></tr>
  </table>
</dl>
When using a <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a>, set the background of the widget with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fb887de4c1f3424b9c5a9f245bd2910f">Gtk::Widget::modify_bg()</a> if you're an application, or <a class="el" href="classXfc_1_1Gtk_1_1Style.html#43b8ddacb65436be9115f19fa6a72347">Gtk::Style::set_background()</a> if you're implementing a custom widget. The color must be allocated; <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html#8d6788680dff7870573e6f7fb0538251">Gdk::Colormap::rgb_find_color()</a> is the best way to allocate a color. See also <a class="el" href="classXfc_1_1Gdk_1_1Window.html#68f91a87b5526231af9b2b740c9d9e7f">set_back_pixmap()</a>. 
</div>
</div><p>
<a class="anchor" name="68f91a87b5526231af9b2b740c9d9e7f"></a><!-- doxytag: member="Xfc::Gdk::Window::set_back_pixmap" ref="68f91a87b5526231af9b2b740c9d9e7f" args="(Pixmap *pixmap, bool parent_relative=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_back_pixmap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Pixmap.html">Pixmap</a> *&nbsp;</td>
          <td class="paramname"> <em>pixmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>parent_relative</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the background pixmap of the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixmap</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Pixmap.html">Pixmap</a>, or null for no background. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent_relative</em>&nbsp;</td><td>Whether the tiling origin is at the origin of window's parent.</td></tr>
  </table>
</dl>
To set a background of "None" on the window, set a background pixmap of null. A background pixmap will be tiled, positioning the first tile at the origin of the window, or if parent_relative is true, the tiling will be done based on the origin of the parent window (useful to align tiles in a parent with tiles in a child).<p>
A background pixmap of null means that the window will have no background. A window with no background will never have its background filled by the windowing system, instead the window will contain whatever pixels were already in the corresponding area of the display. The windowing system will normally fill a window with its background when the window is obscured then exposed, and when you call <a class="el" href="classXfc_1_1Gdk_1_1Window.html#036f01ec31a68d1354f3fc7d8b0d7e39">clear()</a>. 
</div>
</div><p>
<a class="anchor" name="1adaa48a8575a541069f9a1036098574"></a><!-- doxytag: member="Xfc::Gdk::Window::set_cursor" ref="1adaa48a8575a541069f9a1036098574" args="(const Cursor &amp;cursor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_cursor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Cursor.html">Cursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mouse pointer for the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cursor</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Cursor.html">Cursor</a>.</td></tr>
  </table>
</dl>
By default, most windows use the cursor of its parent window. 
</div>
</div><p>
<a class="anchor" name="7c446d6bac000bfb2e4bcc3bc80552a2"></a><!-- doxytag: member="Xfc::Gdk::Window::set_events" ref="7c446d6bac000bfb2e4bcc3bc80552a2" args="(EventMaskField event_mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_events           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">EventMaskField</a>&nbsp;</td>
          <td class="paramname"> <em>event_mask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the event mask for the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event_mask</em>&nbsp;</td><td>The event mask for the window.</td></tr>
  </table>
</dl>
The event mask for a window determines which events will be reported for that window. For example, an event mask including BUTTON_PRESS_MASK means the window should report button press events. The event mask is the bitwise OR of values from the EventMask enumeration. 
</div>
</div><p>
<a class="anchor" name="c3876454f2add79fa8566c72c00251cc"></a><!-- doxytag: member="Xfc::Gdk::Window::set_icon_list" ref="c3876454f2add79fa8566c72c00251cc" args="(const std::vector&lt; Pixbuf * &gt; &amp;pixbufs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_icon_list           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Pixbuf</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pixbufs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a list of icons for the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixbufs</em>&nbsp;</td><td>A reference to a vector of Pixbuf* that holds a list of pixbufs, of different sizes.</td></tr>
  </table>
</dl>
One of these will be used to represent the window when it has been iconified. The icon is usually shown in an icon box or some sort of task bar. Which icon size is shown depends on the window manager. The window manager can scale the icon but setting several size icons can give better image quality since the window manager may only need to scale the icon by a small amount or not at all. 
</div>
</div><p>
<a class="anchor" name="e2070842284647d99c2cc5395786a917"></a><!-- doxytag: member="Xfc::Gdk::Window::set_icon" ref="e2070842284647d99c2cc5395786a917" args="(Pixmap *pixmap, Bitmap *mask, Window *icon_window=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_icon           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Pixmap.html">Pixmap</a> *&nbsp;</td>
          <td class="paramname"> <em>pixmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Bitmap</a> *&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> *&nbsp;</td>
          <td class="paramname"> <em>icon_window</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the icon of the window as a pixmap or window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>icon_window</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> to use for the icon, or null to unset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixmap</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Pixmap.html">Pixmap</a> to use as the icon, or null to unset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>A 1-bit pixmap (<a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Gdk::Bitmap</a>) to use as mask for pixmap, or null for none.</td></tr>
  </table>
</dl>
Investigate <a class="el" href="classXfc_1_1Gtk_1_1Window.html#dde1c4f76c6ad7fad676fb88a7233409">Gtk::Window::set_default_icon_list()</a> first, and then <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">Gtk::Window::set_icon_list()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7c5750ac3f8bb3d268d6bad8f8209a95">Gtk::Window::set_icon()</a>. If those don't meet your needs, look at <a class="el" href="classXfc_1_1Gdk_1_1Window.html#c3876454f2add79fa8566c72c00251cc">Gdk::Window::set_icon_list()</a>. Only if all those are too high-level do you want to fall back to <a class="el" href="classXfc_1_1Gdk_1_1Window.html#e2070842284647d99c2cc5395786a917">set_icon()</a>. 
</div>
</div><p>
<a class="anchor" name="3b6aefd8ff8f22e29d996b211ed0417d"></a><!-- doxytag: member="Xfc::Gdk::Window::set_icon_name" ref="3b6aefd8ff8f22e29d996b211ed0417d" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_icon_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Windows may have a name used while minimized, distinct from the name they display in their titlebar. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of window while iconified (minimized).</td></tr>
  </table>
</dl>
Most of the time this is a bad idea from a user interface standpoint. But you can set such a name with this method, if you like. 
</div>
</div><p>
<a class="anchor" name="773b296b3ce236c7e349772b832fb8d3"></a><!-- doxytag: member="Xfc::Gdk::Window::set_group" ref="773b296b3ce236c7e349772b832fb8d3" args="(Window &amp;leader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_group           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>leader</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the group leader window for the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leader</em>&nbsp;</td><td>The group leader window.</td></tr>
  </table>
</dl>
By default, GDK sets the group leader for all toplevel windows to a global window implicitly created by GDK. With this function you can override this default. The group leader window allows the window manager to distinguish all windows that belong to a single application. It may for example allow users to minimize/unminimize all windows belonging to an application at once. You should only set a non-default group window if your application pretends to be multiple applications. The group leader window may not be changed after a window has been mapped (with <a class="el" href="classXfc_1_1Gdk_1_1Window.html#f6211ecd7c42c56d4509917a33e9557b">show()</a> for example). 
</div>
</div><p>
<a class="anchor" name="8a41f0eb92974324b17942b2dae52761"></a><!-- doxytag: member="Xfc::Gdk::Window::set_decorations" ref="8a41f0eb92974324b17942b2dae52761" args="(WMDecorationField decorations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_decorations           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#87db3b9f39ef0c2d4e996b4dbaed5fdb">WMDecorationField</a>&nbsp;</td>
          <td class="paramname"> <em>decorations</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
"Decorations" are the features the window manager adds to a toplevel <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>decorations</em>&nbsp;</td><td>The <a class="el" href="namespaceXfc_1_1Gdk.html#3bd329235da47b9706518873a473b779">Gdk::WMDecoration</a> hint mask.</td></tr>
  </table>
</dl>
This method sets the traditional Motif window manager hints that tell the window manager which decorations you would like your window to have. Usually you should use <a class="el" href="classXfc_1_1Gtk_1_1Window.html#bdad0041d92dcf049c92d16747220140">Gtk::Window::set_decorated()</a> on a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> instead of using this GDK method.<p>
The decorations argument is the logical OR of the fields in the WMDecoration enumeration. If DECOR_ALL is included in the mask, the other bits indicate which decorations should be turned off. If DECOR_ALL is not included, then the other bits indicate which decorations should be turned on.<p>
Most window managers honor a decorations hint of 0 to disable all decorations, but very few honor all possible combinations of bits. 
</div>
</div><p>
<a class="anchor" name="577771b2da679d9d9886ee398d248270"></a><!-- doxytag: member="Xfc::Gdk::Window::set_functions" ref="577771b2da679d9d9886ee398d248270" args="(WMFunctionField functions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_functions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#6ca3bc981cb74955ac51d5b4bff609b6">WMFunctionField</a>&nbsp;</td>
          <td class="paramname"> <em>functions</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the traditional Motif window manager hint for which operations the window manager should allow on a toplevel window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functions</em>&nbsp;</td><td>The <a class="el" href="namespaceXfc_1_1Gdk.html#a9310813db75989d2a4beb5a91a352a5">Gdk::WMFunction</a> bitmask of operations to allow on the window.</td></tr>
  </table>
</dl>
This method isn't really good for much. Few window managers do anything reliable or interesting with this hint. Many ignore it entirely.<p>
The functions argument is the logical OR of values from the GdkWMFunction enumeration. If the bitmask includes FUNC_ALL, then the other bits indicate which functions to disable; if it doesn't include FUNC_ALL, it indicates which functions to enable. 
</div>
</div><p>
<a class="anchor" name="172e208474427b0b5926863f748a7c80"></a><!-- doxytag: member="Xfc::Gdk::Window::iconify" ref="172e208474427b0b5926863f748a7c80" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::iconify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to iconify (minimize) the window. 
<p>
The window manager may choose to ignore the request, but normally will honor it. Using <a class="el" href="classXfc_1_1Gtk_1_1Window.html#f08e9d7463a7fd859fe76f4b52c6a03a">Gtk::Window::iconify()</a> is preferred, if you have a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> widget. This method only makes sense when the window is a toplevel window. 
</div>
</div><p>
<a class="anchor" name="e77228302a4743b942c3ee36df8e1bbd"></a><!-- doxytag: member="Xfc::Gdk::Window::deiconify" ref="e77228302a4743b942c3ee36df8e1bbd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::deiconify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to deiconify (unminimize) the window. 
<p>
On X11 the window manager may choose to ignore the request to deiconify. Using <a class="el" href="classXfc_1_1Gtk_1_1Window.html#5c6cdd7a8cd195a8a52b7fc97b8c8dac">Gtk::Window::deiconify()</a> instead of the <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> variant is preferred. Or better yet, you probably want to use <a class="el" href="classXfc_1_1Gtk_1_1Window.html#989fb247d36058c20ff009ef3ffe3266">Gtk::Window::present()</a>, which raises the window, focuses it, unminimizes it, and puts it on the current desktop. 
</div>
</div><p>
<a class="anchor" name="0b020abd689bf153123872b874eb9077"></a><!-- doxytag: member="Xfc::Gdk::Window::stick" ref="0b020abd689bf153123872b874eb9077" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::stick           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
"Pins" the window such that it's on all workspaces and does not scroll with viewports, for window managers that have scrollable viewports. 
<p>
When using <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a>, <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0ddf327ef5eaca7e1d3544a51a07d4b6">Gtk::Window::stick()</a> may be more useful. On the X11 platform, this method depends on window manager support, so may have no effect with many window managers. However, GDK will do the best it can to convince the window manager to stick the window. For window managers that don't support this operation, there's nothing you can do to force it to happen. 
</div>
</div><p>
<a class="anchor" name="319a5ad6ce2ebf23d65fc073c2a6da5c"></a><!-- doxytag: member="Xfc::Gdk::Window::maximize" ref="319a5ad6ce2ebf23d65fc073c2a6da5c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::maximize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximizes the window. 
<p>
If the window was already maximized, then this method does nothing. On X11, asks the window manager to maximize window, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "maximized"; so you can't rely on the maximization actually happening. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen. 
</div>
</div><p>
<a class="anchor" name="8443b27c8d2f75bd2ad50508ce876a2d"></a><!-- doxytag: member="Xfc::Gdk::Window::unmaximize" ref="8443b27c8d2f75bd2ad50508ce876a2d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::unmaximize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unmaximizes the window. 
<p>
If the window wasn't maximized, then this method does nothing. On X11, asks the window manager to unmaximize window, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "maximized"; so you can't rely on the unmaximization actually happening. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen. 
</div>
</div><p>
<a class="anchor" name="34a2d439d0a55c7bc529a939f14ae8d0"></a><!-- doxytag: member="Xfc::Gdk::Window::fullscreen" ref="34a2d439d0a55c7bc529a939f14ae8d0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::fullscreen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the window into fullscreen mode. 
<p>
This means the window covers the entire screen and is above any panels or task bars. If the window was already fullscreen, then this function does nothing. On X11, asks the window manager to put window in a fullscreen state, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "fullscreen"; so you can't rely on the fullscreenification actually happening. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen. 
</div>
</div><p>
<a class="anchor" name="fc372a5fec6da91874b470ac026830bf"></a><!-- doxytag: member="Xfc::Gdk::Window::unfullscreen" ref="fc372a5fec6da91874b470ac026830bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::unfullscreen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the window out of fullscreen mode. 
<p>
If the window was not fullscreen, does nothing. On X11, asks the window manager to move window out of the fullscreen state, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "fullscreen"; so you can't rely on the unfullscreenification actually happening. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen. 
</div>
</div><p>
<a class="anchor" name="ba85a872fcbe8ea17da5e538935e4ce2"></a><!-- doxytag: member="Xfc::Gdk::Window::set_keep_above" ref="ba85a872fcbe8ea17da5e538935e4ce2" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_keep_above           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set if the window must be kept above other windows. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Whether to keep the window above other windows.</td></tr>
  </table>
</dl>
If the window was already above, then this function does nothing. On X11, this method asks the window manager to keep the window above, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "keep above"; so you can't rely on the window being kept above. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen. 
</div>
</div><p>
<a class="anchor" name="265cf94e1998441ef184a38fa77ed1a0"></a><!-- doxytag: member="Xfc::Gdk::Window::set_keep_below" ref="265cf94e1998441ef184a38fa77ed1a0" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_keep_below           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set if the window must be kept below other windows. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Whether to keep the window below other windows.</td></tr>
  </table>
</dl>
If the window was already below, then this function does nothing. On X11, this method asks the window manager to keep window below, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "keep below"; so you can't rely on the window being kept below. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen. 
</div>
</div><p>
<a class="anchor" name="dc407eb56aff778e0180c699be5dbf37"></a><!-- doxytag: member="Xfc::Gdk::Window::begin_resize_drag" ref="dc407eb56aff778e0180c699be5dbf37" args="(WindowEdge edge, int button, int root_x, int root_y, unsigned int timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::begin_resize_drag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#0e823b84cf97c36c12abce34415e9e39">WindowEdge</a>&nbsp;</td>
          <td class="paramname"> <em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a window resize operation (for a toplevel window). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge</em>&nbsp;</td><td>The edge or corner from which the drag is started. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>button</em>&nbsp;</td><td>The button being used to drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_x</em>&nbsp;</td><td>The root window X coordinate of the mouse click that began the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_y</em>&nbsp;</td><td>The root window Y coordinate of the mouse click that began the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>Timestamp of the mouse click that began the drag (use <a class="el" href="classXfc_1_1Gdk_1_1Event.html#ac5338503e8ee44702c595b2f7af7004">Gdk::Event::get_time()</a>).</td></tr>
  </table>
</dl>
You might use this method to implement a "window resize grip," for example; in fact <a class="el" href="classXfc_1_1Gtk_1_1Statusbar.html">Gtk::Statusbar</a> uses it. The method works best with window managers that support the Extended <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> Manager Hints spec (see <a href="http://www.freedesktop.org">http://www.freedesktop.org</a>), but has a fallback implementation for other window managers. 
</div>
</div><p>
<a class="anchor" name="092e8c816b414076e0618816c0aeab16"></a><!-- doxytag: member="Xfc::Gdk::Window::begin_move_drag" ref="092e8c816b414076e0618816c0aeab16" args="(int button, int root_x, int root_y, unsigned int timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::begin_move_drag           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a window move operation (for a toplevel window). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>button</em>&nbsp;</td><td>The button being used to drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_x</em>&nbsp;</td><td>The root window X coordinate of the mouse click that began the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_y</em>&nbsp;</td><td>The root window Y coordinate of the mouse click that began the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>The timestamp of the mouse click that began the drag.</td></tr>
  </table>
</dl>
You might use this method to implement a "window move grip," for example. The method works best with window managers that support the Extended <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> Manager Hints spec (see <a href="http://www.freedesktop.org">http://www.freedesktop.org</a>), but has a fallback implementation for other window managers. 
</div>
</div><p>
<a class="anchor" name="c339f7f349b7213e85d02a7e81ecb7b2"></a><!-- doxytag: member="Xfc::Gdk::Window::invalidate" ref="c339f7f349b7213e85d02a7e81ecb7b2" args="(const Rectangle &amp;rectangle, bool invalidate_children)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::invalidate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rectangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>invalidate_children</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <em>rectangle</em> to the update area for the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rectangle</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Rectangle</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>invalidate_children</em>&nbsp;</td><td>Set <em>true</em> to also invalidate child windows.</td></tr>
  </table>
</dl>
This method is a convenience wrapper around <a class="el" href="classXfc_1_1Gdk_1_1Window.html#97e405dab8885c0bd80f3d134bff2eba">invalidate(const Region&amp;, bool)</a> which invalidates a rectangular region. 
</div>
</div><p>
<a class="anchor" name="97e405dab8885c0bd80f3d134bff2eba"></a><!-- doxytag: member="Xfc::Gdk::Window::invalidate" ref="97e405dab8885c0bd80f3d134bff2eba" args="(const Region &amp;region, bool invalidate_children)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::invalidate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Region.html">Region</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>invalidate_children</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <em>region</em> to the update area for the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Region.html">Region</a> to invalidate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>invalidate_children</em>&nbsp;</td><td>Set <em>true</em> to also invalidate child windows.</td></tr>
  </table>
</dl>
The update area is the region that needs to be redrawn, or "dirty region." The call <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5250420ef05e8ed00cee17450263a6b4">process_updates()</a> sends one or more expose events to the window, which together cover the entire update area. An application would normally redraw the contents of the window in response to those expose events.<p>
GDK will call <a class="el" href="classXfc_1_1Gdk_1_1Window.html#bfcda13fe554d94ad90555c8a4a4332e">process_all_updates()</a> on your behalf whenever your program returns to the main loop and becomes idle, so normally there's no need to do that manually, you just need to invalidate regions that you know should be redrawn.<p>
The <em>invalidate_children</em> parameter controls whether the region of each child window that intersects region will also be invalidated. If false, then the update area for child windows will remain unaffected. See gdk_window_invalidate_maybe_recurse() if you need fine grained control over which children are invalidated. 
</div>
</div><p>
<a class="anchor" name="cdb0211dde80aac9fbd6f128ca6b1eea"></a><!-- doxytag: member="Xfc::Gdk::Window::freeze_updates" ref="cdb0211dde80aac9fbd6f128ca6b1eea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::freeze_updates           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Temporarily freezes a window such that it won't receive expose events. 
<p>
The window will begin receiving expose events again when <a class="el" href="classXfc_1_1Gdk_1_1Window.html#44ca52d2e727b9042ac69c822674691d">thaw_updates()</a> is called. If <a class="el" href="classXfc_1_1Gdk_1_1Window.html#cdb0211dde80aac9fbd6f128ca6b1eea">freeze_updates()</a> has been called more than once, <a class="el" href="classXfc_1_1Gdk_1_1Window.html#44ca52d2e727b9042ac69c822674691d">thaw_updates()</a> must be called an equal number of times to begin processing exposes. 
</div>
</div><p>
<a class="anchor" name="5250420ef05e8ed00cee17450263a6b4"></a><!-- doxytag: member="Xfc::Gdk::Window::process_updates" ref="5250420ef05e8ed00cee17450263a6b4" args="(bool update_children)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::process_updates           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>update_children</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends one or more expose events to the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>update_children</em>&nbsp;</td><td>Whether to also process updates for child windows.</td></tr>
  </table>
</dl>
The areas in each expose event will cover the entire update area for the window (see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#97e405dab8885c0bd80f3d134bff2eba">invalidate(const Region&amp;, bool)</a> for details). Normally GDK calls <a class="el" href="classXfc_1_1Gdk_1_1Window.html#bfcda13fe554d94ad90555c8a4a4332e">process_all_updates()</a> on your behalf, so there's no need to call this function unless you want to force expose events to be delivered immediately and synchronously (vs. the usual case, where GDK delivers them in an idle handler). Occasionally this is useful to produce nicer scrolling behavior, for example. 
</div>
</div><p>
<a class="anchor" name="7ac6128a4ce529f83ce358961362acbe"></a><!-- doxytag: member="Xfc::Gdk::Window::set_debug_updates" ref="7ac6128a4ce529f83ce358961362acbe" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_debug_updates           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
With update debugging enabled, calls to <a class="el" href="classXfc_1_1Gdk_1_1Window.html#97e405dab8885c0bd80f3d134bff2eba">invalidate(const Region&amp;, bool)</a> clear the invalidated region of the screen to a noticeable color, and GDK pauses for a short time before sending exposes to windows during <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5250420ef05e8ed00cee17450263a6b4">process_updates()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Set <em>true</em> to turn on update debugging.</td></tr>
  </table>
</dl>
The net effect is that you can see the invalid region for each window and watch redraws as they occur. This allows you to diagnose inefficiencies in your application. In essence, because the GDK rendering model prevents all flicker, if you are redrawing the same region 400 times you may never notice, aside from noticing a speed problem. Enabling update debugging causes GTK to flicker slowly and noticeably, so you can see exactly what's being redrawn when, in what order.<p>
The --gtk-debug=updates command line option passed to GTK+ programs enables this debug option at application startup time. That's usually more useful than calling <a class="el" href="classXfc_1_1Gdk_1_1Window.html#7ac6128a4ce529f83ce358961362acbe">set_debug_updates()</a> yourself, though you might want to use this method to enable updates sometime after application startup time. 
</div>
</div><p>
<a class="anchor" name="68bc38f96eed6e2b277ba377bfca7177"></a><!-- doxytag: member="Xfc::Gdk::Window::enable_synchronized_configure" ref="68bc38f96eed6e2b277ba377bfca7177" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::enable_synchronized_configure           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates that the application will cooperate with the window system in synchronizing the window repaint with the window manager during resizing operations. 
<p>
After an application calls this function, it must call <a class="el" href="classXfc_1_1Gdk_1_1Window.html#3edde69831c0395e0299c1cab5f9e492">configure_finished()</a> every time it has finished all processing associated with a set of "configure" events. Toplevel GTK+ windows automatically use this protocol. On X, calling this function makes window participate in the _NET_WM_SYNC_REQUEST window manager protocol. 
</div>
</div><p>
<a class="anchor" name="3edde69831c0395e0299c1cab5f9e492"></a><!-- doxytag: member="Xfc::Gdk::Window::configure_finished" ref="3edde69831c0395e0299c1cab5f9e492" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::configure_finished           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal to the window system that the application has finished handling "configure" events it has received. 
<p>
<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> Managers can use this to better synchronize the frame repaint with the application. GTK+ applications will automatically call this function when appropriate. 
</div>
</div><p>
<a class="anchor" name="fffc194ea371388241e754b1abe025db"></a><!-- doxytag: member="Xfc::Gdk::Window::keyboard_grab" ref="fffc194ea371388241e754b1abe025db" args="(bool owner_events=false, unsigned int time=GDK_CURRENT_TIME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1Gdk.html#a122cdf630b777e48fce8da9f57a01b6">GrabStatus</a> Xfc::Gdk::Window::keyboard_grab           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owner_events</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>time</em> = <code>GDK_CURRENT_TIME</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This window grabs the keyboard so that all events are passed to this application until the keyboard is ungrabbed with <a class="el" href="namespaceXfc_1_1Gdk.html#18d3b377328e00747fe591469bdc91f6">Gdk::keyboard_ungrab()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owner_events</em>&nbsp;</td><td>If <em>false</em> then all keyboard events are reported with respect to the window. If <em>true</em> then keyboard events for this application are reported as normal, but keyboard events outside this application are reported with respect to the window. Both key press and key release events are always reported, independant of the event mask set by the application. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>A timestamp from a <a class="el" href="classXfc_1_1Gdk_1_1Event.html">Gdk::Event</a>, or GDK_CURRENT_TIME if no timestamp is available. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>GRAB_SUCCESS if the grab was successful.</dd></dl>
This overrides any previous keyboard grab by this client. 
</div>
</div><p>
<a class="anchor" name="08c01838fd6c5ca6fda03fba0567f969"></a><!-- doxytag: member="Xfc::Gdk::Window::pointer_grab" ref="08c01838fd6c5ca6fda03fba0567f969" args="(EventMaskField event_mask, Window *confine_to=0, Cursor *cursor=0, bool owner_events=false, unsigned int time=GDK_CURRENT_TIME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1Gdk.html#a122cdf630b777e48fce8da9f57a01b6">GrabStatus</a> Xfc::Gdk::Window::pointer_grab           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">EventMaskField</a>&nbsp;</td>
          <td class="paramname"> <em>event_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Window</a> *&nbsp;</td>
          <td class="paramname"> <em>confine_to</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Cursor.html">Cursor</a> *&nbsp;</td>
          <td class="paramname"> <em>cursor</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owner_events</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>time</em> = <code>GDK_CURRENT_TIME</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This window grabs the pointer (usualy a mouse) so that all events are passed to this application until the pointer is ungrabbed with <a class="el" href="namespaceXfc_1_1Gdk.html#c01264f9bd5744449473c344b96ae9b8">Gdk::pointer_ungrab()</a>, or the grab window becomes unviewable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event_mask</em>&nbsp;</td><td>Specifies the event mask, which is used in accordance with owner_events. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>confine_to</em>&nbsp;</td><td>If non-null, the pointer will be confined to this window during the grab. If the pointer is outside confine_to, it will automatically be moved to the closest edge of confine_to and enter and leave events will be generated as necessary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cursor</em>&nbsp;</td><td>The cursor to display while the grab is active. If this is null then the normal cursors are used for window and its descendants, and the cursor for window is used for all other windows. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owner_events</em>&nbsp;</td><td>If false then all pointer events are reported with respect to window and are only reported if selected by event_mask. If true then pointer events for this application are reported as normal, but pointer events outside this application are reported with respect to window and only if selected by event_mask. In either mode, unreported events are discarded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>The timestamp of the event which led to this pointer grab. This usually comes from <a class="el" href="classXfc_1_1Gdk_1_1EventButton.html">Gdk::EventButton</a>, though GDK_CURRENT_TIME can be used if the time isn't known. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>GRAB_SUCCESS if the grab was successful.</dd></dl>
This overrides any previous pointer grab by this client. <a class="el" href="classXfc_1_1Pointer.html">Pointer</a> grabs are used for operations which need complete control over mouse events, even if the mouse leaves the application. For example in GTK+ it is used for Drag and Drop, and for dragging the handle in the <a class="el" href="classXfc_1_1Gtk_1_1HPaned.html">Gtk::HPaned</a> and <a class="el" href="classXfc_1_1Gtk_1_1VPaned.html">Gtk::VPaned</a> widgets.<p>
Note that if the event mask of an X window has selected both button press and button release events, then a button press event will cause an automatic pointer grab until the button is released. X does this automatically since most applications expect to receive button press and release events in pairs. It is equivalent to a pointer grab on the window with owner_events set to true. 
</div>
</div><p>
<a class="anchor" name="14ad4e31494a187d2e4c524d92c0e2a5"></a><!-- doxytag: member="Xfc::Gdk::Window::set_extension_events" ref="14ad4e31494a187d2e4c524d92c0e2a5" args="(int mask, ExtensionMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gdk::Window::set_extension_events           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#6a40c7183f0539c8c67394dc8a22a917">ExtensionMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Turns extension events on or off for a particular window, and specifies the event mask for extension events. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The event mask. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The type of extension events that are desired. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="gdk_2window_8hh.html">gdk/window.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
