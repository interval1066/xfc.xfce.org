<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1Gtk.html">Gtk</a>::<a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a></div>
<h1>Xfc::Gtk::TextBuffer Class Reference</h1><!-- doxytag: class="Xfc::Gtk::TextBuffer" --><!-- doxytag: inherits="Xfc::G::Object" -->A GtkTextBuffer C++ wrapper class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/gtk/textbuffer.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::Gtk::TextBuffer:
<p><center><img src="classXfc_1_1Gtk_1_1TextBuffer.png" usemap="#Xfc::Gtk::TextBuffer_map" border="0" alt=""></center>
<map name="Xfc::Gtk::TextBuffer_map">
<area href="classXfc_1_1G_1_1Object.html" alt="Xfc::G::Object" shape="rect" coords="0,112,138,136">
<area href="classXfc_1_1G_1_1TypeInstance.html" alt="Xfc::G::TypeInstance" shape="rect" coords="0,56,138,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,138,24">
<area href="classXfc_1_1Gtk_1_1SourceBuffer.html" alt="Xfc::Gtk::SourceBuffer" shape="rect" coords="0,224,138,248">
</map>
<a href="classXfc_1_1Gtk_1_1TextBuffer-members.html">List of all members.</a><h2>Signal Prototypes</h2>
<ul>
<li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">InsertTextSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#0975def12526624349177219810d1d57">insert_text_signal</a>
<dl class="el"><dd class="mdescRight">Insert text signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#a16a5f96a02fd4605067af9f2df7de71">signal_insert_text()</a>).  <a href="#0975def12526624349177219810d1d57"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">InsertPixbufSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#72fae4367e102e3775c6e5922c68d712">insert_pixbuf_signal</a>
<dl class="el"><dd class="mdescRight">Insert pixbuf signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#79b1216bd55cf75927089219261a07a9">signal_insert_pixbuf()</a>).  <a href="#72fae4367e102e3775c6e5922c68d712"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">InsertChildAnchorSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#1f06ed3796a260e3f78bd293f30dfadd">insert_child_anchor_signal</a>
<dl class="el"><dd class="mdescRight">Insert child anchor signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#af18bb564727a14906ba752ab5228a95">signal_insert_child_anchor()</a>).  <a href="#1f06ed3796a260e3f78bd293f30dfadd"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DeleteRangeSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#cf5860d43994f5a372795ce52fb1dba2">delete_range_signal</a>
<dl class="el"><dd class="mdescRight">Delete range signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#d1310207cbe2972d2a1e023ae6b28f3d">signal_delete_range()</a>).  <a href="#cf5860d43994f5a372795ce52fb1dba2"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#bf0cad66c5645e40e5bd83d8985f868f">changed_signal</a>
<dl class="el"><dd class="mdescRight">Changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#86dd93ed14ce9709687dbe368533c118">signal_changed()</a>).  <a href="#bf0cad66c5645e40e5bd83d8985f868f"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ModifiedChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#83c94869ba239ecdca623df390f7265c">modified_changed_signal</a>
<dl class="el"><dd class="mdescRight">Modified changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e1076af81b94f9df30833f6506ff2ddd">signal_modified_changed()</a>).  <a href="#83c94869ba239ecdca623df390f7265c"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">MarkSetSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#6feca2062ae026aea720a414d6a5514f">mark_set_signal</a>
<dl class="el"><dd class="mdescRight">Mark set signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#80907a0caf0de3c94aacd0f9af64c85d">signal_mark_set()</a>).  <a href="#6feca2062ae026aea720a414d6a5514f"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">MarkDeletedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#4f3597d41e96ce5a6f9c30633ce84a81">mark_deleted_signal</a>
<dl class="el"><dd class="mdescRight">Mark deleted signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#c306bbf2a72f1ed23efd280102428d47">signal_mark_deleted()</a>).  <a href="#4f3597d41e96ce5a6f9c30633ce84a81"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ApplyTagSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#22569634ad0e3e8bdcf363d27d334b03">apply_tag_signal</a>
<dl class="el"><dd class="mdescRight">Apply tag signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#91d0f01a1cdf33cf3274ed7b4cc3e060">signal_apply_tag()</a>).  <a href="#22569634ad0e3e8bdcf363d27d334b03"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">RemoveTagSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f80f7a021fbca128c2e9ea4fd4e868fa">remove_tag_signal</a>
<dl class="el"><dd class="mdescRight">Remove tag signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#b7635a94cf93d171817aab53bb35c660">signal_remove_tag()</a>).  <a href="#f80f7a021fbca128c2e9ea4fd4e868fa"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">BeginUserActionSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#ed494e4f8c0276f92e29ab52726ccb5f">begin_user_action_signal</a>
<dl class="el"><dd class="mdescRight">Begin user action signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e17058582952743762741b8c251b48b8">signal_begin_user_action()</a>).  <a href="#ed494e4f8c0276f92e29ab52726ccb5f"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">EndUserActionSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#509960160599c738a67509eb2db253c1">end_user_action_signal</a>
<dl class="el"><dd class="mdescRight">End user action signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#c83e6b0ea7d723d37f584d5f8f2d4260">signal_end_user_action()</a>).  <a href="#509960160599c738a67509eb2db253c1"></a><br></dl></ul>
<h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="6e2960d29a8f9e3a1b9d6694758d568e"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::gtk_text_buffer" ref="6e2960d29a8f9e3a1b9d6694758d568e" args="() const" -->
GtkTextBuffer * <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#6e2960d29a8f9e3a1b9d6694758d568e">gtk_text_buffer</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GtkTextBuffer structure. <br></dl><li><a class="anchor" name="7ba946e72ffdfc7525dc8509325baa3b"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::operator GtkTextBuffer *" ref="7ba946e72ffdfc7525dc8509325baa3b" args="() const" -->
<a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#7ba946e72ffdfc7525dc8509325baa3b">operator GtkTextBuffer *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; safely converts a <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a> to a GtkTextBuffer pointer. <br></dl><li>int <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f2fe023a57d677b67da0b4a3c03f742f">get_line_count</a> () const
<dl class="el"><dd class="mdescRight">Obtains the number of lines in the buffer.  <a href="#f2fe023a57d677b67da0b4a3c03f742f"></a><br></dl><li>int <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#b0232d9ef17da45210eebe7f6ef42357">get_char_count</a> () const
<dl class="el"><dd class="mdescRight">Gets the number of characters in the buffer.  <a href="#b0232d9ef17da45210eebe7f6ef42357"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextTagTable.html">TextTagTable</a> * <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#1fd0c58d901922e313fd2b84a365f374">get_tag_table</a> () const
<dl class="el"><dd class="mdescRight">Get the <a class="el" href="classXfc_1_1Gtk_1_1TextTagTable.html">TextTagTable</a> associated with this buffer.  <a href="#1fd0c58d901922e313fd2b84a365f374"></a><br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#1536d37828625393eeb837eab33583fc">get_text</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end, bool include_hidden_chars=false) const
<dl class="el"><dd class="mdescRight">Returns the text in the range (start,end).  <a href="#1536d37828625393eeb837eab33583fc"></a><br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#8b13c709113316e6365e9432d5e92ff6">get_slice</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end, bool include_hidden_chars=false) const
<dl class="el"><dd class="mdescRight">Returns the text in the range (start,end).  <a href="#8b13c709113316e6365e9432d5e92ff6"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> * <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f1ee7770e81d2e9130151422c544a0cc">get_mark</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;name) const
<dl class="el"><dd class="mdescRight">Returns the mark named <em>name</em> in the buffer, or null if no such mark exists.  <a href="#f1ee7770e81d2e9130151422c544a0cc"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> * <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#8e3b5466b4de2413566a7c31f216e54b">get_insert</a> () const
<dl class="el"><dd class="mdescRight">Returns the mark that represents the cursor (insertion point).  <a href="#8e3b5466b4de2413566a7c31f216e54b"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> * <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#6badd35e02831d5e559ca24b6cf26705">get_selection_bound</a> () const
<dl class="el"><dd class="mdescRight">Returns the mark that represents the selection bound.  <a href="#6badd35e02831d5e559ca24b6cf26705"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#1bd2940717da11c3337da9ce2db8c425">get_iter_at_line_offset</a> (int line_number, int char_offset) const
<dl class="el"><dd class="mdescRight">Obtains an initialized iterator pointing to <em>char_offset</em> within the given line.  <a href="#1bd2940717da11c3337da9ce2db8c425"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#a5ab18e1b036aa3be315c608660cc685">get_iter_at_line_index</a> (int line_number, int byte_index) const
<dl class="el"><dd class="mdescRight">Obtains an initialized iterator pointing to <em>byte_index</em> within the given line.  <a href="#a5ab18e1b036aa3be315c608660cc685"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#b5eed4fe253e60312e908200ad56c7e7">get_iter_at_offset</a> (int char_offset) const
<dl class="el"><dd class="mdescRight">Obtains an gfcalized iterater to a position <em>char_offset</em> chars from the start of the entire buffer.  <a href="#b5eed4fe253e60312e908200ad56c7e7"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#ec84141349e110334957fb87e68c6a34">get_iter_at_line</a> (int line_number) const
<dl class="el"><dd class="mdescRight">Obtains an initialized iterator to the start of the given line.  <a href="#ec84141349e110334957fb87e68c6a34"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#a7231ee43cf8e8525cdbb2ed5039a0cd">get_start_iter</a> () const
<dl class="el"><dd class="mdescRight">Obtains an initialized iterator to the first position in the text buffer.  <a href="#a7231ee43cf8e8525cdbb2ed5039a0cd"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#18d3249fbe712ec9002cc6824bd14ffb">get_end_iter</a> () const
<dl class="el"><dd class="mdescRight">Obtains an initialzied iterator to one past the last valid character in the text buffer.  <a href="#18d3249fbe712ec9002cc6824bd14ffb"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#51dbb30719a81e19e5443835abf77b73">get_bounds</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end) const
<dl class="el"><dd class="mdescRight">Retrieves the first and last iterators in the buffer, that is the entire buffer lies within the range (start,end).  <a href="#51dbb30719a81e19e5443835abf77b73"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#a1f54f0a48245c3909cd88fdc110b5d8">get_iter_at_mark</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> &amp;mark) const
<dl class="el"><dd class="mdescRight">Obtains an initialized iterator to the current position of mark.  <a href="#a1f54f0a48245c3909cd88fdc110b5d8"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#5a3e8eca5f20275506087b9aff98b910">get_iter_at_child_anchor</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextChildAnchor.html">TextChildAnchor</a> &amp;anchor) const
<dl class="el"><dd class="mdescRight">Obtains an initialized iterator to the location of anchor within the buffer.  <a href="#5a3e8eca5f20275506087b9aff98b910"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#877b8d52af90e114a45053223c1fb848">get_modified</a> () const
<dl class="el"><dd class="mdescRight">Indicates whether the buffer has been modified since the last call to <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#91e631a0cd32c92abfbf916f68c88083">set_modified()</a> to set the modification flag to false.  <a href="#877b8d52af90e114a45053223c1fb848"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#97770479f55c4623f10f61f24b500181">get_selection_bounds</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *start=0, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *end=0) const
<dl class="el"><dd class="mdescRight">Returns true if some text is selected; places the bounds of the selection in <em>start</em> and <em>end</em>.  <a href="#97770479f55c4623f10f61f24b500181"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f33ddc3b296772ce728235a3f8e9719d">begin_user_action</a> ()
<dl class="el"><dd class="mdescRight">Called to indicate that the buffer operations between here and a call to buffer_end_user_action() are part of a single user-visible operation.  <a href="#f33ddc3b296772ce728235a3f8e9719d"></a><br></dl><li><a class="anchor" name="3131f88b93409df8de7f60f85e028980"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::end_user_action" ref="3131f88b93409df8de7f60f85e028980" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#3131f88b93409df8de7f60f85e028980">end_user_action</a> ()
<dl class="el"><dd class="mdescRight">Should be paired with a call to <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f33ddc3b296772ce728235a3f8e9719d">begin_user_action()</a> (see that method for a full explanation). <br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#b9ba36434f756b22acde5cbee292ce2c">set_text</a> (const char *text, int length=-1)
<dl class="el"><dd class="mdescRight">Deletes current contents of buffer, and inserts <em>text</em> instead.  <a href="#b9ba36434f756b22acde5cbee292ce2c"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#4f26e9dc2d7fb8e02e4c434070d773dc">set_text</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text)
<dl class="el"><dd class="mdescRight">Deletes current contents of buffer, and inserts <em>text</em> instead.  <a href="#4f26e9dc2d7fb8e02e4c434070d773dc"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const char *text, int length=-1)
<dl class="el"><dd class="mdescRight">Inserts <em>length</em> bytes of text at position iter.  <a href="#16defd6684cb948eb0f5b9c6ae9feb5e"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f9436034aab66781c79d7cfb65d41136">insert</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text)
<dl class="el"><dd class="mdescRight">Inserts text at position iter.  <a href="#f9436034aab66781c79d7cfb65d41136"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#507c26d4649b8c8da95150a341d0cff7">insert_at_cursor</a> (const char *text, int length=-1)
<dl class="el"><dd class="mdescRight">Simply calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a>, using the current cursor position as the insertion point.  <a href="#507c26d4649b8c8da95150a341d0cff7"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#74be6bb8af8827432b12b630d20b0ea4">insert_at_cursor</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text)
<dl class="el"><dd class="mdescRight">Simply calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a>, using the current cursor position as the insertion point.  <a href="#74be6bb8af8827432b12b630d20b0ea4"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#67736bce78aea5b45e7af99289e02bb6">insert_interactive</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const char *text, int length, bool default_editable)
<dl class="el"><dd class="mdescRight">Like <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a>, but the insertion will not occur if iter is at a non-editable location in the buffer.  <a href="#67736bce78aea5b45e7af99289e02bb6"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#978d16b0d50d3ffc7b872b0819eaf8c0">insert_interactive</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text, bool default_editable)
<dl class="el"><dd class="mdescRight">Like <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a>, but the insertion will not occur if iter is at a non-editable location in the buffer.  <a href="#978d16b0d50d3ffc7b872b0819eaf8c0"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#ce3dc30d6e627ee9340bf6a5dff3e093">insert_interactive_at_cursor</a> (const char *text, int length, bool default_editable)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#67736bce78aea5b45e7af99289e02bb6">insert_interactive()</a> to insert <em>text</em> at the cursor position.  <a href="#ce3dc30d6e627ee9340bf6a5dff3e093"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e9e6f6a833a58a0fea84e94d340a94c0">insert_interactive_at_cursor</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text, bool default_editable)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#67736bce78aea5b45e7af99289e02bb6">insert_interactive()</a> to insert <em>text</em> at the cursor position.  <a href="#e9e6f6a833a58a0fea84e94d340a94c0"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#394497af51fc6edc27eef817bfc82164">insert_range</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Copies text, tags, and pixbufs between start and end (the order of start and end doesn't matter) and inserts the copy at iter.  <a href="#394497af51fc6edc27eef817bfc82164"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#0c7b7819037ee286534ad455a09b9aa3">insert_range_interactive</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end, bool default_editable)
<dl class="el"><dd class="mdescRight">Same as <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#394497af51fc6edc27eef817bfc82164">insert_range()</a>, but does nothing if the insertion point isn't editable.  <a href="#0c7b7819037ee286534ad455a09b9aa3"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#adc2ac504a9d5a7ae6a7efd9ef2fc5ad">insert_with_tag</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const char *text, int length, <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> &amp;tag)
<dl class="el"><dd class="mdescRight">Inserts <em>text</em> into the buffer at <em>iter</em>, applying the tag to the newly-inserted text.  <a href="#adc2ac504a9d5a7ae6a7efd9ef2fc5ad"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#ea85ae478bcde6bab26d0679a2fbc164">insert_with_tag</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text, <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> &amp;tag)
<dl class="el"><dd class="mdescRight">Inserts <em>text</em> into the buffer at <em>iter</em>, applying the tag to the newly-inserted text.  <a href="#ea85ae478bcde6bab26d0679a2fbc164"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f4d12527b713ee66a49c9f3435999f11">insert_with_tags</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const char *text, int length, const std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> * &gt; &amp;tags)
<dl class="el"><dd class="mdescRight">Inserts text into the buffer at iter, applying the list of tags to the newly-inserted text.  <a href="#f4d12527b713ee66a49c9f3435999f11"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#ad0e20a22ce74c786a1f756f288f8bff">insert_with_tags</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text, const std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> * &gt; &amp;tags)
<dl class="el"><dd class="mdescRight">Inserts text into the buffer at iter, applying the list of tags to the newly-inserted text.  <a href="#ad0e20a22ce74c786a1f756f288f8bff"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#d277e27120859ebd82a4c3cab182b09f">insert_with_tag_by_name</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const char *text, int length, const char *tag_name)
<dl class="el"><dd class="mdescRight">Same as <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#adc2ac504a9d5a7ae6a7efd9ef2fc5ad">insert_with_tag()</a>, but allows you to pass in the tag name instead of a tag object.  <a href="#d277e27120859ebd82a4c3cab182b09f"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#8b5a763f08d6ba545c911ff93d58f8eb">insert_with_tag_by_name</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text, const char *tag_name)
<dl class="el"><dd class="mdescRight">Same as <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#adc2ac504a9d5a7ae6a7efd9ef2fc5ad">insert_with_tag()</a>, but allows you to pass in the tag name instead of a tag object.  <a href="#8b5a763f08d6ba545c911ff93d58f8eb"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#3f13731a915dbea60ad4c6622925ada7">insert_with_tags_by_name</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const char *text, int length, const std::vector&lt; <a class="el" href="classXfc_1_1String.html">String</a> &gt; &amp;tag_names)
<dl class="el"><dd class="mdescRight">Same as <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f4d12527b713ee66a49c9f3435999f11">insert_with_tags()</a>, but allows you to pass in tag names instead of tag objects.  <a href="#3f13731a915dbea60ad4c6622925ada7"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#cb85fa636d03db1f83793e12362359d2">insert_with_tags_by_name</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text, const std::vector&lt; <a class="el" href="classXfc_1_1String.html">String</a> &gt; &amp;tag_names)
<dl class="el"><dd class="mdescRight">Same as <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f4d12527b713ee66a49c9f3435999f11">insert_with_tags()</a>, but allows you to pass in tag names instead of tag objects.  <a href="#cb85fa636d03db1f83793e12362359d2"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#ade282cb0e422792075215a9a9babd69">delete_range</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Deletes text between start and end.  <a href="#ade282cb0e422792075215a9a9babd69"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#02cf7e0f6e9762e656db74aab9ba3a8e">delete_range_interactive</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end, bool default_editable)
<dl class="el"><dd class="mdescRight">Deletes all editable text in the given range.  <a href="#02cf7e0f6e9762e656db74aab9ba3a8e"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#3221472398f60f8d686e95a8db900e6e">insert_pixbuf</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &amp;pixbuf)
<dl class="el"><dd class="mdescRight">Inserts an image into the text buffer at iter.  <a href="#3221472398f60f8d686e95a8db900e6e"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#b3bc1f68ed59dd782795dbf9db770206">insert_child_anchor</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter, <a class="el" href="classXfc_1_1Gtk_1_1TextChildAnchor.html">TextChildAnchor</a> &amp;anchor)
<dl class="el"><dd class="mdescRight">Inserts a child widget anchor into the text buffer at iter.  <a href="#b3bc1f68ed59dd782795dbf9db770206"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextChildAnchor.html">TextChildAnchor</a> * <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#32b72b9aaeb23f1f36e20ebab1e58a14">create_child_anchor</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;iter)
<dl class="el"><dd class="mdescRight">This is a convenience method which simply creates a child anchor and inserts it into the buffer with <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#b3bc1f68ed59dd782795dbf9db770206">insert_child_anchor()</a>.  <a href="#32b72b9aaeb23f1f36e20ebab1e58a14"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> * <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#887d2fb66cdcbd6f4c2fbe4d3171d2a4">create_mark</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;mark_name, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;where, bool left_gravity)
<dl class="el"><dd class="mdescRight">Creates a mark at position where.  <a href="#887d2fb66cdcbd6f4c2fbe4d3171d2a4"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#3c69e03db48aebda9a31136c3fbf66bd">move_mark</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> &amp;mark, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;where)
<dl class="el"><dd class="mdescRight">Moves <em>mark</em> to the new location <em>where</em>.  <a href="#3c69e03db48aebda9a31136c3fbf66bd"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#10e102267d6c153c8fa7b7c409d3ba22">move_mark_by_name</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;name, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;where)
<dl class="el"><dd class="mdescRight">Moves the mark named <em>name</em> (which must exist) to location <em>where</em> (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#3c69e03db48aebda9a31136c3fbf66bd">move_mark()</a> for details).  <a href="#10e102267d6c153c8fa7b7c409d3ba22"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#6403a1bc61162c486af6d4b8a07d3739">delete_mark</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> &amp;mark)
<dl class="el"><dd class="mdescRight">Deletes <em>mark</em>, so that it's no longer located anywhere in the buffer.  <a href="#6403a1bc61162c486af6d4b8a07d3739"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e74576deb195c2c58897dcf05471b35d">delete_mark_by_name</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;name)
<dl class="el"><dd class="mdescRight">Deletes the mark named name; the mark must exist (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#6403a1bc61162c486af6d4b8a07d3739">delete_mark()</a> for details).  <a href="#e74576deb195c2c58897dcf05471b35d"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#d5fefdc4fd5e63f725e0a80997e41ea3">place_cursor</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;where)
<dl class="el"><dd class="mdescRight">This method moves the "insert" and "selection_bound" marks simultaneously.  <a href="#d5fefdc4fd5e63f725e0a80997e41ea3"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#9a0d5994311a496dd325a19330db30ed">select_range</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;insert, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;bound)
<dl class="el"><dd class="mdescRight">Move the "insert" and "selection_bound" marks simultaneously.  <a href="#9a0d5994311a496dd325a19330db30ed"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e0c19e308cf21da8d8159b3eb910195c">apply_tag</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> &amp;tag, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Emits the "apply_tag" signal on the buffer.  <a href="#e0c19e308cf21da8d8159b3eb910195c"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#8d51e6e3e2fb7ec4d716e60e1ce47d08">apply_tag_by_name</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;name, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Calls Gtk::TextTagTable::lookup() on the buffer's tag table to get a <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>, then calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e0c19e308cf21da8d8159b3eb910195c">apply_tag()</a>.  <a href="#8d51e6e3e2fb7ec4d716e60e1ce47d08"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f92e61464bec12b2f5ffcf07834b6240">remove_tag</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> &amp;tag, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Emits the "remove_tag" signal.  <a href="#f92e61464bec12b2f5ffcf07834b6240"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#33f1636e830bded5979771e77a5ff545">remove_tag_by_name</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;name, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Calls Gtk::TextTagTable::lookup() on the buffer's tag table to get a <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>, then calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f92e61464bec12b2f5ffcf07834b6240">remove_tag()</a>.  <a href="#33f1636e830bded5979771e77a5ff545"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#9c08f24c7a2efd592c237a867c57a3f1">remove_all_tags</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Removes all tags in the range between <em>start</em> and <em>end</em>.  <a href="#9c08f24c7a2efd592c237a867c57a3f1"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> * <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#7b3804b4b8f1a4208551099514d307a6">create_tag</a> ()
<dl class="el"><dd class="mdescRight">Creates an anonymous tag.  <a href="#7b3804b4b8f1a4208551099514d307a6"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> * <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#5d795b98af9bcd7b2ba60fbea937a1d5">create_tag</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;tag_name)
<dl class="el"><dd class="mdescRight">Creates a tag and adds it to the tag table for the buffer.  <a href="#5d795b98af9bcd7b2ba60fbea937a1d5"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#91e631a0cd32c92abfbf916f68c88083">set_modified</a> (bool setting)
<dl class="el"><dd class="mdescRight">Used to keep track of whether the buffer has been modified since the last time it was saved.  <a href="#91e631a0cd32c92abfbf916f68c88083"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#335c3a7faa169748020b7178f1ebd256">add_selection_clipboard</a> (<a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> &amp;clipboard)
<dl class="el"><dd class="mdescRight">Adds <em>clipboard</em> to the list of clipboards in which the selection contents of the buffer are available.  <a href="#335c3a7faa169748020b7178f1ebd256"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#ae7b25a924f8beb5f125643756119a0b">remove_selection_clipboard</a> (<a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> &amp;clipboard)
<dl class="el"><dd class="mdescRight">Removes a <a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> added with <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#335c3a7faa169748020b7178f1ebd256">add_selection_clipboard()</a>.  <a href="#ae7b25a924f8beb5f125643756119a0b"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#09879500cd20134cd9fe599d6976a3c7">cut_clipboard</a> (<a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> &amp;clipboard, bool default_editable)
<dl class="el"><dd class="mdescRight">Copies the currently selected text to a clipboard, then deletes said text if it's editable.  <a href="#09879500cd20134cd9fe599d6976a3c7"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f7e00eef9bfa4e624e3eff9e2ef52b90">copy_clipboard</a> (<a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> &amp;clipboard)
<dl class="el"><dd class="mdescRight">Copies the currently selected text to a clipboard.  <a href="#f7e00eef9bfa4e624e3eff9e2ef52b90"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#6783544bc5653132f972a3b753186d81">paste_clipboard</a> (<a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> &amp;clipboard, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *override_location, bool default_editable)
<dl class="el"><dd class="mdescRight">Pastes the contents of a clipboard at the insertion point, or at <em>override_location</em>.  <a href="#6783544bc5653132f972a3b753186d81"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#163cb17e7c23e47d541b448445b95506">delete_selection</a> (bool interactive, bool default_editable)
<dl class="el"><dd class="mdescRight">Deletes the range between the "insert" and "selection_bound" marks, that is, the currently selected text.  <a href="#163cb17e7c23e47d541b448445b95506"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Signal Proxies</div></td></tr>
<ul>
<li><a class="anchor" name="a16a5f96a02fd4605067af9f2df7de71"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_insert_text" ref="a16a5f96a02fd4605067af9f2df7de71" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">InsertTextSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#a16a5f96a02fd4605067af9f2df7de71">signal_insert_text</a> ()
<dl class="el"><dd class="mdescRight">Connect to the insert_text_signal; emitted whenever text is inserted into the text buffer. <br></dl><li><a class="anchor" name="79b1216bd55cf75927089219261a07a9"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_insert_pixbuf" ref="79b1216bd55cf75927089219261a07a9" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">InsertPixbufSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#79b1216bd55cf75927089219261a07a9">signal_insert_pixbuf</a> ()
<dl class="el"><dd class="mdescRight">Connect to the insert_pixbuf_signal; emitted when a pixbuf image is inserted into the buffer. <br></dl><li><a class="anchor" name="af18bb564727a14906ba752ab5228a95"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_insert_child_anchor" ref="af18bb564727a14906ba752ab5228a95" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">InsertChildAnchorSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#af18bb564727a14906ba752ab5228a95">signal_insert_child_anchor</a> ()
<dl class="el"><dd class="mdescRight">Connect to the insert_child_anchor_signal; emitted when a child anchor is inserted into the buffer. <br></dl><li><a class="anchor" name="d1310207cbe2972d2a1e023ae6b28f3d"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_delete_range" ref="d1310207cbe2972d2a1e023ae6b28f3d" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DeleteRangeSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#d1310207cbe2972d2a1e023ae6b28f3d">signal_delete_range</a> ()
<dl class="el"><dd class="mdescRight">Connect to the delete_range_signal; emitted when contents of the buffer bewteen two iterators are removed. <br></dl><li><a class="anchor" name="86dd93ed14ce9709687dbe368533c118"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_changed" ref="86dd93ed14ce9709687dbe368533c118" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ChangedSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#86dd93ed14ce9709687dbe368533c118">signal_changed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the changed_signal; emitted when the contents of the buffer are changed by an insertion or deletion action. <br></dl><li><a class="anchor" name="e1076af81b94f9df30833f6506ff2ddd"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_modified_changed" ref="e1076af81b94f9df30833f6506ff2ddd" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ModifiedChangedSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e1076af81b94f9df30833f6506ff2ddd">signal_modified_changed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the modified_changed_signal; emitted when the buffer is modified since the last time it was saved. <br></dl><li><a class="anchor" name="80907a0caf0de3c94aacd0f9af64c85d"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_mark_set" ref="80907a0caf0de3c94aacd0f9af64c85d" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">MarkSetSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#80907a0caf0de3c94aacd0f9af64c85d">signal_mark_set</a> ()
<dl class="el"><dd class="mdescRight">Connect to the mark_set_signal; emitted when a mark is placed in the buffer. <br></dl><li><a class="anchor" name="c306bbf2a72f1ed23efd280102428d47"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_mark_deleted" ref="c306bbf2a72f1ed23efd280102428d47" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">MarkDeletedSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#c306bbf2a72f1ed23efd280102428d47">signal_mark_deleted</a> ()
<dl class="el"><dd class="mdescRight">Connect to the mark_deleted_signal; emitted when a mark is removed from the buffer. <br></dl><li><a class="anchor" name="91d0f01a1cdf33cf3274ed7b4cc3e060"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_apply_tag" ref="91d0f01a1cdf33cf3274ed7b4cc3e060" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ApplyTagSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#91d0f01a1cdf33cf3274ed7b4cc3e060">signal_apply_tag</a> ()
<dl class="el"><dd class="mdescRight">Connect to the apply_tag_signal; emitted when a tag is applied to a range characters bewteen two iterators. <br></dl><li><a class="anchor" name="b7635a94cf93d171817aab53bb35c660"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_remove_tag" ref="b7635a94cf93d171817aab53bb35c660" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">RemoveTagSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#b7635a94cf93d171817aab53bb35c660">signal_remove_tag</a> ()
<dl class="el"><dd class="mdescRight">Connect to the remove_tag_signal; emitted when all occurrences of a tag are removed from a range characters bewteen two iterators. <br></dl><li><a class="anchor" name="e17058582952743762741b8c251b48b8"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_begin_user_action" ref="e17058582952743762741b8c251b48b8" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">BeginUserActionSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e17058582952743762741b8c251b48b8">signal_begin_user_action</a> ()
<dl class="el"><dd class="mdescRight">Connect to the begin_user_action_signal; emitted to indicate the user is starting buffer operations that are part of a single user-visible operation. <br></dl><li><a class="anchor" name="c83e6b0ea7d723d37f584d5f8f2d4260"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::signal_end_user_action" ref="c83e6b0ea7d723d37f584d5f8f2d4260" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">EndUserActionSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#c83e6b0ea7d723d37f584d5f8f2d4260">signal_end_user_action</a> ()
<dl class="el"><dd class="mdescRight">Connect to the end_user_action_signal; emitted to indicate the user has ended the current buffer operations. <br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GtkTextBuffer C++ wrapper class. 
<p>
GTK+ has an extremely powerful framework for multiline text editing. The primary objects involved in the process are <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a>, which represents the text being edited, and <a class="el" href="classXfc_1_1Gtk_1_1TextView.html">TextView</a>, a widget which can display a <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a>. Each buffer can be displayed by any number of views. One of the important things to remember about text in GTK+ is that it's in the UTF-8 encoding. This means that one character can be encoded as multiple bytes. Character counts are usually referred to as offsets, while byte counts are called indexes. If you confuse these two, things will work fine with ASCII, but as soon as your buffer contains multibyte characters, bad things will happen.<p>
Text in a buffer can be marked with tags. A tag is an attribute that can be applied to some range of text. For example, a tag might be called "bold" and make the text inside the tag bold. Each tag is stored in a <a class="el" href="classXfc_1_1Gtk_1_1TextTagTable.html">TextTagTable</a>. A tag table defines a set of tags that can be used together. Each buffer has one tag table associated with it; only tags from that tag table can be used with the buffer. A single tag table can be shared between multiple buffers, however. Tags can have names, which is convenient sometimes (for example, you can name your tag that makes things bold "bold"), but they can also be anonymous (which is convenient if you're creating tags on-the-fly).<p>
Most text manipulation is accomplished with iterators, represented by a <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>. An iterator represents a position between two characters in the text buffer. Because of this, iterators can't be used to preserve positions across buffer modifications. To preserve a position, the <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> object is ideal. You can think of a mark as an invisible cursor or insertion point; it floats in the buffer, saving a position. Like tags, marks can be either named or anonymous.<p>
Text buffers always contain at least one line, but may be empty (that is, buffers can contain zero characters). The last line in the text buffer never ends in a line separator (such as newline); the other lines in the buffer always end in a line separator. Line separators count as characters when computing character counts and character offsets. Note that some Unicode line separators are represented with multiple bytes in UTF-8, and the two-character sequence "\\r\\n" is also considered a line separator.<p>
Note: <em>dynamically allocated objects must either be unreferenced or assigned to a smart pointer. Stack objects are automatically unreferenced when they go out of scope.</em><p>
<b>See also:</b> the <a href="../../howto/html/textview.html">TextView Widget</a> HOWTO and example. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4d7ea208668032320e81f51ba159234f"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::TextBuffer" ref="4d7ea208668032320e81f51ba159234f" args="(GtkTextBuffer *buffer, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::TextBuffer::TextBuffer           </td>
          <td>(</td>
          <td class="paramtype">GtkTextBuffer *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a> from an existing GtkTextBuffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to a GtkTextBuffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>buffer</em> can be a newly created GtkTextBuffer or an existing GtkTextBuffer (see G::Object::Object). 
</div>
</div><p>
<a class="anchor" name="ff7964c8448f505b5cd8e165d6f0c05e"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::TextBuffer" ref="ff7964c8448f505b5cd8e165d6f0c05e" args="(TextTagTable *table=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::TextBuffer::TextBuffer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextTagTable.html">TextTagTable</a> *&nbsp;</td>
          <td class="paramname"> <em>table</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new text buffer with a reference count of 1 that the caller owns. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>table</em>&nbsp;</td><td>A tag table, or null to have the text buffer create one for you. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4d7ea208668032320e81f51ba159234f"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::TextBuffer" ref="4d7ea208668032320e81f51ba159234f" args="(GtkTextBuffer *buffer, bool owns_reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::TextBuffer::TextBuffer           </td>
          <td>(</td>
          <td class="paramtype">GtkTextBuffer *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a> from an existing GtkTextBuffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to a GtkTextBuffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>buffer</em> can be a newly created GtkTextBuffer or an existing GtkTextBuffer (see G::Object::Object). 
</div>
</div><p>
<a class="anchor" name="ff7964c8448f505b5cd8e165d6f0c05e"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::TextBuffer" ref="ff7964c8448f505b5cd8e165d6f0c05e" args="(TextTagTable *table=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::TextBuffer::TextBuffer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextTagTable.html">TextTagTable</a> *&nbsp;</td>
          <td class="paramname"> <em>table</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new text buffer with a reference count of 1 that the caller owns. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>table</em>&nbsp;</td><td>A tag table, or null to have the text buffer create one for you. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f2fe023a57d677b67da0b4a3c03f742f"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_line_count" ref="f2fe023a57d677b67da0b4a3c03f742f" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Gtk::TextBuffer::get_line_count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the number of lines in the buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of lines in the buffer.</dd></dl>
This value is cached, so the function is very fast. 
</div>
</div><p>
<a class="anchor" name="b0232d9ef17da45210eebe7f6ef42357"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_char_count" ref="b0232d9ef17da45210eebe7f6ef42357" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Gtk::TextBuffer::get_char_count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of characters in the buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of characters in the buffer.</dd></dl>
Note that characters and bytes are not the same, you can't for example expect the contents of the buffer in string form to be this many bytes long. The character count is cached, so this method is very fast. 
</div>
</div><p>
<a class="anchor" name="1fd0c58d901922e313fd2b84a365f374"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_tag_table" ref="1fd0c58d901922e313fd2b84a365f374" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextTagTable.html">TextTagTable</a>* Xfc::Gtk::TextBuffer::get_tag_table           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="classXfc_1_1Gtk_1_1TextTagTable.html">TextTagTable</a> associated with this buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The buffer's tag table. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1536d37828625393eeb837eab33583fc"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_text" ref="1536d37828625393eeb837eab33583fc" args="(const TextIter &amp;start, const TextIter &amp;end, bool include_hidden_chars=false) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Gtk::TextBuffer::get_text           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_hidden_chars</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the text in the range (start,end). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The start of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The end of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>include_hidden_chars</em>&nbsp;</td><td>Whether to include invisible text. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The text string.</dd></dl>
Undisplayed text is excluded (text marked with tags that set the invisibility attribute) if <em>include_hidden_chars</em> is false. Does not include characters representing embedded images, so byte and character indexes into the returned string do not correspond to byte and character indexes into the buffer. Contrast with <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#8b13c709113316e6365e9432d5e92ff6">get_slice()</a>. 
</div>
</div><p>
<a class="anchor" name="8b13c709113316e6365e9432d5e92ff6"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_slice" ref="8b13c709113316e6365e9432d5e92ff6" args="(const TextIter &amp;start, const TextIter &amp;end, bool include_hidden_chars=false) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Gtk::TextBuffer::get_slice           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_hidden_chars</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the text in the range (start,end). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The start of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The end of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>include_hidden_chars</em>&nbsp;</td><td>Whether to include invisible text. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A text string.</dd></dl>
Excludes undisplayed text (text marked with tags that set the invisibility attribute) if <em>include_hidden_chars</em> is false. The returned string includes a 0xFFFC character whenever the buffer contains embedded images, so byte and character indexes into the returned string do correspond to byte and character indexes into the buffer. Contrast with <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#1536d37828625393eeb837eab33583fc">get_text()</a>. Note that 0xFFFC can occur in normal text as well, so it is not a reliable indicator that a pixbuf or widget is in the buffer. 
</div>
</div><p>
<a class="anchor" name="f1ee7770e81d2e9130151422c544a0cc"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_mark" ref="f1ee7770e81d2e9130151422c544a0cc" args="(const String &amp;name) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a>* Xfc::Gtk::TextBuffer::get_mark           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the mark named <em>name</em> in the buffer, or null if no such mark exists. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A mark name. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a>, or null. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8e3b5466b4de2413566a7c31f216e54b"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_insert" ref="8e3b5466b4de2413566a7c31f216e54b" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a>* Xfc::Gtk::TextBuffer::get_insert           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the mark that represents the cursor (insertion point). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The insertion point mark.</dd></dl>
Equivalent to calling get_mark() to get the mark named "insert", but slightly more efficient, and involves less typing. 
</div>
</div><p>
<a class="anchor" name="6badd35e02831d5e559ca24b6cf26705"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_selection_bound" ref="6badd35e02831d5e559ca24b6cf26705" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a>* Xfc::Gtk::TextBuffer::get_selection_bound           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the mark that represents the selection bound. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The selection bound mark.</dd></dl>
Equivalent to calling get_mark() to get the mark named "selection_bound", but slightly more efficient, and involves less typing. The currently selected text in buffer is the region between the "selection_bound" and "insert" marks. If "selection_bound" and "insert" are in the same place, then there is no current selection. <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#97770479f55c4623f10f61f24b500181">get_selection_bounds()</a> is another convenient method for handling the selection, if you just want to know whether there's a selection and what its bounds are. 
</div>
</div><p>
<a class="anchor" name="1bd2940717da11c3337da9ce2db8c425"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_iter_at_line_offset" ref="1bd2940717da11c3337da9ce2db8c425" args="(int line_number, int char_offset) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> Xfc::Gtk::TextBuffer::get_iter_at_line_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>char_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains an initialized iterator pointing to <em>char_offset</em> within the given line. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line_number</em>&nbsp;</td><td>The line number counting from 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>char_offset</em>&nbsp;</td><td>The char offset from start of line. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The initialized iterator.</dd></dl>
The <em>char_offset</em> must exist, offsets off the end of the line are not allowed. Note characters, not bytes; UTF-8 may encode one character as multiple bytes. 
</div>
</div><p>
<a class="anchor" name="a5ab18e1b036aa3be315c608660cc685"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_iter_at_line_index" ref="a5ab18e1b036aa3be315c608660cc685" args="(int line_number, int byte_index) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> Xfc::Gtk::TextBuffer::get_iter_at_line_index           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byte_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains an initialized iterator pointing to <em>byte_index</em> within the given line. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line_number</em>&nbsp;</td><td>The line number counting from 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byte_index</em>&nbsp;</td><td>The byte index from start of the line. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The initialized iterator.</dd></dl>
The <em>byte_index</em> must be the start of a UTF-8 character, and must not be beyond the end of the line. Note bytes, not characters; UTF-8 may encode one character as multiple bytes. 
</div>
</div><p>
<a class="anchor" name="b5eed4fe253e60312e908200ad56c7e7"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_iter_at_offset" ref="b5eed4fe253e60312e908200ad56c7e7" args="(int char_offset) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> Xfc::Gtk::TextBuffer::get_iter_at_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>char_offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains an gfcalized iterater to a position <em>char_offset</em> chars from the start of the entire buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_offset</em>&nbsp;</td><td>The character offset from start of buffer, counting from 0, or -1. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The initialized iterator.</dd></dl>
If <em>char_offset</em> is -1 or greater than the number of characters in the buffer, the iterator is initialized to the end iterator, the iterator one past the last valid character in the buffer. 
</div>
</div><p>
<a class="anchor" name="ec84141349e110334957fb87e68c6a34"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_iter_at_line" ref="ec84141349e110334957fb87e68c6a34" args="(int line_number) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> Xfc::Gtk::TextBuffer::get_iter_at_line           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains an initialized iterator to the start of the given line. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line_number</em>&nbsp;</td><td>The line number counting from 0. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The initialized iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a7231ee43cf8e8525cdbb2ed5039a0cd"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_start_iter" ref="a7231ee43cf8e8525cdbb2ed5039a0cd" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> Xfc::Gtk::TextBuffer::get_start_iter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains an initialized iterator to the first position in the text buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The initialized <em>start</em> iterator.</dd></dl>
This is the same as using <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#b5eed4fe253e60312e908200ad56c7e7">get_iter_at_offset()</a> to get the iter at character offset 0. 
</div>
</div><p>
<a class="anchor" name="18d3249fbe712ec9002cc6824bd14ffb"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_end_iter" ref="18d3249fbe712ec9002cc6824bd14ffb" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> Xfc::Gtk::TextBuffer::get_end_iter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains an initialzied iterator to one past the last valid character in the text buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The initialized <em>end</em> iterator.</dd></dl>
If dereferenced with <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8b78bb057daddfa3fbd9db5818d153c0">Gtk::TextIter::get_char()</a>, the end iterator has a character value of 0. The entire buffer lies in the range from the first position (call <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#a7231ee43cf8e8525cdbb2ed5039a0cd">get_start_iter()</a> to get character position 0 in the buffer) to the end iterator. 
</div>
</div><p>
<a class="anchor" name="51dbb30719a81e19e5443835abf77b73"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_bounds" ref="51dbb30719a81e19e5443835abf77b73" args="(TextIter &amp;start, TextIter &amp;end) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::get_bounds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the first and last iterators in the buffer, that is the entire buffer lies within the range (start,end). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The iterator to initialize to first position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The iterator to initialize with the end iterator. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a1f54f0a48245c3909cd88fdc110b5d8"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_iter_at_mark" ref="a1f54f0a48245c3909cd88fdc110b5d8" args="(TextMark &amp;mark) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> Xfc::Gtk::TextBuffer::get_iter_at_mark           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mark</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains an initialized iterator to the current position of mark. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mark</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> in the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The initialized iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a3e8eca5f20275506087b9aff98b910"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_iter_at_child_anchor" ref="5a3e8eca5f20275506087b9aff98b910" args="(TextChildAnchor &amp;anchor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> Xfc::Gtk::TextBuffer::get_iter_at_child_anchor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextChildAnchor.html">TextChildAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>anchor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains an initialized iterator to the location of anchor within the buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>anchor</em>&nbsp;</td><td>A child anchor that appears in the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The initialized iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="877b8d52af90e114a45053223c1fb848"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_modified" ref="877b8d52af90e114a45053223c1fb848" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextBuffer::get_modified           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates whether the buffer has been modified since the last call to <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#91e631a0cd32c92abfbf916f68c88083">set_modified()</a> to set the modification flag to false. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the buffer has been modified.</dd></dl>
Used for example to enable a "save" function in a text editor. 
</div>
</div><p>
<a class="anchor" name="97770479f55c4623f10f61f24b500181"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::get_selection_bounds" ref="97770479f55c4623f10f61f24b500181" args="(TextIter *start=0, TextIter *end=0) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextBuffer::get_selection_bounds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>end</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if some text is selected; places the bounds of the selection in <em>start</em> and <em>end</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The iterator to initialize with selection start. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The iterator to initialize with selection end. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the selection has nonzero length.</dd></dl>
If the selection has length 0, then start and end are filled in with the same value. start and end will be in ascending order. If start and end are null, then they are not filled in, but the return value still indicates whether any text is selected. 
</div>
</div><p>
<a class="anchor" name="f33ddc3b296772ce728235a3f8e9719d"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::begin_user_action" ref="f33ddc3b296772ce728235a3f8e9719d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::begin_user_action           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called to indicate that the buffer operations between here and a call to buffer_end_user_action() are part of a single user-visible operation. 
<p>
The operations between <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f33ddc3b296772ce728235a3f8e9719d">begin_user_action()</a> and <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#3131f88b93409df8de7f60f85e028980">end_user_action()</a> can then be grouped when creating an undo stack. <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a> maintains a count of calls to <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f33ddc3b296772ce728235a3f8e9719d">begin_user_action()</a> that have not been closed with a call to <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#3131f88b93409df8de7f60f85e028980">end_user_action()</a>, and emits the "begin_user_action" and "end_user_action" signals only for the outermost pair of calls. This allows you to build user actions from other user actions.<p>
The "interactive" buffer mutation methods, such as <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#67736bce78aea5b45e7af99289e02bb6">insert_interactive()</a>, automatically call begin/end user action around the buffer operations they perform, so there's no need to add extra calls if your user action consists solely of a single call to one of those methods. 
</div>
</div><p>
<a class="anchor" name="b9ba36434f756b22acde5cbee292ce2c"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::set_text" ref="b9ba36434f756b22acde5cbee292ce2c" args="(const char *text, int length=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::set_text           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes current contents of buffer, and inserts <em>text</em> instead. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The UTF-8 text to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of text in bytes, or -1 if <em>text</em> is null-terminated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4f26e9dc2d7fb8e02e4c434070d773dc"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::set_text" ref="4f26e9dc2d7fb8e02e4c434070d773dc" args="(const String &amp;text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::set_text           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes current contents of buffer, and inserts <em>text</em> instead. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to insert. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="16defd6684cb948eb0f5b9c6ae9feb5e"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert" ref="16defd6684cb948eb0f5b9c6ae9feb5e" args="(TextIter &amp;iter, const char *text, int length=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <em>length</em> bytes of text at position iter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The UTF-8 format text to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of text in bytes, or -1.</td></tr>
  </table>
</dl>
If <em>length</em> is -1, <em>text</em> must be null-terminated and will be inserted in its entirety. This method emits the "insert_text" signal; insertion actually occurs in the default handler for the signal. The iter is invalidated when insertion occurs (because the buffer contents change), but the default signal handler revalidates it to point to the end of the inserted text. 
</div>
</div><p>
<a class="anchor" name="f9436034aab66781c79d7cfb65d41136"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert" ref="f9436034aab66781c79d7cfb65d41136" args="(TextIter &amp;iter, const String &amp;text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts text at position iter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to insert.</td></tr>
  </table>
</dl>
Emits the "insert_text" signal; insertion actually occurs in the default handler for the signal. The iter is invalidated when insertion occurs (because the buffer contents change), but the default signal handler revalidates it to point to the end of the inserted text. 
</div>
</div><p>
<a class="anchor" name="507c26d4649b8c8da95150a341d0cff7"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_at_cursor" ref="507c26d4649b8c8da95150a341d0cff7" args="(const char *text, int length=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_at_cursor           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simply calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a>, using the current cursor position as the insertion point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>Some text in UTF-8 format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of <em>text</em>, in bytes. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="74be6bb8af8827432b12b630d20b0ea4"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_at_cursor" ref="74be6bb8af8827432b12b630d20b0ea4" args="(const String &amp;text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_at_cursor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simply calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a>, using the current cursor position as the insertion point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>Some text to insert. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="67736bce78aea5b45e7af99289e02bb6"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_interactive" ref="67736bce78aea5b45e7af99289e02bb6" args="(TextIter &amp;iter, const char *text, int length, bool default_editable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextBuffer::insert_interactive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a>, but the insertion will not occur if iter is at a non-editable location in the buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>Some UTF-8 text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of <em>text</em> in bytes, or -1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>The default editability of the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>text</em> was actually inserted.</dd></dl>
Usually you want to prevent insertions at ineditable locations if the insertion results from a user action (is interactive). <em>default_editable</em> indicates the editability of text that doesn't have a tag affecting editability applied to it. Typically the result of <a class="el" href="classXfc_1_1Gtk_1_1TextView.html#2f5c87a4a200f2883c33ff1c4f4eb394">Gtk::TextView::get_editable()</a> is appropriate here. 
</div>
</div><p>
<a class="anchor" name="978d16b0d50d3ffc7b872b0819eaf8c0"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_interactive" ref="978d16b0d50d3ffc7b872b0819eaf8c0" args="(TextIter &amp;iter, const String &amp;text, bool default_editable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextBuffer::insert_interactive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a>, but the insertion will not occur if iter is at a non-editable location in the buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>Some text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>The default editability of the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>text</em> was actually inserted.</dd></dl>
Usually you want to prevent insertions at ineditable locations if the insertion results from a user action (is interactive). <em>default_editable</em> indicates the editability of text that doesn't have a tag affecting editability applied to it. Typically the result of <a class="el" href="classXfc_1_1Gtk_1_1TextView.html#2f5c87a4a200f2883c33ff1c4f4eb394">Gtk::TextView::get_editable()</a> is appropriate here. 
</div>
</div><p>
<a class="anchor" name="ce3dc30d6e627ee9340bf6a5dff3e093"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_interactive_at_cursor" ref="ce3dc30d6e627ee9340bf6a5dff3e093" args="(const char *text, int length, bool default_editable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextBuffer::insert_interactive_at_cursor           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#67736bce78aea5b45e7af99289e02bb6">insert_interactive()</a> to insert <em>text</em> at the cursor position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text in UTF-8 format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of <em>text</em> in bytes, or -1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>The default editability of the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the text was actually inserted.</dd></dl>
<em>default_editable</em> indicates the editability of text that doesn't have a tag affecting editability applied to it. Typically the result of <a class="el" href="classXfc_1_1Gtk_1_1TextView.html#2f5c87a4a200f2883c33ff1c4f4eb394">Gtk::TextView::get_editable()</a> is appropriate here. 
</div>
</div><p>
<a class="anchor" name="e9e6f6a833a58a0fea84e94d340a94c0"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_interactive_at_cursor" ref="e9e6f6a833a58a0fea84e94d340a94c0" args="(const String &amp;text, bool default_editable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextBuffer::insert_interactive_at_cursor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#67736bce78aea5b45e7af99289e02bb6">insert_interactive()</a> to insert <em>text</em> at the cursor position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>The default editability of the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the text was actually inserted.</dd></dl>
<em>default_editable</em> indicates the editability of text that doesn't have a tag affecting editability applied to it. Typically the result of <a class="el" href="classXfc_1_1Gtk_1_1TextView.html#2f5c87a4a200f2883c33ff1c4f4eb394">Gtk::TextView::get_editable()</a> is appropriate here. 
</div>
</div><p>
<a class="anchor" name="394497af51fc6edc27eef817bfc82164"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_range" ref="394497af51fc6edc27eef817bfc82164" args="(TextIter &amp;iter, const TextIter &amp;start, const TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_range           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies text, tags, and pixbufs between start and end (the order of start and end doesn't matter) and inserts the copy at iter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>A position in a <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Another position in the same buffer as start.</td></tr>
  </table>
</dl>
Used instead of simply getting/inserting text because it preserves images and tags. If start and end are in a different buffer from buffer, the two buffers must share the same tag table. Implemented via emissions of the <em>insert_text</em> and <em>apply_tag</em> signals, so expect those. 
</div>
</div><p>
<a class="anchor" name="0c7b7819037ee286534ad455a09b9aa3"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_range_interactive" ref="0c7b7819037ee286534ad455a09b9aa3" args="(TextIter &amp;iter, const TextIter &amp;start, const TextIter &amp;end, bool default_editable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextBuffer::insert_range_interactive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#394497af51fc6edc27eef817bfc82164">insert_range()</a>, but does nothing if the insertion point isn't editable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>A position in a <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Another position in the same buffer as start. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>The default editability of the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether an insertion was possible at iter.</dd></dl>
The <em>default_editable</em> parameter indicates whether the text is editable at iter if no tags enclosing iter affect editability. Typically the result of <a class="el" href="classXfc_1_1Gtk_1_1TextView.html#2f5c87a4a200f2883c33ff1c4f4eb394">Gtk::TextView::get_editable()</a> is appropriate here. 
</div>
</div><p>
<a class="anchor" name="adc2ac504a9d5a7ae6a7efd9ef2fc5ad"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_with_tag" ref="adc2ac504a9d5a7ae6a7efd9ef2fc5ad" args="(TextIter &amp;iter, const char *text, int length, TextTag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_with_tag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <em>text</em> into the buffer at <em>iter</em>, applying the tag to the newly-inserted text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>An iterator in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The UTF-8 text to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of <em>text</em>, or -1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>The tag to apply to <em>text</em>.</td></tr>
  </table>
</dl>
This method is a convenience function. It is equivalent to calling <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a> and then <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e0c19e308cf21da8d8159b3eb910195c">apply_tag()</a> on the inserted text. 
</div>
</div><p>
<a class="anchor" name="ea85ae478bcde6bab26d0679a2fbc164"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_with_tag" ref="ea85ae478bcde6bab26d0679a2fbc164" args="(TextIter &amp;iter, const String &amp;text, TextTag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_with_tag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <em>text</em> into the buffer at <em>iter</em>, applying the tag to the newly-inserted text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>An iterator in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>The tag to apply to <em>text</em>.</td></tr>
  </table>
</dl>
This method is a convenience function. It is equivalent to calling <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a> and then <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e0c19e308cf21da8d8159b3eb910195c">apply_tag()</a> on the inserted text. 
</div>
</div><p>
<a class="anchor" name="f4d12527b713ee66a49c9f3435999f11"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_with_tags" ref="f4d12527b713ee66a49c9f3435999f11" args="(TextIter &amp;iter, const char *text, int length, const std::vector&lt; TextTag * &gt; &amp;tags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_with_tags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts text into the buffer at iter, applying the list of tags to the newly-inserted text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>An iterator in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The UTF-8 text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of text, or -1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tags</em>&nbsp;</td><td>A vector of text tags to apply to <em>text</em>.</td></tr>
  </table>
</dl>
This is a convenience method and is equivalent to calling <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a>, and then <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e0c19e308cf21da8d8159b3eb910195c">apply_tag()</a> on the inserted text. 
</div>
</div><p>
<a class="anchor" name="ad0e20a22ce74c786a1f756f288f8bff"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_with_tags" ref="ad0e20a22ce74c786a1f756f288f8bff" args="(TextIter &amp;iter, const String &amp;text, const std::vector&lt; TextTag * &gt; &amp;tags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_with_tags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts text into the buffer at iter, applying the list of tags to the newly-inserted text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>An iterator in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tags</em>&nbsp;</td><td>A vector of text tags to apply to <em>text</em>.</td></tr>
  </table>
</dl>
This is a convenience method and is equivalent to calling <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#16defd6684cb948eb0f5b9c6ae9feb5e">insert()</a>, and then <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e0c19e308cf21da8d8159b3eb910195c">apply_tag()</a> on the inserted text. 
</div>
</div><p>
<a class="anchor" name="d277e27120859ebd82a4c3cab182b09f"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_with_tag_by_name" ref="d277e27120859ebd82a4c3cab182b09f" args="(TextIter &amp;iter, const char *text, int length, const char *tag_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_with_tag_by_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tag_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#adc2ac504a9d5a7ae6a7efd9ef2fc5ad">insert_with_tag()</a>, but allows you to pass in the tag name instead of a tag object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The UTF-8 text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of text, or -1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_name</em>&nbsp;</td><td>The name of the tag to apply to <em>text</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8b5a763f08d6ba545c911ff93d58f8eb"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_with_tag_by_name" ref="8b5a763f08d6ba545c911ff93d58f8eb" args="(TextIter &amp;iter, const String &amp;text, const char *tag_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_with_tag_by_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tag_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#adc2ac504a9d5a7ae6a7efd9ef2fc5ad">insert_with_tag()</a>, but allows you to pass in the tag name instead of a tag object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_name</em>&nbsp;</td><td>The name of the tag to apply to <em>text</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3f13731a915dbea60ad4c6622925ada7"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_with_tags_by_name" ref="3f13731a915dbea60ad4c6622925ada7" args="(TextIter &amp;iter, const char *text, int length, const std::vector&lt; String &gt; &amp;tag_names)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_with_tags_by_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXfc_1_1String.html">String</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_names</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f4d12527b713ee66a49c9f3435999f11">insert_with_tags()</a>, but allows you to pass in tag names instead of tag objects. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The UTF-8 text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of text, or -1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_names</em>&nbsp;</td><td>A vector of text tag names to apply to <em>text</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cb85fa636d03db1f83793e12362359d2"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_with_tags_by_name" ref="cb85fa636d03db1f83793e12362359d2" args="(TextIter &amp;iter, const String &amp;text, const std::vector&lt; String &gt; &amp;tag_names)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_with_tags_by_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXfc_1_1String.html">String</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_names</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f4d12527b713ee66a49c9f3435999f11">insert_with_tags()</a>, but allows you to pass in tag names instead of tag objects. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_names</em>&nbsp;</td><td>A vector of text tag names to apply to <em>text</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ade282cb0e422792075215a9a9babd69"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::delete_range" ref="ade282cb0e422792075215a9a9babd69" args="(TextIter &amp;start, TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::delete_range           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes text between start and end. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Another position in the buffer.</td></tr>
  </table>
</dl>
The order of start and end is not actually relevant; <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#ade282cb0e422792075215a9a9babd69">delete_range()</a> will reorder them. This method actually emits the "delete_range" signal, and the default handler of that signal deletes the text. Because the buffer is modified, all outstanding iterators become invalid after calling this method; however, the start and end will be re-initialized to point to the location where text was deleted. 
</div>
</div><p>
<a class="anchor" name="02cf7e0f6e9762e656db74aab9ba3a8e"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::delete_range_interactive" ref="02cf7e0f6e9762e656db74aab9ba3a8e" args="(TextIter &amp;start, TextIter &amp;end, bool default_editable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextBuffer::delete_range_interactive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes all editable text in the given range. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The start of range to delete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The end of range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>Whether the buffer is editable by default. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether some text was actually deleted.</dd></dl>
Calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#ade282cb0e422792075215a9a9babd69">delete_range()</a> for each editable sub-range of (start,end). <em>start</em> and <em>end</em> are revalidated to point to the location of the last deleted range, or left untouched if no text was deleted. 
</div>
</div><p>
<a class="anchor" name="3221472398f60f8d686e95a8db900e6e"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_pixbuf" ref="3221472398f60f8d686e95a8db900e6e" args="(TextIter &amp;iter, Gdk::Pixbuf &amp;pixbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_pixbuf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pixbuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts an image into the text buffer at iter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>The location to insert the pixbuf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixbuf</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a>.</td></tr>
  </table>
</dl>
The image will be counted as one character in character counts, and when obtaining the buffer contents as a string, will be represented by the Unicode "object replacement character" 0xFFFC. Note that the "slice" variants for obtaining portions of the buffer as a string include this character for pixbufs, but the "text" variants do not. e.g. see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#8b13c709113316e6365e9432d5e92ff6">get_slice()</a> and <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#1536d37828625393eeb837eab33583fc">get_text()</a>. 
</div>
</div><p>
<a class="anchor" name="b3bc1f68ed59dd782795dbf9db770206"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_child_anchor" ref="b3bc1f68ed59dd782795dbf9db770206" args="(TextIter &amp;iter, TextChildAnchor &amp;anchor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::insert_child_anchor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextChildAnchor.html">TextChildAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>anchor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a child widget anchor into the text buffer at iter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>The location to insert the anchor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>anchor</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextChildAnchor.html">TextChildAnchor</a>.</td></tr>
  </table>
</dl>
The anchor will be counted as one character in character counts, and when obtaining the buffer contents as a string, will be represented by the Unicode "object replacement character" 0xFFFC. Note that the "slice" variants for obtaining portions of the buffer as a string include this character for child anchors, but the "text" variants do not. For example, see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#8b13c709113316e6365e9432d5e92ff6">get_slice()</a> and <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#1536d37828625393eeb837eab33583fc">get_text()</a>. Consider <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#32b72b9aaeb23f1f36e20ebab1e58a14">create_child_anchor()</a> as a more convenient alternative to this method. The buffer will add a reference to the anchor, so you can unref it after insertion. 
</div>
</div><p>
<a class="anchor" name="32b72b9aaeb23f1f36e20ebab1e58a14"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::create_child_anchor" ref="32b72b9aaeb23f1f36e20ebab1e58a14" args="(TextIter &amp;iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextChildAnchor.html">TextChildAnchor</a>* Xfc::Gtk::TextBuffer::create_child_anchor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a convenience method which simply creates a child anchor and inserts it into the buffer with <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#b3bc1f68ed59dd782795dbf9db770206">insert_child_anchor()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>The location in the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The created child anchor.</dd></dl>
The new anchor is owned by the buffer; no reference count is returned to the caller of <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#32b72b9aaeb23f1f36e20ebab1e58a14">create_child_anchor()</a>. 
</div>
</div><p>
<a class="anchor" name="887d2fb66cdcbd6f4c2fbe4d3171d2a4"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::create_mark" ref="887d2fb66cdcbd6f4c2fbe4d3171d2a4" args="(const String &amp;mark_name, const TextIter &amp;where, bool left_gravity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a>* Xfc::Gtk::TextBuffer::create_mark           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mark_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>left_gravity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a mark at position where. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mark_name</em>&nbsp;</td><td>The name for the mark, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>The location to place the new mark. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left_gravity</em>&nbsp;</td><td>Whether the mark has left gravity. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> object.</dd></dl>
If mark_name is null, the mark is anonymous; otherwise, the mark can be retrieved by name using get_mark(). If a mark has left gravity, and text is inserted at the mark's current location, the mark will be moved to the left of the newly-inserted text. If the mark has right gravity (left_gravity = false), the mark will end up on the right of newly-inserted text. The standard left-to-right cursor is a mark with right gravity (when you type, the cursor stays on the right side of the text you're typing). The caller of this method does not own a reference to the returned <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a>, so you can ignore the return value if you like. Marks are owned by the buffer and go away when the buffer does. Emits the "mark_set" signal as notification of the mark's initial placement. 
</div>
</div><p>
<a class="anchor" name="3c69e03db48aebda9a31136c3fbf66bd"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::move_mark" ref="3c69e03db48aebda9a31136c3fbf66bd" args="(TextMark &amp;mark, const TextIter &amp;where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::move_mark           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>where</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>mark</em> to the new location <em>where</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mark</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>The new location for <em>mark</em> in the buffer.</td></tr>
  </table>
</dl>
Emits the <em>mark_set</em> signal as notification of the move. 
</div>
</div><p>
<a class="anchor" name="10e102267d6c153c8fa7b7c409d3ba22"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::move_mark_by_name" ref="10e102267d6c153c8fa7b7c409d3ba22" args="(const String &amp;name, const TextIter &amp;where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::move_mark_by_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>where</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the mark named <em>name</em> (which must exist) to location <em>where</em> (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#3c69e03db48aebda9a31136c3fbf66bd">move_mark()</a> for details). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of a mark. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>The new location for <em>mark</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6403a1bc61162c486af6d4b8a07d3739"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::delete_mark" ref="6403a1bc61162c486af6d4b8a07d3739" args="(TextMark &amp;mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::delete_mark           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mark</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes <em>mark</em>, so that it's no longer located anywhere in the buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mark</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> in the buffer.</td></tr>
  </table>
</dl>
Removes the reference the buffer holds to the mark, so if you haven't called <a class="el" href="classXfc_1_1G_1_1Object.html#47f87a1180f4950eba164d60aa281283">ref()</a> on the mark, it will be freed. Even if the mark isn't freed, most operations on mark become invalid. There is no way to undelete a mark. <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html#9e082d0e136d23e5cec68c93454d9909">Gtk::TextMark::get_deleted()</a> will return true after this method has been called on a mark, indicating that a mark no longer belongs to a buffer. The "mark_deleted" signal will be emitted as notification after the mark is deleted. 
</div>
</div><p>
<a class="anchor" name="e74576deb195c2c58897dcf05471b35d"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::delete_mark_by_name" ref="e74576deb195c2c58897dcf05471b35d" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::delete_mark_by_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the mark named name; the mark must exist (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#6403a1bc61162c486af6d4b8a07d3739">delete_mark()</a> for details). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of a mark in the buffer. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d5fefdc4fd5e63f725e0a80997e41ea3"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::place_cursor" ref="d5fefdc4fd5e63f725e0a80997e41ea3" args="(const TextIter &amp;where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::place_cursor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>where</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method moves the "insert" and "selection_bound" marks simultaneously. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>The where to put the cursor.</td></tr>
  </table>
</dl>
If you move them to the same place in two steps with <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#3c69e03db48aebda9a31136c3fbf66bd">move_mark()</a>, you will temporarily select a region in between their old and new locations, which can be pretty inefficient since the temporarily selected region will force stuff to be recalculated. This method moves them as a unit, which can be optimized. 
</div>
</div><p>
<a class="anchor" name="9a0d5994311a496dd325a19330db30ed"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::select_range" ref="9a0d5994311a496dd325a19330db30ed" args="(const TextIter &amp;insert, const TextIter &amp;bound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::select_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bound</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move the "insert" and "selection_bound" marks simultaneously. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>insert</em>&nbsp;</td><td>Where to put the "insert" mark. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bound</em>&nbsp;</td><td>Where to put the "selection_bound" mark</td></tr>
  </table>
</dl>
If you move <em>insert</em> and <em>bound</em> in two steps with <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#3c69e03db48aebda9a31136c3fbf66bd">move_mark()</a>, you will temporarily select a region in between their old and new locations, which can be pretty inefficient since the temporarily-selected region will force stuff to be recalculated. This function moves them as a unit, which can be optimized. 
</div>
</div><p>
<a class="anchor" name="e0c19e308cf21da8d8159b3eb910195c"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::apply_tag" ref="e0c19e308cf21da8d8159b3eb910195c" args="(TextTag &amp;tag, const TextIter &amp;start, const TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::apply_tag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emits the "apply_tag" signal on the buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>One bound of a range to be tagged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The other bound of a range to be tagged.</td></tr>
  </table>
</dl>
The default handler for the signal applies tag to the given range. The <em>start</em> and <em>end</em> do not have to be in order. 
</div>
</div><p>
<a class="anchor" name="8d51e6e3e2fb7ec4d716e60e1ce47d08"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::apply_tag_by_name" ref="8d51e6e3e2fb7ec4d716e60e1ce47d08" args="(const String &amp;name, const TextIter &amp;start, const TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::apply_tag_by_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls Gtk::TextTagTable::lookup() on the buffer's tag table to get a <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>, then calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e0c19e308cf21da8d8159b3eb910195c">apply_tag()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of a named <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>One bound of a range to be tagged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The other bound of a range to be tagged. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f92e61464bec12b2f5ffcf07834b6240"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::remove_tag" ref="f92e61464bec12b2f5ffcf07834b6240" args="(TextTag &amp;tag, const TextIter &amp;start, const TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::remove_tag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emits the "remove_tag" signal. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>One bound of a range to be untagged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The other bound of a range to be untagged.</td></tr>
  </table>
</dl>
The default handler for the signal removes all occurrences of tag from the given range. The <em>start</em> and <em>end</em> don't have to be in order. 
</div>
</div><p>
<a class="anchor" name="33f1636e830bded5979771e77a5ff545"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::remove_tag_by_name" ref="33f1636e830bded5979771e77a5ff545" args="(const String &amp;name, const TextIter &amp;start, const TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::remove_tag_by_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls Gtk::TextTagTable::lookup() on the buffer's tag table to get a <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>, then calls <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f92e61464bec12b2f5ffcf07834b6240">remove_tag()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of a named <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>One bound of a range to be untagged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The other bound of a range to be untagged. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9c08f24c7a2efd592c237a867c57a3f1"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::remove_all_tags" ref="9c08f24c7a2efd592c237a867c57a3f1" args="(const TextIter &amp;start, const TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::remove_all_tags           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all tags in the range between <em>start</em> and <em>end</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>One bound of a range to be untagged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The other bound of a range to be untagged.</td></tr>
  </table>
</dl>
Be careful with this method; it could remove tags added in code unrelated to the code you're currently writing. That is, using this method is probably a bad idea if you have two or more unrelated code sections that add tags. 
</div>
</div><p>
<a class="anchor" name="7b3804b4b8f1a4208551099514d307a6"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::create_tag" ref="7b3804b4b8f1a4208551099514d307a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>* Xfc::Gtk::TextBuffer::create_tag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an anonymous tag. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new anonymous tag.</dd></dl>
Equivalent to creating a new <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> and then adding the tag to the buffer's tag table. The returned tag is owned by the buffer's tag table, so the reference count will be equal to one. 
</div>
</div><p>
<a class="anchor" name="5d795b98af9bcd7b2ba60fbea937a1d5"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::create_tag" ref="5d795b98af9bcd7b2ba60fbea937a1d5" args="(const String &amp;tag_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>* Xfc::Gtk::TextBuffer::create_tag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a tag and adds it to the tag table for the buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag_name</em>&nbsp;</td><td>The name of the new tag. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tag.</dd></dl>
Equivalent to creating a new <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> and then adding the tag to the buffer's tag table. The returned tag is owned by the buffer's tag table, so the reference count will be equal to one. If <em>tag_name</em> is a null <a class="el" href="classXfc_1_1String.html">String</a>, the tag is anonymous. If <em>tag_name</em> is non-null, a tag called <em>tag_name</em> must not already exist in the tag table for this buffer. 
</div>
</div><p>
<a class="anchor" name="91e631a0cd32c92abfbf916f68c88083"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::set_modified" ref="91e631a0cd32c92abfbf916f68c88083" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::set_modified           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to keep track of whether the buffer has been modified since the last time it was saved. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>The modification flag setting.</td></tr>
  </table>
</dl>
Whenever the buffer is saved to disk, call set_modified(false). When the buffer is modified, it will automatically toggled on the modified bit again. When the modified bit flips, the buffer emits a <em>modified_changed</em> signal. 
</div>
</div><p>
<a class="anchor" name="335c3a7faa169748020b7178f1ebd256"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::add_selection_clipboard" ref="335c3a7faa169748020b7178f1ebd256" args="(Clipboard &amp;clipboard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::add_selection_clipboard           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>clipboard</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <em>clipboard</em> to the list of clipboards in which the selection contents of the buffer are available. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clipboard</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a>.</td></tr>
  </table>
</dl>
In most cases, clipboard will be the <a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> of type GDK_SELECTION_PRIMARY for a view of buffer. 
</div>
</div><p>
<a class="anchor" name="ae7b25a924f8beb5f125643756119a0b"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::remove_selection_clipboard" ref="ae7b25a924f8beb5f125643756119a0b" args="(Clipboard &amp;clipboard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::remove_selection_clipboard           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>clipboard</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a <a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> added with <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#335c3a7faa169748020b7178f1ebd256">add_selection_clipboard()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clipboard</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> added to buffer by <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#335c3a7faa169748020b7178f1ebd256">add_selection_clipboard()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="09879500cd20134cd9fe599d6976a3c7"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::cut_clipboard" ref="09879500cd20134cd9fe599d6976a3c7" args="(Clipboard &amp;clipboard, bool default_editable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::cut_clipboard           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>clipboard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the currently selected text to a clipboard, then deletes said text if it's editable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clipboard</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> object to cut to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>The default editability of the buffer. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f7e00eef9bfa4e624e3eff9e2ef52b90"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::copy_clipboard" ref="f7e00eef9bfa4e624e3eff9e2ef52b90" args="(Clipboard &amp;clipboard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::copy_clipboard           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>clipboard</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the currently selected text to a clipboard. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clipboard</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> object to copy to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6783544bc5653132f972a3b753186d81"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::paste_clipboard" ref="6783544bc5653132f972a3b753186d81" args="(Clipboard &amp;clipboard, TextIter *override_location, bool default_editable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextBuffer::paste_clipboard           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>clipboard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>override_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pastes the contents of a clipboard at the insertion point, or at <em>override_location</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clipboard</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> to paste from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>override_location</em>&nbsp;</td><td>The location to insert pasted text, or null for at the cursor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>Whether the buffer is editable by default.</td></tr>
  </table>
</dl>
Note the pasting is asynchronous, that is, we'll ask for the paste data and return, and at some point later after the main loop runs, the paste data will be inserted. 
</div>
</div><p>
<a class="anchor" name="163cb17e7c23e47d541b448445b95506"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::delete_selection" ref="163cb17e7c23e47d541b448445b95506" args="(bool interactive, bool default_editable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextBuffer::delete_selection           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>interactive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the range between the "insert" and "selection_bound" marks, that is, the currently selected text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interactive</em>&nbsp;</td><td>Whether the deletion is caused by user interaction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>Whether the buffer is editable by default. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether there was a non-empty selection to delete.</dd></dl>
If interactive is true, the editability of the selection will be considered (users can't delete uneditable text). 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="0975def12526624349177219810d1d57"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_text_signal" ref="0975def12526624349177219810d1d57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">InsertTextSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#0975def12526624349177219810d1d57">Xfc::Gtk::TextBuffer::insert_text_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert text signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#a16a5f96a02fd4605067af9f2df7de71">signal_insert_text()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(TextIter&amp; pos, <span class="keyword">const</span> String&amp; text);
&lt; <span class="comment">// pos: A position in the buffer.</span>
&lt; <span class="comment">// text: The text to insert.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="72fae4367e102e3775c6e5922c68d712"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_pixbuf_signal" ref="72fae4367e102e3775c6e5922c68d712" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">InsertPixbufSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#72fae4367e102e3775c6e5922c68d712">Xfc::Gtk::TextBuffer::insert_pixbuf_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert pixbuf signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#79b1216bd55cf75927089219261a07a9">signal_insert_pixbuf()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(TextIter&amp; pos, Gdk::Pixbuf&amp; pixbuf);
&lt; <span class="comment">// pos: The location to insert the pixbuf.</span>
&lt; <span class="comment">// pixbuf: A Gdk::Pixbuf.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="1f06ed3796a260e3f78bd293f30dfadd"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::insert_child_anchor_signal" ref="1f06ed3796a260e3f78bd293f30dfadd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">InsertChildAnchorSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#1f06ed3796a260e3f78bd293f30dfadd">Xfc::Gtk::TextBuffer::insert_child_anchor_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert child anchor signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#af18bb564727a14906ba752ab5228a95">signal_insert_child_anchor()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(TextIter&amp; pos, TextChildAnchor&amp; anchor);
&lt; <span class="comment">// pos: The location to insert the anchor.</span>
&lt; <span class="comment">// anchor: A TextChildAnchor.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="cf5860d43994f5a372795ce52fb1dba2"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::delete_range_signal" ref="cf5860d43994f5a372795ce52fb1dba2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DeleteRangeSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#cf5860d43994f5a372795ce52fb1dba2">Xfc::Gtk::TextBuffer::delete_range_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete range signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#d1310207cbe2972d2a1e023ae6b28f3d">signal_delete_range()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(TextIter&amp; start, TextIter&amp; end);
&lt; <span class="comment">// start: A position in the buffer.</span>
&lt; <span class="comment">// end: Another position in the buffer.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="bf0cad66c5645e40e5bd83d8985f868f"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::changed_signal" ref="bf0cad66c5645e40e5bd83d8985f868f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#bf0cad66c5645e40e5bd83d8985f868f">Xfc::Gtk::TextBuffer::changed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#86dd93ed14ce9709687dbe368533c118">signal_changed()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="83c94869ba239ecdca623df390f7265c"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::modified_changed_signal" ref="83c94869ba239ecdca623df390f7265c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ModifiedChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#83c94869ba239ecdca623df390f7265c">Xfc::Gtk::TextBuffer::modified_changed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modified changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e1076af81b94f9df30833f6506ff2ddd">signal_modified_changed()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="6feca2062ae026aea720a414d6a5514f"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::mark_set_signal" ref="6feca2062ae026aea720a414d6a5514f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">MarkSetSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#6feca2062ae026aea720a414d6a5514f">Xfc::Gtk::TextBuffer::mark_set_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mark set signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#80907a0caf0de3c94aacd0f9af64c85d">signal_mark_set()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<span class="keyword">const</span> TextIter&amp; location, TextMark&amp; mark);
&lt; <span class="comment">// location: The location for mark in the buffer.</span>
&lt; <span class="comment">// mark: A TextMark.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="4f3597d41e96ce5a6f9c30633ce84a81"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::mark_deleted_signal" ref="4f3597d41e96ce5a6f9c30633ce84a81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">MarkDeletedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#4f3597d41e96ce5a6f9c30633ce84a81">Xfc::Gtk::TextBuffer::mark_deleted_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mark deleted signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#c306bbf2a72f1ed23efd280102428d47">signal_mark_deleted()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(TextMark&amp; mark);
&lt; <span class="comment">// mark: A TextMark.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="22569634ad0e3e8bdcf363d27d334b03"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::apply_tag_signal" ref="22569634ad0e3e8bdcf363d27d334b03" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ApplyTagSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#22569634ad0e3e8bdcf363d27d334b03">Xfc::Gtk::TextBuffer::apply_tag_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply tag signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#91d0f01a1cdf33cf3274ed7b4cc3e060">signal_apply_tag()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(TextTag&amp; tag, <span class="keyword">const</span> TextIter&amp; start_char, <span class="keyword">const</span> TextIter&amp; end_char);
&lt; <span class="comment">// tag: A TextTag.</span>
&lt; <span class="comment">// start_char: One bound of a range to be tagged.</span>
&lt; <span class="comment">// end_char: The other bound of a range to be tagged.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="f80f7a021fbca128c2e9ea4fd4e868fa"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::remove_tag_signal" ref="f80f7a021fbca128c2e9ea4fd4e868fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">RemoveTagSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#f80f7a021fbca128c2e9ea4fd4e868fa">Xfc::Gtk::TextBuffer::remove_tag_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove tag signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#b7635a94cf93d171817aab53bb35c660">signal_remove_tag()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(TextTag&amp; tag, <span class="keyword">const</span> TextIter&amp; start_char, <span class="keyword">const</span> TextIter&amp; end_char);
&lt; <span class="comment">// tag: A TextTag.</span>
&lt; <span class="comment">// start_char: One bound of a range to be untagged.</span>
&lt; <span class="comment">// end_char: The other bound of a range to be untagged.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="ed494e4f8c0276f92e29ab52726ccb5f"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::begin_user_action_signal" ref="ed494e4f8c0276f92e29ab52726ccb5f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">BeginUserActionSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#ed494e4f8c0276f92e29ab52726ccb5f">Xfc::Gtk::TextBuffer::begin_user_action_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin user action signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#e17058582952743762741b8c251b48b8">signal_begin_user_action()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="509960160599c738a67509eb2db253c1"></a><!-- doxytag: member="Xfc::Gtk::TextBuffer::end_user_action_signal" ref="509960160599c738a67509eb2db253c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">EndUserActionSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#509960160599c738a67509eb2db253c1">Xfc::Gtk::TextBuffer::end_user_action_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End user action signal (see <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#c83e6b0ea7d723d37f584d5f8f2d4260">signal_end_user_action()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="textbuffer_8hh.html">textbuffer.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
