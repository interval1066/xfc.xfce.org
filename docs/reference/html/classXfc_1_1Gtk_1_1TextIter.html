<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1Gtk.html">Gtk</a>::<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a></div>
<h1>Xfc::Gtk::TextIter Class Reference</h1><!-- doxytag: class="Xfc::Gtk::TextIter" --><!-- doxytag: inherits="Xfc::G::Boxed,Xfc::StackObject" -->A GtkTextIter C++ wrapper class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/gtk/textiter.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::Gtk::TextIter:
<p><center><img src="classXfc_1_1Gtk_1_1TextIter.png" usemap="#Xfc::Gtk::TextIter_map" border="0" alt=""></center>
<map name="Xfc::Gtk::TextIter_map">
<area href="classXfc_1_1G_1_1Boxed.html" alt="Xfc::G::Boxed" shape="rect" coords="0,112,121,136">
<area href="classXfc_1_1StackObject.html" alt="Xfc::StackObject" shape="rect" coords="131,112,252,136">
<area href="classXfc_1_1Object.html" alt="Xfc::Object" shape="rect" coords="0,56,121,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,121,24">
<area href="classXfc_1_1Gtk_1_1SourceIter.html" alt="Xfc::Gtk::SourceIter" shape="rect" coords="65,224,186,248">
</map>
<a href="classXfc_1_1Gtk_1_1TextIter-members.html">List of all members.</a><h2>Constructors</h2>
<ul>
<li><a class="anchor" name="16f1b54a886bf67c6b854e2274499b16"></a><!-- doxytag: member="Xfc::Gtk::TextIter::TextIter" ref="16f1b54a886bf67c6b854e2274499b16" args="()" -->
<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#16f1b54a886bf67c6b854e2274499b16">TextIter</a> ()
<dl class="el"><dd class="mdescRight">Construct an properly initialized text iterator. <br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#15cece10fd01404d4ade9e53b88be342">TextIter</a> (GtkTextIter *iter)
<dl class="el"><dd class="mdescRight">Construct a new text iterator from an existing GtkTextIter.  <a href="#15cece10fd01404d4ade9e53b88be342"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#4d4eee1504afac40388fb8c84d3af11a">TextIter</a> (GtkTextIter *iter, bool copy)
<dl class="el"><dd class="mdescRight">Construct a new text iterator from an existing GtkTextIter.  <a href="#4d4eee1504afac40388fb8c84d3af11a"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#83687b2f3a0cf0c6e34b9769accb60f6">TextIter</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;src)
<dl class="el"><dd class="mdescRight">Copy constructor.  <a href="#83687b2f3a0cf0c6e34b9769accb60f6"></a><br></dl><li><a class="anchor" name="d2a457c915c546fbf811ed42a66ca8ea"></a><!-- doxytag: member="Xfc::Gtk::TextIter::~TextIter" ref="d2a457c915c546fbf811ed42a66ca8ea" args="()" -->
<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#d2a457c915c546fbf811ed42a66ca8ea">~TextIter</a> ()
<dl class="el"><dd class="mdescRight">Destructor. <br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp; <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#72753231ab9b95a321af56c76126dc15">operator=</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;src)
<dl class="el"><dd class="mdescRight">Assignment operator.  <a href="#72753231ab9b95a321af56c76126dc15"></a><br></dl></ul>
<h2>Public Types</h2>
<ul>
<li>typedef sigc::slot&lt; bool,<br>
 <a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> &gt; <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#07b9abce2eb06fd426cdc9250a1d6ed2">TextCharPredicate</a>
<dl class="el"><dd class="mdescRight">Signature of the callback slot to be called on each character when searching a text buffer for characters with <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c0ed42e964d02c2d6440395b3b48a1a2">forward_find_char()</a> and <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#d549ba7ae03626e2fe79b3b889607710">backward_find_char()</a>.  <a href="#07b9abce2eb06fd426cdc9250a1d6ed2"></a><br></dl></ul>
<h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="8ece403b9b5f3f59ffe4fe90989debf2"></a><!-- doxytag: member="Xfc::Gtk::TextIter::gtk_text_iter" ref="8ece403b9b5f3f59ffe4fe90989debf2" args="() const" -->
GtkTextIter * <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8ece403b9b5f3f59ffe4fe90989debf2">gtk_text_iter</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GtkTextIter structure. <br></dl><li><a class="anchor" name="4a1739ff536de0526ce5dcd2d7c81318"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator GtkTextIter *" ref="4a1739ff536de0526ce5dcd2d7c81318" args="() const" -->
<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#4a1739ff536de0526ce5dcd2d7c81318">operator GtkTextIter *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; safely converts a <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> to a GtkTextIter pointer. <br></dl><li><a class="anchor" name="eeec51c259f48b801a10350f7697d172"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_buffer" ref="eeec51c259f48b801a10350f7697d172" args="() const" -->
<a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a> * <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#eeec51c259f48b801a10350f7697d172">get_buffer</a> () const
<dl class="el"><dd class="mdescRight">Returns the <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a> this iterator is associated with. <br></dl><li>int <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#1f2b809813a53177e6e37fb7df353f5a">get_offset</a> () const
<dl class="el"><dd class="mdescRight">Returns the character offset of an iterator.  <a href="#1f2b809813a53177e6e37fb7df353f5a"></a><br></dl><li>int <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#348685472a0b50408ab5766006c10672">get_line</a> () const
<dl class="el"><dd class="mdescRight">Returns the line number containing the iterator.  <a href="#348685472a0b50408ab5766006c10672"></a><br></dl><li>int <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#1f39faa61437f6fcaec705baec433f4b">get_line_offset</a> () const
<dl class="el"><dd class="mdescRight">Returns the character offset of the iterator, counting from the start of a newline-terminated line.  <a href="#1f39faa61437f6fcaec705baec433f4b"></a><br></dl><li>int <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#e663256677fa7af58b4966e066cb4a07">get_line_index</a> () const
<dl class="el"><dd class="mdescRight">Returns the byte index of the iterator, counting from the start of a newline-terminated line.  <a href="#e663256677fa7af58b4966e066cb4a07"></a><br></dl><li>int <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#09cb3b7851d18d4254e91b6243879d49">get_visible_line_offset</a> () const
<dl class="el"><dd class="mdescRight">Returns the offset in characters from the start of the line to the iterator, not counting characters that are invisible due to tags with the "invisible" flag toggled on.  <a href="#09cb3b7851d18d4254e91b6243879d49"></a><br></dl><li>int <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8615594f9eacfef00fcd894a46651e0b">get_visible_line_index</a> () const
<dl class="el"><dd class="mdescRight">Returns the number of bytes from the start of the line to the iterator, not counting bytes that are invisible due to tags with the "invisible" flag toggled on.  <a href="#8615594f9eacfef00fcd894a46651e0b"></a><br></dl><li><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8b78bb057daddfa3fbd9db5818d153c0">get_char</a> () const
<dl class="el"><dd class="mdescRight">Returns the Unicode character at this iterator.  <a href="#8b78bb057daddfa3fbd9db5818d153c0"></a><br></dl><li><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#235a99bcc6988ad744ccddcfe2ca37e4">operator *</a> () const
<dl class="el"><dd class="mdescRight">The dereference operator returns the Unicode character at this iterator.  <a href="#235a99bcc6988ad744ccddcfe2ca37e4"></a><br></dl><li><a class="anchor" name="bf0ad567a6bfed1e0a86b6cb1847fa40"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_pixbuf" ref="bf0ad567a6bfed1e0a86b6cb1847fa40" args="() const" -->
<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> * <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#bf0ad567a6bfed1e0a86b6cb1847fa40">get_pixbuf</a> () const
<dl class="el"><dd class="mdescRight">If the element at this iterator is a pixbuf, the pixbuf is returned (with no new reference count added), otherwise null is returned. <br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#6a3661b40ed48b34ac0bad78c9241cf6">get_marks</a> (std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> * &gt; &amp;marks) const
<dl class="el"><dd class="mdescRight">Retrieves a list of all <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> at this location.  <a href="#6a3661b40ed48b34ac0bad78c9241cf6"></a><br></dl><li><a class="anchor" name="d537250af93cf9b50da9cbf15c0699d1"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_child_anchor" ref="d537250af93cf9b50da9cbf15c0699d1" args="() const" -->
<a class="el" href="classXfc_1_1Gtk_1_1TextChildAnchor.html">TextChildAnchor</a> * <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#d537250af93cf9b50da9cbf15c0699d1">get_child_anchor</a> () const
<dl class="el"><dd class="mdescRight">If the location at this iterator contains a child anchor, the anchor is returned (with no new reference count added), otherwise, null is returned. <br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#45a6df8c6e47db36381374ef6e6b4bb4">get_toggled_tags</a> (std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> * &gt; &amp;tags, bool toggled_on) const
<dl class="el"><dd class="mdescRight">Retrieves a list of <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> that are toggled on or off at this point.  <a href="#45a6df8c6e47db36381374ef6e6b4bb4"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8171ff686c95ada38610ab4fc3e062b4">begins_tag</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> *tag=0) const
<dl class="el"><dd class="mdescRight">Returns true if tag is toggled on at exactly this point.  <a href="#8171ff686c95ada38610ab4fc3e062b4"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#15db45ceac556089ffdd89c7e8f75305">ends_tag</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> *tag=0) const
<dl class="el"><dd class="mdescRight">Returns true if tag is toggled off at exactly this point.  <a href="#15db45ceac556089ffdd89c7e8f75305"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#f41dafb04e9b1a0a96f63c307a077160">toggles_tag</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> *tag=0) const
<dl class="el"><dd class="mdescRight">This is equivalent to (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8171ff686c95ada38610ab4fc3e062b4">begins_tag()</a> || <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#15db45ceac556089ffdd89c7e8f75305">ends_tag()</a>), that is, it tells you whether a range with tag applied to it begins or ends at iter.  <a href="#f41dafb04e9b1a0a96f63c307a077160"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#5d353c66465f6346ffc3780816d8512b">has_tag</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> &amp;tag) const
<dl class="el"><dd class="mdescRight">Returns true if the iterator is within a range tagged with <em>tag</em>.  <a href="#5d353c66465f6346ffc3780816d8512b"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#ac082cf92f031457496689b8557fdc16">get_tags</a> (std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> * &gt; &amp;tags) const
<dl class="el"><dd class="mdescRight">Retrieves a list of tags that apply to this iterator, in ascending order of priority (highest-priority tags are last).  <a href="#ac082cf92f031457496689b8557fdc16"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c5c4ae6bfb1b6f951c4ec6edab931f66">editable</a> (bool default_setting) const 
<dl class="el"><dd class="mdescRight">Returns whether the character at the iterator is within an editable region of text.  <a href="#c5c4ae6bfb1b6f951c4ec6edab931f66"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#ae22fa451dd37f9dd28a3cf79c18a949">can_insert</a> (bool default_editability) const
<dl class="el"><dd class="mdescRight">Considering the default editability of the buffer, and tags that affect editability, determines whether text inserted at this iterator would be editable.  <a href="#ae22fa451dd37f9dd28a3cf79c18a949"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#b5563732c69ab5c7269a4ffdba656772">starts_word</a> () const
<dl class="el"><dd class="mdescRight">Determines whether the iterator begins a natural-language word.  <a href="#b5563732c69ab5c7269a4ffdba656772"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#46bc2aff104775b2728cc1ae0f7703b9">ends_word</a> () const
<dl class="el"><dd class="mdescRight">Determines whether the iterator ends a natural-language word.  <a href="#46bc2aff104775b2728cc1ae0f7703b9"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#2e46da52c12d185d9043757a0da72d28">inside_word</a> () const
<dl class="el"><dd class="mdescRight">Determines whether the iterator is inside a natural-language word (as opposed to say inside some whitespace).  <a href="#2e46da52c12d185d9043757a0da72d28"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#0ea41e4811988534e25600356b05b035">starts_sentence</a> () const
<dl class="el"><dd class="mdescRight">Determines whether the iterator begins a sentence.  <a href="#0ea41e4811988534e25600356b05b035"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#d6b7af94e82f28b67ef23c2b979ea755">ends_sentence</a> () const
<dl class="el"><dd class="mdescRight">Determines whether the iterator ends a sentence.  <a href="#d6b7af94e82f28b67ef23c2b979ea755"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#d032f34a29da6f88452505ad219e1ba5">inside_sentence</a> () const
<dl class="el"><dd class="mdescRight">Determines whether the iterator is inside a sentence (as opposed to in between two sentences, for example, after a period and before the first letter of the next sentence).  <a href="#d032f34a29da6f88452505ad219e1ba5"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#9ecf81e07662c7eff3002961ddb28910">starts_line</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the iterator begins a paragraph, that is, if <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#1f39faa61437f6fcaec705baec433f4b">get_line_offset()</a> would return 0.  <a href="#9ecf81e07662c7eff3002961ddb28910"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#6211c189a5cc8d5f23eea99a142176d0">ends_line</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the iterator points to the start of the paragraph delimiter characters for a line.  <a href="#6211c189a5cc8d5f23eea99a142176d0"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#dbb3b0df480e26cedc18a12313dafc0c">is_cursor_position</a> () const
<dl class="el"><dd class="mdescRight">Returns <em>true</em> if the cursor can be placed at this iterator.  <a href="#dbb3b0df480e26cedc18a12313dafc0c"></a><br></dl><li><a class="anchor" name="1639d5cc8de426da6d1cc9e07ea9b6bd"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_chars_in_line" ref="1639d5cc8de426da6d1cc9e07ea9b6bd" args="() const" -->
int <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#1639d5cc8de426da6d1cc9e07ea9b6bd">get_chars_in_line</a> () const
<dl class="el"><dd class="mdescRight">Returns the number of characters in the line containing this iterator, including the paragraph delimiters. <br></dl><li><a class="anchor" name="483d1d853f12e3b7042bdccf0dd85397"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_bytes_in_line" ref="483d1d853f12e3b7042bdccf0dd85397" args="() const" -->
int <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#483d1d853f12e3b7042bdccf0dd85397">get_bytes_in_line</a> () const
<dl class="el"><dd class="mdescRight">Returns the number of bytes in the line containing this iterator, including the paragraph delimiters. <br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#977ac073e2d22d032b9ebc6c4709cf3b">get_attributes</a> (<a class="el" href="classXfc_1_1Gtk_1_1TextAttributes.html">TextAttributes</a> &amp;values) const
<dl class="el"><dd class="mdescRight">Computes the effect of any tags applied to this spot in the text.  <a href="#977ac073e2d22d032b9ebc6c4709cf3b"></a><br></dl><li>PangoLanguage * <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#dc5535ce8aac3ca22598fbc0633f92a8">get_language</a> () const
<dl class="el"><dd class="mdescRight">A convenience wrapper around <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#977ac073e2d22d032b9ebc6c4709cf3b">get_attributes()</a>, which returns the language in effect at this iterator.  <a href="#dc5535ce8aac3ca22598fbc0633f92a8"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#e4277f43324fc7eea97070905ef96e9a">is_end</a> () const
<dl class="el"><dd class="mdescRight">Returns true if this iterator is the end iterator, that is, one past the last dereferenceable iterator in the buffer.  <a href="#e4277f43324fc7eea97070905ef96e9a"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#167aa4d16aa9add9eea77e047cd70e3f">is_start</a> () const
<dl class="el"><dd class="mdescRight">Returns true if this iterator is the first iterator in the buffer, that is, if iter has a character offset of 0.  <a href="#167aa4d16aa9add9eea77e047cd70e3f"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#9c4f8ad49595029ae6966a35c9e11108">equal</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;other) const
<dl class="el"><dd class="mdescRight">Tests whether two iterators are equal, using the fastest possible mechanism.  <a href="#9c4f8ad49595029ae6966a35c9e11108"></a><br></dl><li>int <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#74b63a8a1f2ed88d6dae69473d85cfec">compare</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;other) const
<dl class="el"><dd class="mdescRight">A qsort()-style method that returns negative if this iterator is less than <em>other</em>, positive if it's greater than <em>other</em>, and 0 it's equal to <em>other</em>.  <a href="#74b63a8a1f2ed88d6dae69473d85cfec"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#d4f7d909965464911015d5bc2e59e294">in_range</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Checks whether this iterator falls in the range (start, end); start and end must be in ascending order.  <a href="#d4f7d909965464911015d5bc2e59e294"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#45757f3d1bc4b60abde253fc96d02856">operator==</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;other) const
<dl class="el"><dd class="mdescRight">Returns true if this iterator is equal to other.  <a href="#45757f3d1bc4b60abde253fc96d02856"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#4bc0b437e301f3d498dcb80d86178d2e">operator!=</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;other) const
<dl class="el"><dd class="mdescRight">Returns true if this iterator is not equal to other.  <a href="#4bc0b437e301f3d498dcb80d86178d2e"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#909d6f7638e5061a8cdc2f6cbb4d2e2d">operator&lt;</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;other) const
<dl class="el"><dd class="mdescRight">Returns true if this iterator is less than other.  <a href="#909d6f7638e5061a8cdc2f6cbb4d2e2d"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#10973c8c0f729b066b304fd9150ae8c2">operator&gt;</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;other) const
<dl class="el"><dd class="mdescRight">Returns true if this iterator is greater than other.  <a href="#10973c8c0f729b066b304fd9150ae8c2"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#94cf742543d8b4f9b7d474a5147b1107">operator&lt;=</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;other) const
<dl class="el"><dd class="mdescRight">Returns true if this iterator is less than or equal to other.  <a href="#94cf742543d8b4f9b7d474a5147b1107"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#811b3955f423b913270f5d9e2fd8096f">operator&gt;=</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;other) const
<dl class="el"><dd class="mdescRight">Returns true if this iterator is greater than or equal to other.  <a href="#811b3955f423b913270f5d9e2fd8096f"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#50d718a5646dd7e0d669abd990d53626">forward_char</a> ()
<dl class="el"><dd class="mdescRight">Moves the iterator forward by one character offset.  <a href="#50d718a5646dd7e0d669abd990d53626"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#ac6a51a7cc31f22657ff6b9a47718cb6">backward_char</a> ()
<dl class="el"><dd class="mdescRight">Moves backward by one character offset.  <a href="#ac6a51a7cc31f22657ff6b9a47718cb6"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#6f61dfff953ac6c151405703c1365747">forward_chars</a> (int count)
<dl class="el"><dd class="mdescRight">Moves <em>count</em> characters if possible (if count would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="#6f61dfff953ac6c151405703c1365747"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c5c2a3da42e9848fdb5679317f096659">backward_chars</a> (int count)
<dl class="el"><dd class="mdescRight">Moves <em>count</em> characters backward, if possible (if count would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="#c5c2a3da42e9848fdb5679317f096659"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#a2c419d7711783a0922e22990bf8f740">forward_line</a> ()
<dl class="el"><dd class="mdescRight">Moves the iterator to the start of the next line.  <a href="#a2c419d7711783a0922e22990bf8f740"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#92875efc33d2263386e93d8264fc309a">backward_line</a> ()
<dl class="el"><dd class="mdescRight">Moves the iterator to the start of the previous line.  <a href="#92875efc33d2263386e93d8264fc309a"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#5c6480e558bb9cbe09e8e2be32c9496b">forward_lines</a> (int count)
<dl class="el"><dd class="mdescRight">Moves <em>count</em> lines forward, if possible (if count would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="#5c6480e558bb9cbe09e8e2be32c9496b"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#b27bfab0874194ab270fca37209d0649">backward_lines</a> (int count)
<dl class="el"><dd class="mdescRight">Moves <em>count</em> lines backward, if possible (if count would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="#b27bfab0874194ab270fca37209d0649"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#4fe5656179604e374b7d5ce9f97476ae">forward_word_end</a> ()
<dl class="el"><dd class="mdescRight">Moves forward to the next word end.  <a href="#4fe5656179604e374b7d5ce9f97476ae"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#b4caf91905822647e2e4ad2f9161dd2e">backward_word_start</a> ()
<dl class="el"><dd class="mdescRight">Moves backward to the previous word start.  <a href="#b4caf91905822647e2e4ad2f9161dd2e"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#5518984f357869edd3ea5f35fd1cd0f6">forward_word_ends</a> (int count)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#4fe5656179604e374b7d5ce9f97476ae">forward_word_end()</a> up to <em>count</em> times.  <a href="#5518984f357869edd3ea5f35fd1cd0f6"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#69886c1bee31808c02f12754003f78d5">backward_word_starts</a> (int count)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#b4caf91905822647e2e4ad2f9161dd2e">backward_word_start()</a> up to <em>count</em> times.  <a href="#69886c1bee31808c02f12754003f78d5"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#6fa52217855e4a4b46f3ba87e173eeb5">forward_visible_word_end</a> ()
<dl class="el"><dd class="mdescRight">Moves forward to the next visible word end.  <a href="#6fa52217855e4a4b46f3ba87e173eeb5"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#95862ef98161a91cd820fc256f18f94a">backward_visible_word_start</a> ()
<dl class="el"><dd class="mdescRight">Moves backward to the previous visible word start.  <a href="#95862ef98161a91cd820fc256f18f94a"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#9c33f3f6ff1a1504a9c187d349c66af2">forward_visible_word_ends</a> (int count)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#6fa52217855e4a4b46f3ba87e173eeb5">forward_visible_word_end()</a> up to count times.  <a href="#9c33f3f6ff1a1504a9c187d349c66af2"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#504d4985eaa2a2b7bcf96b396153fc0b">backward_visible_word_starts</a> (int count)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#95862ef98161a91cd820fc256f18f94a">backward_visible_word_start()</a> up to count times.  <a href="#504d4985eaa2a2b7bcf96b396153fc0b"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#103eca4d0192b029a03c5ffdfe0900bf">forward_sentence_end</a> ()
<dl class="el"><dd class="mdescRight">Moves forward to the next sentence end.  <a href="#103eca4d0192b029a03c5ffdfe0900bf"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#9fad63519c8ae6f86dd75eff5b766895">backward_sentence_start</a> ()
<dl class="el"><dd class="mdescRight">Moves backward to the previous sentence start.  <a href="#9fad63519c8ae6f86dd75eff5b766895"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#b7ccc81a8ff564cdd3937659cd80c879">forward_sentence_ends</a> (int count)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#103eca4d0192b029a03c5ffdfe0900bf">forward_sentence_end()</a> <em>count</em> times (or until <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#103eca4d0192b029a03c5ffdfe0900bf">forward_sentence_end()</a> returns false).  <a href="#b7ccc81a8ff564cdd3937659cd80c879"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c35a78ca50ba17a1f3dba249096b808d">backward_sentence_starts</a> (int count)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#9fad63519c8ae6f86dd75eff5b766895">backward_sentence_start()</a> up to <em>count</em> times, or until it returns false.  <a href="#c35a78ca50ba17a1f3dba249096b808d"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position</a> ()
<dl class="el"><dd class="mdescRight">Moves the iterator forward by a single cursor position.  <a href="#52593bb48c497310a17770acffb8a468"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8fc7ef8f2c0072092d3680e5fd3458f6">backward_cursor_position</a> ()
<dl class="el"><dd class="mdescRight">Like <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a>, but moves backward.  <a href="#8fc7ef8f2c0072092d3680e5fd3458f6"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#1cc41af53db7dd301b87b0a27f5ef0b8">forward_cursor_positions</a> (int count)
<dl class="el"><dd class="mdescRight">Moves up to <em>count</em> cursor positions (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a> for details).  <a href="#1cc41af53db7dd301b87b0a27f5ef0b8"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#374b782717943e6e9040172b01081a78">backward_cursor_positions</a> (int count)
<dl class="el"><dd class="mdescRight">Moves up to <em>count</em> cursor positions backwards (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a> for details).  <a href="#374b782717943e6e9040172b01081a78"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#b3a5f9253911959b48f2578a45c8fe65">forward_visible_cursor_position</a> ()
<dl class="el"><dd class="mdescRight">Moves the iterator forward to the next visible cursor position (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a> for details).  <a href="#b3a5f9253911959b48f2578a45c8fe65"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#0d7e1b7983771641218a3f432d6ddc17">backward_visible_cursor_position</a> ()
<dl class="el"><dd class="mdescRight">Moves the iterator backward to the previous visible cursor position (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8fc7ef8f2c0072092d3680e5fd3458f6">backward_cursor_position()</a> for details).  <a href="#0d7e1b7983771641218a3f432d6ddc17"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#2b86daf33b69ae6f5df67f3cfe5a389b">forward_visible_cursor_positions</a> (int count)
<dl class="el"><dd class="mdescRight">Moves the iterator up to count visible cursor positions (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a> for details).  <a href="#2b86daf33b69ae6f5df67f3cfe5a389b"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#d5eecb76e6103011d367d48d91d97fe2">backward_visible_cursor_positions</a> (int count)
<dl class="el"><dd class="mdescRight">Moves the iterator up to count visible cursor positions (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a> for details).  <a href="#d5eecb76e6103011d367d48d91d97fe2"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#6d1283468c33e093c1a71cb701eb6eea">set_offset</a> (int char_offset)
<dl class="el"><dd class="mdescRight">Sets the iterator to point to <em>char_offset</em>.  <a href="#6d1283468c33e093c1a71cb701eb6eea"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#12b6e4e781c1bebed64de33eb5b3ffd5">set_line</a> (int line_number)
<dl class="el"><dd class="mdescRight">Moves the iterator to the start of the line <em>line_number</em>.  <a href="#12b6e4e781c1bebed64de33eb5b3ffd5"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#42c521feec8321601f9abee97dd59afb">set_line_offset</a> (int char_on_line)
<dl class="el"><dd class="mdescRight">Moves the iterator within a line, to a new character (not byte) offset.  <a href="#42c521feec8321601f9abee97dd59afb"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#a34cc8197fd8c654c40f6451001d52a1">set_line_index</a> (int byte_on_line)
<dl class="el"><dd class="mdescRight">Same as <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#42c521feec8321601f9abee97dd59afb">set_line_offset()</a>, but works with a byte index.  <a href="#a34cc8197fd8c654c40f6451001d52a1"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c7a4bc35b00e3a5055dee3f1139ffcea">set_visible_line_offset</a> (int char_on_line)
<dl class="el"><dd class="mdescRight">Like <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#42c521feec8321601f9abee97dd59afb">set_line_offset()</a>, but the offset is in visible characters, that is, text with a tag making it invisible is not counted in the offset.  <a href="#c7a4bc35b00e3a5055dee3f1139ffcea"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#1b457bbd4228930b4873f8ea5a17f3c1">set_visible_line_index</a> (int byte_on_line)
<dl class="el"><dd class="mdescRight">Like <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#a34cc8197fd8c654c40f6451001d52a1">set_line_index()</a>, but the index is in visible bytes, that is, text with a tag making it invisible is not counted in the index.  <a href="#1b457bbd4228930b4873f8ea5a17f3c1"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#cba3e89f31faa1e8b6b643338d9a2bc8">forward_to_end</a> ()
<dl class="el"><dd class="mdescRight">Moves the iterator forward to the "end iterator", which points one past the last valid character in the buffer.  <a href="#cba3e89f31faa1e8b6b643338d9a2bc8"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#7c0805cb4c1f47fb3f2233a5e22e82c6">forward_to_line_end</a> ()
<dl class="el"><dd class="mdescRight">Moves the iterator to point to the paragraph delimiter characters, which will be either a newline, a carriage return, a carriage return/newline in sequence, or the Unicode paragraph separator character.  <a href="#7c0805cb4c1f47fb3f2233a5e22e82c6"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c1393a3e5828e2195ebfb37498dd3610">forward_to_tag_toggle</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> *tag=0)
<dl class="el"><dd class="mdescRight">Moves forward to the next toggle (on or off) of the <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is null.  <a href="#c1393a3e5828e2195ebfb37498dd3610"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#9e4a846d3ab5327492032bb47a3b1a7b">backward_to_tag_toggle</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> *tag=0)
<dl class="el"><dd class="mdescRight">Moves backward to the next toggle (on or off) of the <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is null.  <a href="#9e4a846d3ab5327492032bb47a3b1a7b"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c0ed42e964d02c2d6440395b3b48a1a2">forward_find_char</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#07b9abce2eb06fd426cdc9250a1d6ed2">TextCharPredicate</a> &amp;predicate, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *limit=0)
<dl class="el"><dd class="mdescRight">Advances the iterator, calling <em>predicate</em> on each character.  <a href="#c0ed42e964d02c2d6440395b3b48a1a2"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#d549ba7ae03626e2fe79b3b889607710">backward_find_char</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#07b9abce2eb06fd426cdc9250a1d6ed2">TextCharPredicate</a> &amp;predicate, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *limit=0)
<dl class="el"><dd class="mdescRight">Same as <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c0ed42e964d02c2d6440395b3b48a1a2">forward_find_char()</a>, but goes backward from the iterator.  <a href="#d549ba7ae03626e2fe79b3b889607710"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#bcdeafa8989c2aa67949103de9b87e9e">forward_search</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *limit=0)
<dl class="el"><dd class="mdescRight">Searches forward for <em>str</em>.  <a href="#bcdeafa8989c2aa67949103de9b87e9e"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#16d1b02edd01d655e442132b9c93eb84">forward_search</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *match_start, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *match_end, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *limit=0)
<dl class="el"><dd class="mdescRight">Searches forward for <em>str</em>.  <a href="#16d1b02edd01d655e442132b9c93eb84"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#f02083557830f4e44109dd680e12a77f">forward_search</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, <a class="el" href="namespaceXfc_1_1Gtk.html#29e0bc5b6206932b4fdce85ae95ad4a6">TextSearchFlagsField</a> flags, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *match_start, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *match_end, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *limit=0)
<dl class="el"><dd class="mdescRight">Searches forward for <em>str</em>.  <a href="#f02083557830f4e44109dd680e12a77f"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#95a1985957a63f65795d5dd9404cd837">backward_search</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *limit=0)
<dl class="el"><dd class="mdescRight">Same as forward_search(), but moves backward.  <a href="#95a1985957a63f65795d5dd9404cd837"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#038610ee313e20f1b21ae078fb4cb966">backward_search</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *match_start, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *match_end, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *limit=0)
<dl class="el"><dd class="mdescRight">Same as forward_search(), but moves backward.  <a href="#038610ee313e20f1b21ae078fb4cb966"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#992840862a73be1edf495bc255035152">backward_search</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, <a class="el" href="namespaceXfc_1_1Gtk.html#29e0bc5b6206932b4fdce85ae95ad4a6">TextSearchFlagsField</a> flags, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *match_start, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *match_end, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *limit=0)
<dl class="el"><dd class="mdescRight">Same as forward_search(), but moves backward.  <a href="#992840862a73be1edf495bc255035152"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#35c4ebc160378adc2c95449485626eeb">operator+</a> (int chars) const
<dl class="el"><dd class="mdescRight">Returns a <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> to the position <em>chars</em> characters from this iterator in a forward direction.  <a href="#35c4ebc160378adc2c95449485626eeb"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8e471e8f16028b461e415ea38bcb901f">operator-</a> (int chars) const
<dl class="el"><dd class="mdescRight">Returns a <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> to the position <em>chars</em> characters from this iterator in a backward direction.  <a href="#8e471e8f16028b461e415ea38bcb901f"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp; <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#28746896550bc7e20f82ff28484b7097">operator+=</a> (int chars)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#6f61dfff953ac6c151405703c1365747">forward_chars()</a> to move this iterator forward <em>chars</em> characters.  <a href="#28746896550bc7e20f82ff28484b7097"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp; <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#259a50cf49b1fdabda0473aa65004e66">operator-=</a> (int chars)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c5c2a3da42e9848fdb5679317f096659">backward_chars()</a> to move this iterator backward <em>chars</em> characters.  <a href="#259a50cf49b1fdabda0473aa65004e66"></a><br></dl><li><a class="anchor" name="6dfdbd4ec75c22a699ece011506e667e"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator++" ref="6dfdbd4ec75c22a699ece011506e667e" args="()" -->
<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp; <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#6dfdbd4ec75c22a699ece011506e667e">operator++</a> ()
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#50d718a5646dd7e0d669abd990d53626">forward_char()</a> to move this iterator forward one character. <br></dl><li><a class="anchor" name="089fde2b0bb9b7f298233f639451d509"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator--" ref="089fde2b0bb9b7f298233f639451d509" args="()" -->
<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp; <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#089fde2b0bb9b7f298233f639451d509">operator--</a> ()
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#ac6a51a7cc31f22657ff6b9a47718cb6">backward_char()</a> to move this iterator back one character. <br></dl><li><a class="anchor" name="98451bf0c3d0ea906f7c6f140da7990f"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator++" ref="98451bf0c3d0ea906f7c6f140da7990f" args="(int)" -->
<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#98451bf0c3d0ea906f7c6f140da7990f">operator++</a> (int)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#50d718a5646dd7e0d669abd990d53626">forward_char()</a> to move this iterator forward one character. <br></dl><li><a class="anchor" name="60ade8f0ba8131d4f21efb4403ff5caf"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator--" ref="60ade8f0ba8131d4f21efb4403ff5caf" args="(int)" -->
<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#60ade8f0ba8131d4f21efb4403ff5caf">operator--</a> (int)
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#ac6a51a7cc31f22657ff6b9a47718cb6">backward_char()</a> to move this iterator back one character. <br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c9e9a72a3968547f85bb8ed105c4c951">get_slice</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Returns the text in the given range.  <a href="#c9e9a72a3968547f85bb8ed105c4c951"></a><br></dl><li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c51a6e912fca229dcff76ffe2fc7bae9">get_text</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Returns the text in the given range.  <a href="#c51a6e912fca229dcff76ffe2fc7bae9"></a><br></dl><li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#871cd7b71e5e4c49310674efdff582c9">get_visible_slice</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Like <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c9e9a72a3968547f85bb8ed105c4c951">get_slice()</a>, but invisible text is not included.  <a href="#871cd7b71e5e4c49310674efdff582c9"></a><br></dl><li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#e9397ca89241b2d678bfb7ad23c38e5f">get_visible_text</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;end)
<dl class="el"><dd class="mdescRight">Like <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c51a6e912fca229dcff76ffe2fc7bae9">get_text()</a>, but invisible text is not included.  <a href="#e9397ca89241b2d678bfb7ad23c38e5f"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>static void <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#0270f87261a13c3e9b337904c9c855c0">order</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;first, const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;second)
<dl class="el"><dd class="mdescRight">Swaps the value of first and second if second comes before first in the buffer.  <a href="#0270f87261a13c3e9b337904c9c855c0"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GtkTextIter C++ wrapper class. 
<p>
Most text manipulation in a <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a> is accomplished with iterators, represented by a <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>. An iterator represents a position between two characters in a text buffer. <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> is a class designed to be allocated on the stack; it's guaranteed to be copiable by value and never contain any heap-allocated data. Iterators are not valid indefinitely; whenever the buffer is modified in a way that affects the number of characters in the buffer, all outstanding iterators become invalid. (Note that deleting 5 characters and then reinserting 5 still invalidates iterators, though you end up with the same number of characters you pass through a state with a different number). Because of this, iterators can't be used to preserve positions across buffer modifications. To preserve a position you would use the <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> object. <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> is a <a class="el" href="classXfc_1_1StackObject.html">StackObject</a> and can only be created on the stack.<p>
<b>See also:</b> the <a href="../../howto/html/textview.html">TextView Widget</a> HOWTO and example. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="07b9abce2eb06fd426cdc9250a1d6ed2"></a><!-- doxytag: member="Xfc::Gtk::TextIter::TextCharPredicate" ref="07b9abce2eb06fd426cdc9250a1d6ed2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef sigc::slot&lt;bool, <a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a>&gt; <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#07b9abce2eb06fd426cdc9250a1d6ed2">Xfc::Gtk::TextIter::TextCharPredicate</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signature of the callback slot to be called on each character when searching a text buffer for characters with <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c0ed42e964d02c2d6440395b3b48a1a2">forward_find_char()</a> and <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#d549ba7ae03626e2fe79b3b889607710">backward_find_char()</a>. 
<p>
<b>Example:</b> Method signature for TextCharPredicate. <div class="fragment"><pre class="fragment">&lt; <span class="keywordtype">bool</span> method(G::UniChar ch);
&lt;
&lt; <span class="comment">// ch: The Unicode character.</span>
&lt;
</pre></div> 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="15cece10fd01404d4ade9e53b88be342"></a><!-- doxytag: member="Xfc::Gtk::TextIter::TextIter" ref="15cece10fd01404d4ade9e53b88be342" args="(GtkTextIter *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::TextIter::TextIter           </td>
          <td>(</td>
          <td class="paramtype">GtkTextIter *&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new text iterator from an existing GtkTextIter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A pointer to a GtkTextIter.</td></tr>
  </table>
</dl>
The <em>iter</em> can be a newly created GtkTextIter or an existing GtkTextIter. The <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> object created is a temporary object. It doesn't take over the ownership of GtkTextIter and GtkTextIter is not freed by the destructor. 
</div>
</div><p>
<a class="anchor" name="4d4eee1504afac40388fb8c84d3af11a"></a><!-- doxytag: member="Xfc::Gtk::TextIter::TextIter" ref="4d4eee1504afac40388fb8c84d3af11a" args="(GtkTextIter *iter, bool copy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::TextIter::TextIter           </td>
          <td>(</td>
          <td class="paramtype">GtkTextIter *&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new text iterator from an existing GtkTextIter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A pointer to a GtkTextIter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy</em>&nbsp;</td><td>Whether the <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> object should make a copy of GtkTextIter or not.</td></tr>
  </table>
</dl>
The <em>iter</em> can be a newly created GtkTextIter or an existing GtkTextIter. If <em>copy</em> is true <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> will make a copy of GtkTextIter. If <em>copy</em> is false <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> wont make a copy but instead takes over the ownership of GtkTextIter. Either way, the destructor will free GtkTextIter when the <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> object is destroyed. This constructor is used by <a class="el" href="classXfc_1_1G_1_1Boxed.html#3e966b09f36600f34a087d5f3a1a77fc">G::Boxed::wrap()</a> to wrap GtkTextIter objects in a C++ wrapper. 
</div>
</div><p>
<a class="anchor" name="83687b2f3a0cf0c6e34b9769accb60f6"></a><!-- doxytag: member="Xfc::Gtk::TextIter::TextIter" ref="83687b2f3a0cf0c6e34b9769accb60f6" args="(const TextIter &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::TextIter::TextIter           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source iterator. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="72753231ab9b95a321af56c76126dc15"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator=" ref="72753231ab9b95a321af56c76126dc15" args="(const TextIter &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>&amp; Xfc::Gtk::TextIter::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source iterator. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1f2b809813a53177e6e37fb7df353f5a"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_offset" ref="1f2b809813a53177e6e37fb7df353f5a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Gtk::TextIter::get_offset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the character offset of an iterator. 
<p>
Each character in a <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a> has an offset, starting with 0 for the first character in the buffer. Use <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#b5eed4fe253e60312e908200ad56c7e7">Gtk::TextBuffer::get_iter_at_offset()</a> to convert an offset back into an iterator. 
</div>
</div><p>
<a class="anchor" name="348685472a0b50408ab5766006c10672"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_line" ref="348685472a0b50408ab5766006c10672" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Gtk::TextIter::get_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the line number containing the iterator. 
<p>
Lines in a <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a> are numbered beginning with 0 for the first line in the buffer. 
</div>
</div><p>
<a class="anchor" name="1f39faa61437f6fcaec705baec433f4b"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_line_offset" ref="1f39faa61437f6fcaec705baec433f4b" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Gtk::TextIter::get_line_offset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the character offset of the iterator, counting from the start of a newline-terminated line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset from start of line.</dd></dl>
The first character on the line has offset 0. 
</div>
</div><p>
<a class="anchor" name="e663256677fa7af58b4966e066cb4a07"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_line_index" ref="e663256677fa7af58b4966e066cb4a07" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Gtk::TextIter::get_line_index           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the byte index of the iterator, counting from the start of a newline-terminated line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The distance from start of line, in bytes.</dd></dl>
Remember that <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html">TextBuffer</a> encodes text in UTF-8, and that characters can require a variable number of bytes to represent them. 
</div>
</div><p>
<a class="anchor" name="09cb3b7851d18d4254e91b6243879d49"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_visible_line_offset" ref="09cb3b7851d18d4254e91b6243879d49" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Gtk::TextIter::get_visible_line_offset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the offset in characters from the start of the line to the iterator, not counting characters that are invisible due to tags with the "invisible" flag toggled on. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset in visible characters from the start of the line. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8615594f9eacfef00fcd894a46651e0b"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_visible_line_index" ref="8615594f9eacfef00fcd894a46651e0b" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Gtk::TextIter::get_visible_line_index           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of bytes from the start of the line to the iterator, not counting bytes that are invisible due to tags with the "invisible" flag toggled on. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The byte index of iterator with respect to the start of the line. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b78bb057daddfa3fbd9db5818d153c0"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_char" ref="8b78bb057daddfa3fbd9db5818d153c0" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> Xfc::Gtk::TextIter::get_char           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the Unicode character at this iterator. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A Unicode character, or 0 if the iterator is not dereferenceable.</dd></dl>
Equivalent to using the dereference operator on the iterator. If the element at this iterator is a non-character element, such as an image embedded in the buffer, the Unicode "unknown" character 0xFFFC is returned. If invoked on the end iterator, zero is returned; zero is not a valid Unicode character. So you can write a loop which ends when <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8b78bb057daddfa3fbd9db5818d153c0">get_char()</a> returns 0. 
</div>
</div><p>
<a class="anchor" name="235a99bcc6988ad744ccddcfe2ca37e4"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator *" ref="235a99bcc6988ad744ccddcfe2ca37e4" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> Xfc::Gtk::TextIter::operator *           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The dereference operator returns the Unicode character at this iterator. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A Unicode character, or 0 if iter is not dereferenceable.</dd></dl>
Equivalent to calling <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8b78bb057daddfa3fbd9db5818d153c0">get_char()</a> on the iterator. If the element at this iterator is a non-character element, such as an image embedded in the buffer, the Unicode "unknown" character 0xFFFC is returned. If invoked on the end iterator, zero is returned; zero is not a valid Unicode character. So you can write a loop which ends when <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8b78bb057daddfa3fbd9db5818d153c0">get_char()</a> returns 0. 
</div>
</div><p>
<a class="anchor" name="6a3661b40ed48b34ac0bad78c9241cf6"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_marks" ref="6a3661b40ed48b34ac0bad78c9241cf6" args="(std::vector&lt; TextMark * &gt; &amp;marks) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::get_marks           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>marks</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a list of all <a class="el" href="classXfc_1_1Gtk_1_1TextMark.html">TextMark</a> at this location. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>marks</em>&nbsp;</td><td>A reference to a vector of TextMark* to hold the marks. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if any marks were retrieved.</dd></dl>
Because marks are not iterable (they don't take up any "space" in the buffer, they are just marks in between iterable locations), multiple marks can exist in the same place. The marks retrieved are not in any meaningful order. 
</div>
</div><p>
<a class="anchor" name="45a6df8c6e47db36381374ef6e6b4bb4"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_toggled_tags" ref="45a6df8c6e47db36381374ef6e6b4bb4" args="(std::vector&lt; TextTag * &gt; &amp;tags, bool toggled_on) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::get_toggled_tags           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>toggled_on</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a list of <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> that are toggled on or off at this point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tags</em>&nbsp;</td><td>A reference to a vector of TextTag* to hold the tags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toggled_on</em>&nbsp;</td><td><em>true</em> to get toggled-on tags. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if any tags are retrieved.</dd></dl>
If toggled_on is true, the list contains tags that are toggled on. If a tag is toggled on at this iterator, then some non-empty range of characters following the iterator has that tag applied to it. If a tag is toggled off, then some non-empty range following the iterator does not have the tag applied to it. 
</div>
</div><p>
<a class="anchor" name="8171ff686c95ada38610ab4fc3e062b4"></a><!-- doxytag: member="Xfc::Gtk::TextIter::begins_tag" ref="8171ff686c95ada38610ab4fc3e062b4" args="(const TextTag *tag=0) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::begins_tag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> *&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if tag is toggled on at exactly this point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>, or null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether this iterator is the start of a range tagged with tag.</dd></dl>
If tag is null, returns true if any tag is toggled on at this point. Note that the <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8171ff686c95ada38610ab4fc3e062b4">begins_tag()</a> returns true if the iterator is the start of the tagged range; <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#5d353c66465f6346ffc3780816d8512b">has_tag()</a> tells you whether the iterator is within a tagged range. 
</div>
</div><p>
<a class="anchor" name="15db45ceac556089ffdd89c7e8f75305"></a><!-- doxytag: member="Xfc::Gtk::TextIter::ends_tag" ref="15db45ceac556089ffdd89c7e8f75305" args="(const TextTag *tag=0) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::ends_tag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> *&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if tag is toggled off at exactly this point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>, or null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether this iterator is the end of a range tagged with tag.</dd></dl>
If tag is null, returns true if any tag is toggled off at this point. Note that the <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#15db45ceac556089ffdd89c7e8f75305">ends_tag()</a> returns true if iter is the end of the tagged range; <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#5d353c66465f6346ffc3780816d8512b">has_tag()</a> tells you whether an iterator is within a tagged range. 
</div>
</div><p>
<a class="anchor" name="f41dafb04e9b1a0a96f63c307a077160"></a><!-- doxytag: member="Xfc::Gtk::TextIter::toggles_tag" ref="f41dafb04e9b1a0a96f63c307a077160" args="(const TextTag *tag=0) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::toggles_tag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> *&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is equivalent to (<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8171ff686c95ada38610ab4fc3e062b4">begins_tag()</a> || <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#15db45ceac556089ffdd89c7e8f75305">ends_tag()</a>), that is, it tells you whether a range with tag applied to it begins or ends at iter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>, or null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>tag</em> is toggled on or off at this iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d353c66465f6346ffc3780816d8512b"></a><!-- doxytag: member="Xfc::Gtk::TextIter::has_tag" ref="5d353c66465f6346ffc3780816d8512b" args="(const TextTag &amp;tag) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::has_tag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the iterator is within a range tagged with <em>tag</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether this iterator is tagged with tag. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac082cf92f031457496689b8557fdc16"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_tags" ref="ac082cf92f031457496689b8557fdc16" args="(std::vector&lt; TextTag * &gt; &amp;tags) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::get_tags           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a list of tags that apply to this iterator, in ascending order of priority (highest-priority tags are last). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tags</em>&nbsp;</td><td>A reference to a vector of TextTag* to hold the tags. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if any tags were retrieved.</dd></dl>
The <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> in the vector don't have a reference added. 
</div>
</div><p>
<a class="anchor" name="c5c4ae6bfb1b6f951c4ec6edab931f66"></a><!-- doxytag: member="Xfc::Gtk::TextIter::editable" ref="c5c4ae6bfb1b6f951c4ec6edab931f66" args="(bool default_setting) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::editable           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the character at the iterator is within an editable region of text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>default_setting</em>&nbsp;</td><td><em>true</em> if text is editable by default. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the iterator is inside an editable range.</dd></dl>
Non-editable text is "locked" and can't be changed by the user via <a class="el" href="classXfc_1_1Gtk_1_1TextView.html">TextView</a>. This method is simply a convenience wrapper around <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#977ac073e2d22d032b9ebc6c4709cf3b">get_attributes()</a>. If no tags applied to this text affect editability, <em>default_setting</em> will be returned.<p>
You don't want to use this method to decide whether text can be inserted at the iterator, because for insertion you don't want to know whether the char at the iterator is inside an editable range, you want to know whether a new character inserted at the iterator would be inside an editable range. Use <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#ae22fa451dd37f9dd28a3cf79c18a949">can_insert()</a> to handle this case. 
</div>
</div><p>
<a class="anchor" name="ae22fa451dd37f9dd28a3cf79c18a949"></a><!-- doxytag: member="Xfc::Gtk::TextIter::can_insert" ref="ae22fa451dd37f9dd28a3cf79c18a949" args="(bool default_editability) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::can_insert           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editability</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Considering the default editability of the buffer, and tags that affect editability, determines whether text inserted at this iterator would be editable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>default_editability</em>&nbsp;</td><td><em>true</em> if text is editable by default. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text inserted at the iterator would be editable.</dd></dl>
If text inserted at the iterator would be editable then the user should be allowed to insert text at the iterator. <a class="el" href="classXfc_1_1Gtk_1_1TextBuffer.html#67736bce78aea5b45e7af99289e02bb6">Gtk::TextBuffer::insert_interactive()</a> uses this method to decide whether insertions are allowed at a given position. 
</div>
</div><p>
<a class="anchor" name="b5563732c69ab5c7269a4ffdba656772"></a><!-- doxytag: member="Xfc::Gtk::TextIter::starts_word" ref="b5563732c69ab5c7269a4ffdba656772" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::starts_word           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the iterator begins a natural-language word. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator is at the start of a word.</dd></dl>
Word breaks are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> word break algorithms). 
</div>
</div><p>
<a class="anchor" name="46bc2aff104775b2728cc1ae0f7703b9"></a><!-- doxytag: member="Xfc::Gtk::TextIter::ends_word" ref="46bc2aff104775b2728cc1ae0f7703b9" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::ends_word           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the iterator ends a natural-language word. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator is at the end of a word.</dd></dl>
Word breaks are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> word break algorithms). 
</div>
</div><p>
<a class="anchor" name="2e46da52c12d185d9043757a0da72d28"></a><!-- doxytag: member="Xfc::Gtk::TextIter::inside_word" ref="2e46da52c12d185d9043757a0da72d28" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::inside_word           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the iterator is inside a natural-language word (as opposed to say inside some whitespace). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator is inside a word.</dd></dl>
Word breaks are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> word break algorithms). 
</div>
</div><p>
<a class="anchor" name="0ea41e4811988534e25600356b05b035"></a><!-- doxytag: member="Xfc::Gtk::TextIter::starts_sentence" ref="0ea41e4811988534e25600356b05b035" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::starts_sentence           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the iterator begins a sentence. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator is at the start of a sentence.</dd></dl>
Sentence boundaries are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> text boundary algorithms). 
</div>
</div><p>
<a class="anchor" name="d6b7af94e82f28b67ef23c2b979ea755"></a><!-- doxytag: member="Xfc::Gtk::TextIter::ends_sentence" ref="d6b7af94e82f28b67ef23c2b979ea755" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::ends_sentence           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the iterator ends a sentence. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator is at the end of a sentence.</dd></dl>
Sentence boundaries are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> text boundary algorithms). 
</div>
</div><p>
<a class="anchor" name="d032f34a29da6f88452505ad219e1ba5"></a><!-- doxytag: member="Xfc::Gtk::TextIter::inside_sentence" ref="d032f34a29da6f88452505ad219e1ba5" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::inside_sentence           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the iterator is inside a sentence (as opposed to in between two sentences, for example, after a period and before the first letter of the next sentence). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator is inside a sentence.</dd></dl>
Sentence boundaries are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> text boundary algorithms). 
</div>
</div><p>
<a class="anchor" name="9ecf81e07662c7eff3002961ddb28910"></a><!-- doxytag: member="Xfc::Gtk::TextIter::starts_line" ref="9ecf81e07662c7eff3002961ddb28910" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::starts_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the iterator begins a paragraph, that is, if <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#1f39faa61437f6fcaec705baec433f4b">get_line_offset()</a> would return 0. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the iterator begins a line.</dd></dl>
This method is potentially more efficient than <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#1f39faa61437f6fcaec705baec433f4b">get_line_offset()</a> because it doesn't have to compute the offset, it just has to see whether it's 0. 
</div>
</div><p>
<a class="anchor" name="6211c189a5cc8d5f23eea99a142176d0"></a><!-- doxytag: member="Xfc::Gtk::TextIter::ends_line" ref="6211c189a5cc8d5f23eea99a142176d0" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::ends_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the iterator points to the start of the paragraph delimiter characters for a line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the iterator is at the end of a line.</dd></dl>
Delimiters will be either a newline, a carriage return, a carriage return followed by a newline, or a Unicode paragraph separator character. Note that an iterator pointing to the \n of a \r\n pair will not be counted as the end of a line, the line ends before the \r. The end iterator is considered to be at the end of a line, even though there are no paragraph delimiter chars there. 
</div>
</div><p>
<a class="anchor" name="dbb3b0df480e26cedc18a12313dafc0c"></a><!-- doxytag: member="Xfc::Gtk::TextIter::is_cursor_position" ref="dbb3b0df480e26cedc18a12313dafc0c" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::is_cursor_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <em>true</em> if the cursor can be placed at this iterator. 
<p>
See <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a> or PangoLogAttr or pango_break() for details on what a cursor position is. 
</div>
</div><p>
<a class="anchor" name="977ac073e2d22d032b9ebc6c4709cf3b"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_attributes" ref="977ac073e2d22d032b9ebc6c4709cf3b" args="(TextAttributes &amp;values) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::get_attributes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextAttributes.html">TextAttributes</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>values</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the effect of any tags applied to this spot in the text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextAttributes.html">TextAttributes</a> to be filled in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if values was modified.</dd></dl>
The values parameter should be initialized to the default settings you wish to use if no tags are in effect. You'd typically obtain the defaults from <a class="el" href="classXfc_1_1Gtk_1_1TextView.html#d4f67179a8d3de746da0079ed54c41b1">Gtk::TextView::get_default_attributes()</a>.<p>
<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#977ac073e2d22d032b9ebc6c4709cf3b">get_attributes()</a> will modify values, applying the effects of any tags present at the iterator. If any tags affected values, the function returns true. 
</div>
</div><p>
<a class="anchor" name="dc5535ce8aac3ca22598fbc0633f92a8"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_language" ref="dc5535ce8aac3ca22598fbc0633f92a8" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PangoLanguage* Xfc::Gtk::TextIter::get_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A convenience wrapper around <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#977ac073e2d22d032b9ebc6c4709cf3b">get_attributes()</a>, which returns the language in effect at this iterator. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The language in effect at the iterator.</dd></dl>
If no tags affecting language apply to the iterator, the return value is identical to that of gtk_get_default_language(). 
</div>
</div><p>
<a class="anchor" name="e4277f43324fc7eea97070905ef96e9a"></a><!-- doxytag: member="Xfc::Gtk::TextIter::is_end" ref="e4277f43324fc7eea97070905ef96e9a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::is_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this iterator is the end iterator, that is, one past the last dereferenceable iterator in the buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the iterator is the end iterator.</dd></dl>
<a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#e4277f43324fc7eea97070905ef96e9a">is_end()</a> is the most efficient way to check whether an iterator is the end iterator. 
</div>
</div><p>
<a class="anchor" name="167aa4d16aa9add9eea77e047cd70e3f"></a><!-- doxytag: member="Xfc::Gtk::TextIter::is_start" ref="167aa4d16aa9add9eea77e047cd70e3f" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::is_start           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this iterator is the first iterator in the buffer, that is, if iter has a character offset of 0. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the iterator is the first in the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c4f8ad49595029ae6966a35c9e11108"></a><!-- doxytag: member="Xfc::Gtk::TextIter::equal" ref="9c4f8ad49595029ae6966a35c9e11108" args="(const TextIter &amp;other) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::equal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests whether two iterators are equal, using the fastest possible mechanism. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>Another <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterators point to the same place in the buffer.</dd></dl>
This method is very fast; you can expect it to perform better than for example, getting the character offset for each iterator and comparing the offsets yourself. Also, it's a bit faster than <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#74b63a8a1f2ed88d6dae69473d85cfec">compare()</a>. 
</div>
</div><p>
<a class="anchor" name="74b63a8a1f2ed88d6dae69473d85cfec"></a><!-- doxytag: member="Xfc::Gtk::TextIter::compare" ref="74b63a8a1f2ed88d6dae69473d85cfec" args="(const TextIter &amp;other) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Gtk::TextIter::compare           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A qsort()-style method that returns negative if this iterator is less than <em>other</em>, positive if it's greater than <em>other</em>, and 0 it's equal to <em>other</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>Another <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 if this iterator is less than other, 1 if it's greater, 0 if they are equal.</dd></dl>
Ordering is in character offset order, that is, the first character in the buffer is less than the second character in the buffer. 
</div>
</div><p>
<a class="anchor" name="d4f7d909965464911015d5bc2e59e294"></a><!-- doxytag: member="Xfc::Gtk::TextIter::in_range" ref="d4f7d909965464911015d5bc2e59e294" args="(const TextIter &amp;start, const TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::in_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether this iterator falls in the range (start, end); start and end must be in ascending order. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The start of range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The end of range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if this iterator is in the range. </dd></dl>

</div>
</div><p>
<a class="anchor" name="45757f3d1bc4b60abde253fc96d02856"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator==" ref="45757f3d1bc4b60abde253fc96d02856" args="(const TextIter &amp;other) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this iterator is equal to other. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>Another <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4bc0b437e301f3d498dcb80d86178d2e"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator!=" ref="4bc0b437e301f3d498dcb80d86178d2e" args="(const TextIter &amp;other) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this iterator is not equal to other. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>Another <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="909d6f7638e5061a8cdc2f6cbb4d2e2d"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator&lt;" ref="909d6f7638e5061a8cdc2f6cbb4d2e2d" args="(const TextIter &amp;other) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this iterator is less than other. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>Another <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="10973c8c0f729b066b304fd9150ae8c2"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator&gt;" ref="10973c8c0f729b066b304fd9150ae8c2" args="(const TextIter &amp;other) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::operator&gt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this iterator is greater than other. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>Another <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="94cf742543d8b4f9b7d474a5147b1107"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator&lt;=" ref="94cf742543d8b4f9b7d474a5147b1107" args="(const TextIter &amp;other) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this iterator is less than or equal to other. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>Another <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="811b3955f423b913270f5d9e2fd8096f"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator&gt;=" ref="811b3955f423b913270f5d9e2fd8096f" args="(const TextIter &amp;other) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this iterator is greater than or equal to other. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>Another <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c9e9a72a3968547f85bb8ed105c4c951"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_slice" ref="c9e9a72a3968547f85bb8ed105c4c951" args="(const TextIter &amp;start, const TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::Gtk::TextIter::get_slice           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the text in the given range. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The iterator at start of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The iterator at end of a range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A slice of text from the buffer.</dd></dl>
A "slice" is an array of characters encoded in UTF-8 format, including the Unicode "unknown" character 0xFFFC for iterable non-character elements in the buffer, such as images. Because images are encoded in the slice, byte and character offsets in the returned <a class="el" href="classXfc_1_1String.html">String</a> will correspond to byte offsets in the text buffer. Note that 0xFFFC can occur in normal text as well, so it is not a reliable indicator that a pixbuf or widget is in the buffer. 
</div>
</div><p>
<a class="anchor" name="c51a6e912fca229dcff76ffe2fc7bae9"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_text" ref="c51a6e912fca229dcff76ffe2fc7bae9" args="(const TextIter &amp;start, const TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::Gtk::TextIter::get_text           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the text in the given range. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The iterator at start of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The iterator at end of a range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1String.html">String</a> containing the characters from the buffer.</dd></dl>
If the range contains non-text elements such as images, the character and byte offsets in the returned string will not correspond to character and byte offsets in the buffer. If you want offsets to correspond, <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c9e9a72a3968547f85bb8ed105c4c951">get_slice()</a>. 
</div>
</div><p>
<a class="anchor" name="871cd7b71e5e4c49310674efdff582c9"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_visible_slice" ref="871cd7b71e5e4c49310674efdff582c9" args="(const TextIter &amp;start, const TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::Gtk::TextIter::get_visible_slice           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c9e9a72a3968547f85bb8ed105c4c951">get_slice()</a>, but invisible text is not included. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The iterator at start of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The iterator at end of a range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A slice of text from the buffer.</dd></dl>
<a class="el" href="classXfc_1_1Gtk_1_1Invisible.html">Invisible</a> text is usually invisible because a <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> with the "invisible" attribute turned on has been applied to it. 
</div>
</div><p>
<a class="anchor" name="e9397ca89241b2d678bfb7ad23c38e5f"></a><!-- doxytag: member="Xfc::Gtk::TextIter::get_visible_text" ref="e9397ca89241b2d678bfb7ad23c38e5f" args="(const TextIter &amp;start, const TextIter &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::Gtk::TextIter::get_visible_text           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c51a6e912fca229dcff76ffe2fc7bae9">get_text()</a>, but invisible text is not included. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The iterator at start of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The iterator at end of a range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1String.html">String</a> containing visible text in the range.</dd></dl>
<a class="el" href="classXfc_1_1Gtk_1_1Invisible.html">Invisible</a> text is usually invisible because a <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> with the "invisible" attribute turned on has been applied to it. 
</div>
</div><p>
<a class="anchor" name="50d718a5646dd7e0d669abd990d53626"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_char" ref="50d718a5646dd7e0d669abd990d53626" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_char           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator forward by one character offset. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the iterator moved and is dereferenceable.</dd></dl>
Note that images embedded in the buffer occupy 1 character slot, so <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#50d718a5646dd7e0d669abd990d53626">forward_char()</a> may actually move onto an image instead of a character, if you have images in your buffer. If the iterator is the end iterator or one character before it, the iterator will now point at the end iterator, and <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#50d718a5646dd7e0d669abd990d53626">forward_char()</a> returns false for convenience when writing loops. 
</div>
</div><p>
<a class="anchor" name="ac6a51a7cc31f22657ff6b9a47718cb6"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_char" ref="ac6a51a7cc31f22657ff6b9a47718cb6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_char           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves backward by one character offset. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if movement was possible.</dd></dl>
If the iterator was the first in the buffer (character offset 0), <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#ac6a51a7cc31f22657ff6b9a47718cb6">backward_char()</a> returns false for convenience when writing loops. 
</div>
</div><p>
<a class="anchor" name="6f61dfff953ac6c151405703c1365747"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_chars" ref="6f61dfff953ac6c151405703c1365747" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_chars           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>count</em> characters if possible (if count would move past the start or end of the buffer, moves to the start or end of the buffer). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters to move, may be negative. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the iterator moved and is dereferenceable.</dd></dl>
The return value indicates whether the new position of the iterator is different from its original position, and dereferenceable (the last iterator in the buffer is not dereferenceable). If <em>count</em> is 0, the function does nothing and returns false. 
</div>
</div><p>
<a class="anchor" name="c5c2a3da42e9848fdb5679317f096659"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_chars" ref="c5c2a3da42e9848fdb5679317f096659" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_chars           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>count</em> characters backward, if possible (if count would move past the start or end of the buffer, moves to the start or end of the buffer). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters to move, may be negative. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the iterator moved and is dereferenceable.</dd></dl>
The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then false is returned. If <em>count</em> is 0, the function does nothing and returns false. 
</div>
</div><p>
<a class="anchor" name="a2c419d7711783a0922e22990bf8f740"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_line" ref="a2c419d7711783a0922e22990bf8f740" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator to the start of the next line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the iterator can be dereferenced.</dd></dl>
Returns true if there was a next line to move to, and false if the iterator was simply moved to the end of the buffer and is now not dereferenceable, or if the iterator was already at the end of the buffer. 
</div>
</div><p>
<a class="anchor" name="92875efc33d2263386e93d8264fc309a"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_line" ref="92875efc33d2263386e93d8264fc309a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator to the start of the previous line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the iterator moved.</dd></dl>
Returns true if the iterator could be moved; that is, if the iterator was at character offset 0, this method returns false. Therefore if the iterator was already on line 0, but not at the start of the line, the iterator is snapped to the start of the line and the method returns true. (Note that this implies that in a loop calling this method, the line number may not change on every iteration, if your first iteration is on line 0.) 
</div>
</div><p>
<a class="anchor" name="5c6480e558bb9cbe09e8e2be32c9496b"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_lines" ref="5c6480e558bb9cbe09e8e2be32c9496b" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_lines           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>count</em> lines forward, if possible (if count would move past the start or end of the buffer, moves to the start or end of the buffer). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of lines to move forward. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the iterator moved and is dereferenceable.</dd></dl>
The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then false is returned. If <em>count</em> is 0, the method does nothing and returns false. If <em>count</em> is negative, the iterator moves backward by 0 - <em>count</em> lines. 
</div>
</div><p>
<a class="anchor" name="b27bfab0874194ab270fca37209d0649"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_lines" ref="b27bfab0874194ab270fca37209d0649" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_lines           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>count</em> lines backward, if possible (if count would move past the start or end of the buffer, moves to the start or end of the buffer). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of lines to move backward. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether iter moved and is dereferenceable.</dd></dl>
The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then false is returned. If <em>count</em> is 0, the method does nothing and returns false. If <em>count</em> is negative, moves forward by 0 - <em>count</em> lines. 
</div>
</div><p>
<a class="anchor" name="4fe5656179604e374b7d5ce9f97476ae"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_word_end" ref="4fe5656179604e374b7d5ce9f97476ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_word_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves forward to the next word end. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator.</dd></dl>
If the iterator is currently on a word end, it moves forward to the next one after that. Word breaks are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> word break algorithms). 
</div>
</div><p>
<a class="anchor" name="b4caf91905822647e2e4ad2f9161dd2e"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_word_start" ref="b4caf91905822647e2e4ad2f9161dd2e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_word_start           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves backward to the previous word start. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator.</dd></dl>
If iter is currently on a word start, moves backward to the next one after that. Word breaks are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> word break algorithms). 
</div>
</div><p>
<a class="anchor" name="5518984f357869edd3ea5f35fd1cd0f6"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_word_ends" ref="5518984f357869edd3ea5f35fd1cd0f6" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_word_ends           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#4fe5656179604e374b7d5ce9f97476ae">forward_word_end()</a> up to <em>count</em> times. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of times to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="69886c1bee31808c02f12754003f78d5"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_word_starts" ref="69886c1bee31808c02f12754003f78d5" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_word_starts           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#b4caf91905822647e2e4ad2f9161dd2e">backward_word_start()</a> up to <em>count</em> times. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of times to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6fa52217855e4a4b46f3ba87e173eeb5"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_visible_word_end" ref="6fa52217855e4a4b46f3ba87e173eeb5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_visible_word_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves forward to the next visible word end. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator.</dd></dl>
If the iterator is currently on a word end, moves forward to the next one after that. Word breaks are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> word break algorithms). 
</div>
</div><p>
<a class="anchor" name="95862ef98161a91cd820fc256f18f94a"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_visible_word_start" ref="95862ef98161a91cd820fc256f18f94a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_visible_word_start           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves backward to the previous visible word start. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator.</dd></dl>
If the iterator is currently on a word start, moves backward to the next one after that. Word breaks are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> word break algorithms). 
</div>
</div><p>
<a class="anchor" name="9c33f3f6ff1a1504a9c187d349c66af2"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_visible_word_ends" ref="9c33f3f6ff1a1504a9c187d349c66af2" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_visible_word_ends           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#6fa52217855e4a4b46f3ba87e173eeb5">forward_visible_word_end()</a> up to count times. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of times to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="504d4985eaa2a2b7bcf96b396153fc0b"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_visible_word_starts" ref="504d4985eaa2a2b7bcf96b396153fc0b" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_visible_word_starts           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#95862ef98161a91cd820fc256f18f94a">backward_visible_word_start()</a> up to count times. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of times to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="103eca4d0192b029a03c5ffdfe0900bf"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_sentence_end" ref="103eca4d0192b029a03c5ffdfe0900bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_sentence_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves forward to the next sentence end. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator.</dd></dl>
If the iterator is at the end of a sentence, moves to the next end of sentence. Sentence boundaries are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> text boundary algorithms). 
</div>
</div><p>
<a class="anchor" name="9fad63519c8ae6f86dd75eff5b766895"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_sentence_start" ref="9fad63519c8ae6f86dd75eff5b766895" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_sentence_start           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves backward to the previous sentence start. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator.</dd></dl>
If the iterator is already at the start of a sentence, moves backward to the next one. Sentence boundaries are determined by <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> text boundary algorithms). 
</div>
</div><p>
<a class="anchor" name="b7ccc81a8ff564cdd3937659cd80c879"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_sentence_ends" ref="b7ccc81a8ff564cdd3937659cd80c879" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_sentence_ends           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#103eca4d0192b029a03c5ffdfe0900bf">forward_sentence_end()</a> <em>count</em> times (or until <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#103eca4d0192b029a03c5ffdfe0900bf">forward_sentence_end()</a> returns false). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of sentences to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator.</dd></dl>
If count is negative, the iterator moves backward instead of forward. 
</div>
</div><p>
<a class="anchor" name="c35a78ca50ba17a1f3dba249096b808d"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_sentence_starts" ref="c35a78ca50ba17a1f3dba249096b808d" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_sentence_starts           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#9fad63519c8ae6f86dd75eff5b766895">backward_sentence_start()</a> up to <em>count</em> times, or until it returns false. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of sentences to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and is not the end iterator.</dd></dl>
If <em>count</em> is negative, the iterator moves forward instead of backward. 
</div>
</div><p>
<a class="anchor" name="52593bb48c497310a17770acffb8a468"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_cursor_position" ref="52593bb48c497310a17770acffb8a468" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_cursor_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator forward by a single cursor position. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if we moved and the new position is dereferenceable.</dd></dl>
Cursor positions are (unsurprisingly) positions where the cursor can appear. Perhaps surprisingly, there may not be a cursor position between all characters. The most common example for European languages would be a carriage return/newline sequence. For some Unicode characters, the equivalent of say the letter "a" with an accent mark will be represented as two characters, first the letter then a "combining mark" that causes the accent to be rendered; so the cursor can't go between those two characters. See also the PangoLogAttr structure and pango_break() function. 
</div>
</div><p>
<a class="anchor" name="8fc7ef8f2c0072092d3680e5fd3458f6"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_cursor_position" ref="8fc7ef8f2c0072092d3680e5fd3458f6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_cursor_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a>, but moves backward. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if we moved. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1cc41af53db7dd301b87b0a27f5ef0b8"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_cursor_positions" ref="1cc41af53db7dd301b87b0a27f5ef0b8" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_cursor_positions           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves up to <em>count</em> cursor positions (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a> for details). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of positions to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="374b782717943e6e9040172b01081a78"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_cursor_positions" ref="374b782717943e6e9040172b01081a78" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_cursor_positions           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves up to <em>count</em> cursor positions backwards (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a> for details). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of positions to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3a5f9253911959b48f2578a45c8fe65"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_visible_cursor_position" ref="b3a5f9253911959b48f2578a45c8fe65" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_visible_cursor_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator forward to the next visible cursor position (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a> for details). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and the new position is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d7e1b7983771641218a3f432d6ddc17"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_visible_cursor_position" ref="0d7e1b7983771641218a3f432d6ddc17" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_visible_cursor_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator backward to the previous visible cursor position (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8fc7ef8f2c0072092d3680e5fd3458f6">backward_cursor_position()</a> for details). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and the new position is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b86daf33b69ae6f5df67f3cfe5a389b"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_visible_cursor_positions" ref="2b86daf33b69ae6f5df67f3cfe5a389b" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_visible_cursor_positions           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator up to count visible cursor positions (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a> for details). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of positions to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and the new position is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d5eecb76e6103011d367d48d91d97fe2"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_visible_cursor_positions" ref="d5eecb76e6103011d367d48d91d97fe2" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_visible_cursor_positions           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator up to count visible cursor positions (see <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#52593bb48c497310a17770acffb8a468">forward_cursor_position()</a> for details). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of positions to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the iterator moved and the new position is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6d1283468c33e093c1a71cb701eb6eea"></a><!-- doxytag: member="Xfc::Gtk::TextIter::set_offset" ref="6d1283468c33e093c1a71cb701eb6eea" args="(int char_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextIter::set_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>char_offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the iterator to point to <em>char_offset</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_offset</em>&nbsp;</td><td>A character number.</td></tr>
  </table>
</dl>
<em>char_offset</em> counts from the start of the entire text buffer, starting with 0. 
</div>
</div><p>
<a class="anchor" name="12b6e4e781c1bebed64de33eb5b3ffd5"></a><!-- doxytag: member="Xfc::Gtk::TextIter::set_line" ref="12b6e4e781c1bebed64de33eb5b3ffd5" args="(int line_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextIter::set_line           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator to the start of the line <em>line_number</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line_number</em>&nbsp;</td><td>The line number (counted from 0).</td></tr>
  </table>
</dl>
If line_number is negative or larger than the number of lines in the buffer, moves iter to the start of the last line in the buffer. 
</div>
</div><p>
<a class="anchor" name="42c521feec8321601f9abee97dd59afb"></a><!-- doxytag: member="Xfc::Gtk::TextIter::set_line_offset" ref="42c521feec8321601f9abee97dd59afb" args="(int char_on_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextIter::set_line_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>char_on_line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator within a line, to a new character (not byte) offset. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_on_line</em>&nbsp;</td><td>A character offset relative to the start of iter's current line.</td></tr>
  </table>
</dl>
The given character offset must be less than or equal to the number of characters in the line; if equal, the iterator moves to the start of the next line. See <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#a34cc8197fd8c654c40f6451001d52a1">set_line_index()</a> if you have a byte index rather than a character offset. 
</div>
</div><p>
<a class="anchor" name="a34cc8197fd8c654c40f6451001d52a1"></a><!-- doxytag: member="Xfc::Gtk::TextIter::set_line_index" ref="a34cc8197fd8c654c40f6451001d52a1" args="(int byte_on_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextIter::set_line_index           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byte_on_line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#42c521feec8321601f9abee97dd59afb">set_line_offset()</a>, but works with a byte index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>byte_on_line</em>&nbsp;</td><td>A byte index relative to the start of iter's current line.</td></tr>
  </table>
</dl>
The given byte index must be at the start of a character, it can't be in the middle of a UTF-8 encoded character. 
</div>
</div><p>
<a class="anchor" name="c7a4bc35b00e3a5055dee3f1139ffcea"></a><!-- doxytag: member="Xfc::Gtk::TextIter::set_visible_line_offset" ref="c7a4bc35b00e3a5055dee3f1139ffcea" args="(int char_on_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextIter::set_visible_line_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>char_on_line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#42c521feec8321601f9abee97dd59afb">set_line_offset()</a>, but the offset is in visible characters, that is, text with a tag making it invisible is not counted in the offset. 
<p>
,<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_on_line</em>&nbsp;</td><td>A character offset. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1b457bbd4228930b4873f8ea5a17f3c1"></a><!-- doxytag: member="Xfc::Gtk::TextIter::set_visible_line_index" ref="1b457bbd4228930b4873f8ea5a17f3c1" args="(int byte_on_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextIter::set_visible_line_index           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byte_on_line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#a34cc8197fd8c654c40f6451001d52a1">set_line_index()</a>, but the index is in visible bytes, that is, text with a tag making it invisible is not counted in the index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>byte_on_line</em>&nbsp;</td><td>A byte index. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cba3e89f31faa1e8b6b643338d9a2bc8"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_to_end" ref="cba3e89f31faa1e8b6b643338d9a2bc8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::TextIter::forward_to_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator forward to the "end iterator", which points one past the last valid character in the buffer. 
<p>
Note <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#8b78bb057daddfa3fbd9db5818d153c0">get_char()</a> called on the end iterator returns 0, which is convenient for writing loops. 
</div>
</div><p>
<a class="anchor" name="7c0805cb4c1f47fb3f2233a5e22e82c6"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_to_line_end" ref="7c0805cb4c1f47fb3f2233a5e22e82c6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_to_line_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator to point to the paragraph delimiter characters, which will be either a newline, a carriage return, a carriage return/newline in sequence, or the Unicode paragraph separator character. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if we moved and the new location is not the end iterator.</dd></dl>
If the iterator is already at the paragraph delimiter characters, it moves to the paragraph delimiter characters for the next line. If the iterator is on the last line in the buffer, which does not end in paragraph delimiters, it moves to the end iterator (end of the last line), and returns false. 
</div>
</div><p>
<a class="anchor" name="c1393a3e5828e2195ebfb37498dd3610"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_to_tag_toggle" ref="c1393a3e5828e2195ebfb37498dd3610" args="(const TextTag *tag=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_to_tag_toggle           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> *&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves forward to the next toggle (on or off) of the <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is null. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>, or null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether we found a tag toggle after the iterator.</dd></dl>
If no matching tag toggles are found, returns false, otherwise true. Does not return toggles located at the iterator, only toggles after the iterator. Sets the iterator to the location of the toggle, or to the end of the buffer if no toggle is found. 
</div>
</div><p>
<a class="anchor" name="9e4a846d3ab5327492032bb47a3b1a7b"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_to_tag_toggle" ref="9e4a846d3ab5327492032bb47a3b1a7b" args="(const TextTag *tag=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_to_tag_toggle           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> *&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves backward to the next toggle (on or off) of the <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is null. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextTag.html">TextTag</a>, or null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether we found a tag toggle before the iterator.</dd></dl>
If no matching tag toggles are found, returns false, otherwise true. Does not return toggles located at the iterator, only toggles before the iterator. Sets the iterator to the location of the toggle, or the start of the buffer if no toggle is found. 
</div>
</div><p>
<a class="anchor" name="c0ed42e964d02c2d6440395b3b48a1a2"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_find_char" ref="c0ed42e964d02c2d6440395b3b48a1a2" args="(const TextCharPredicate &amp;predicate, const TextIter *limit=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_find_char           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#07b9abce2eb06fd426cdc9250a1d6ed2">TextCharPredicate</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>limit</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advances the iterator, calling <em>predicate</em> on each character. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>predicate</em>&nbsp;</td><td>A callback slot to be called on each character. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The search limit, or null for none. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found.</dd></dl>
If <em>predicate</em> returns true, returns true and stops scanning. If <em>predicate</em> never returns true, the iterator is set to <em>limit</em> if limit is non-null, otherwise to the end iterator. 
</div>
</div><p>
<a class="anchor" name="d549ba7ae03626e2fe79b3b889607710"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_find_char" ref="d549ba7ae03626e2fe79b3b889607710" args="(const TextCharPredicate &amp;predicate, const TextIter *limit=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_find_char           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#07b9abce2eb06fd426cdc9250a1d6ed2">TextCharPredicate</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>limit</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c0ed42e964d02c2d6440395b3b48a1a2">forward_find_char()</a>, but goes backward from the iterator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>predicate</em>&nbsp;</td><td>A callback slot to be called on each character. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The search limit, or null for none. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bcdeafa8989c2aa67949103de9b87e9e"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_search" ref="bcdeafa8989c2aa67949103de9b87e9e" args="(const String &amp;str, const TextIter *limit=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_search           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>limit</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches forward for <em>str</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A search string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The bound for the search, or null for the end of the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found</dd></dl>
The search will not continue past <em>limit</em>. Note that a search is a linear or O(n) operation, so you may wish to use limit to avoid locking up your UI on large buffers. The TEXT_SEARCH_VISIBLE_ONLY flag is used so the match may have invisible text interspersed in <em>str</em> (i.e. str will be a possibly-noncontiguous subsequence of the matched range). 
</div>
</div><p>
<a class="anchor" name="16d1b02edd01d655e442132b9c93eb84"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_search" ref="16d1b02edd01d655e442132b9c93eb84" args="(const String &amp;str, TextIter *match_start, TextIter *match_end, const TextIter *limit=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_search           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>match_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>limit</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches forward for <em>str</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A search string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_start</em>&nbsp;</td><td>The return location for start of match, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_end</em>&nbsp;</td><td>The return location for end of match, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The bound for the search, or null for the end of the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found</dd></dl>
Any match is returned by setting <em>match_start</em> to the first character of the match and <em>match_end</em> to the first character after the match. The search will not continue past <em>limit</em>. Note that a search is a linear or O(n) operation, so you may wish to use limit to avoid locking up your UI on large buffers. The TEXT_SEARCH_VISIBLE_ONLY flag is used so the match may have invisible text interspersed in <em>str</em> (i.e. str will be a possibly-noncontiguous subsequence of the matched range). 
</div>
</div><p>
<a class="anchor" name="f02083557830f4e44109dd680e12a77f"></a><!-- doxytag: member="Xfc::Gtk::TextIter::forward_search" ref="f02083557830f4e44109dd680e12a77f" args="(const String &amp;str, TextSearchFlagsField flags, TextIter *match_start, TextIter *match_end, const TextIter *limit=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::forward_search           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#29e0bc5b6206932b4fdce85ae95ad4a6">TextSearchFlagsField</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>match_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>limit</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches forward for <em>str</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A search string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The <a class="el" href="namespaceXfc_1_1Gtk.html#ac812a3b5b3cbaa5a1e4ebd1f935aa0f">Gtk::TextSearchFlags</a> affecting how the search is done. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_start</em>&nbsp;</td><td>The return location for start of match, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_end</em>&nbsp;</td><td>The return location for end of match, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The bound for the search, or null for the end of the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found</dd></dl>
Any match is returned by setting <em>match_start</em> to the first character of the match and <em>match_end</em> to the first character after the match. The search will not continue past <em>limit</em>. Note that a search is a linear or O(n) operation, so you may wish to use limit to avoid locking up your UI on large buffers. If the TEXT_SEARCH_VISIBLE_ONLY flag is present, the match may have invisible text interspersed in <em>str</em> (i.e. str will be a possibly-noncontiguous subsequence of the matched range). Similarly, if you specify TEXT_SEARCH_TEXT_ONLY, the match may have pixbufs or child widgets mixed inside the matched range. If these flags are not given, the match must be exact; the special 0xFFFC character in str will match embedded pixbufs or child widgets. 
</div>
</div><p>
<a class="anchor" name="95a1985957a63f65795d5dd9404cd837"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_search" ref="95a1985957a63f65795d5dd9404cd837" args="(const String &amp;str, const TextIter *limit=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_search           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>limit</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as forward_search(), but moves backward. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The search string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The location of last possible match_start, or null for start of buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found.</dd></dl>
The TEXT_SEARCH_VISIBLE_ONLY flag is used so the match may have invisible text interspersed in <em>str</em> (i.e. str will be a possibly-noncontiguous subsequence of the matched range). 
</div>
</div><p>
<a class="anchor" name="038610ee313e20f1b21ae078fb4cb966"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_search" ref="038610ee313e20f1b21ae078fb4cb966" args="(const String &amp;str, TextIter *match_start, TextIter *match_end, const TextIter *limit=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_search           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>match_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>limit</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as forward_search(), but moves backward. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The search string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_start</em>&nbsp;</td><td>The return location for start of match, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_end</em>&nbsp;</td><td>The return location for end of match, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The location of last possible match_start, or null for start of buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found.</dd></dl>
The TEXT_SEARCH_VISIBLE_ONLY flag is used so the match may have invisible text interspersed in <em>str</em> (i.e. str will be a possibly-noncontiguous subsequence of the matched range). 
</div>
</div><p>
<a class="anchor" name="992840862a73be1edf495bc255035152"></a><!-- doxytag: member="Xfc::Gtk::TextIter::backward_search" ref="992840862a73be1edf495bc255035152" args="(const String &amp;str, TextSearchFlagsField flags, TextIter *match_start, TextIter *match_end, const TextIter *limit=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::TextIter::backward_search           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#29e0bc5b6206932b4fdce85ae95ad4a6">TextSearchFlagsField</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>match_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> *&nbsp;</td>
          <td class="paramname"> <em>limit</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as forward_search(), but moves backward. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The search string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The bitmask of <a class="el" href="namespaceXfc_1_1Gtk.html#ac812a3b5b3cbaa5a1e4ebd1f935aa0f">Gtk::TextSearchFlags</a> affecting the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_start</em>&nbsp;</td><td>The return location for start of match, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_end</em>&nbsp;</td><td>The return location for end of match, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The location of last possible match_start, or null for start of buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="35c4ebc160378adc2c95449485626eeb"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator+" ref="35c4ebc160378adc2c95449485626eeb" args="(int chars) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> Xfc::Gtk::TextIter::operator+           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chars</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> to the position <em>chars</em> characters from this iterator in a forward direction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chars</em>&nbsp;</td><td>The number of characters from this iterator. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> to the new position. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8e471e8f16028b461e415ea38bcb901f"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator-" ref="8e471e8f16028b461e415ea38bcb901f" args="(int chars) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> Xfc::Gtk::TextIter::operator-           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chars</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> to the position <em>chars</em> characters from this iterator in a backward direction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chars</em>&nbsp;</td><td>The number of characters from this iterator. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> to the new position. </dd></dl>

</div>
</div><p>
<a class="anchor" name="28746896550bc7e20f82ff28484b7097"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator+=" ref="28746896550bc7e20f82ff28484b7097" args="(int chars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>&amp; Xfc::Gtk::TextIter::operator+=           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chars</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#6f61dfff953ac6c151405703c1365747">forward_chars()</a> to move this iterator forward <em>chars</em> characters. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chars</em>&nbsp;</td><td>The number of characters to move this iterator. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="259a50cf49b1fdabda0473aa65004e66"></a><!-- doxytag: member="Xfc::Gtk::TextIter::operator-=" ref="259a50cf49b1fdabda0473aa65004e66" args="(int chars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>&amp; Xfc::Gtk::TextIter::operator-=           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chars</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#c5c2a3da42e9848fdb5679317f096659">backward_chars()</a> to move this iterator backward <em>chars</em> characters. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chars</em>&nbsp;</td><td>The number of characters to move this iterator. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0270f87261a13c3e9b337904c9c855c0"></a><!-- doxytag: member="Xfc::Gtk::TextIter::order" ref="0270f87261a13c3e9b337904c9c855c0" args="(const TextIter &amp;first, const TextIter &amp;second)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Gtk::TextIter::order           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>second</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the value of first and second if second comes before first in the buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>Another <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html">TextIter</a>.</td></tr>
  </table>
</dl>
This method ensures that first and second are in sequence. Most text buffer functions that take a range call this automatically on your behalf, so there's no real reason to call it yourself in those cases. There are some exceptions, such as <a class="el" href="classXfc_1_1Gtk_1_1TextIter.html#d4f7d909965464911015d5bc2e59e294">in_range()</a>, that expect a pre-sorted range. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="textiter_8hh.html">textiter.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
