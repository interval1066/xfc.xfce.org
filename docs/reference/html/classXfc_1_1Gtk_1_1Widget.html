<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1Gtk.html">Gtk</a>::<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a></div>
<h1>Xfc::Gtk::Widget Class Reference</h1><!-- doxytag: class="Xfc::Gtk::Widget" --><!-- doxytag: inherits="Xfc::Gtk::Object,Xfc::Atk::Implementor" -->A GtkWidget C++ wrapper class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/gtk/widget.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::Gtk::Widget:
<p><center><img src="classXfc_1_1Gtk_1_1Widget.png" usemap="#Xfc::Gtk::Widget_map" border="0" alt=""></center>
<map name="Xfc::Gtk::Widget_map">
<area href="classXfc_1_1Gtk_1_1Object.html" alt="Xfc::Gtk::Object" shape="rect" coords="0,168,137,192">
<area href="classXfc_1_1Atk_1_1Implementor.html" alt="Xfc::Atk::Implementor" shape="rect" coords="147,168,284,192">
<area href="classXfc_1_1G_1_1Object.html" alt="Xfc::G::Object" shape="rect" coords="0,112,137,136">
<area href="classXfc_1_1G_1_1TypeInterface.html" alt="Xfc::G::TypeInterface" shape="rect" coords="147,112,284,136">
<area href="classXfc_1_1G_1_1TypeInstance.html" alt="Xfc::G::TypeInstance" shape="rect" coords="0,56,137,80">
<area href="classXfc_1_1G_1_1TypeInstance.html" alt="Xfc::G::TypeInstance" shape="rect" coords="147,56,284,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="0,0,137,24">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="147,0,284,24">
<area href="classXfc_1_1Gtk_1_1Calendar.html" alt="Xfc::Gtk::Calendar" shape="rect" coords="220,280,357,304">
<area href="classXfc_1_1Gtk_1_1CellView.html" alt="Xfc::Gtk::CellView" shape="rect" coords="220,336,357,360">
<area href="classXfc_1_1Gtk_1_1Container.html" alt="Xfc::Gtk::Container" shape="rect" coords="220,392,357,416">
<area href="classXfc_1_1Gtk_1_1DrawingArea.html" alt="Xfc::Gtk::DrawingArea" shape="rect" coords="220,448,357,472">
<area href="classXfc_1_1Gtk_1_1Entry.html" alt="Xfc::Gtk::Entry" shape="rect" coords="220,504,357,528">
<area href="classXfc_1_1Gtk_1_1Invisible.html" alt="Xfc::Gtk::Invisible" shape="rect" coords="220,560,357,584">
<area href="classXfc_1_1Gtk_1_1Misc.html" alt="Xfc::Gtk::Misc" shape="rect" coords="220,616,357,640">
<area href="classXfc_1_1Gtk_1_1ProgressBar.html" alt="Xfc::Gtk::ProgressBar" shape="rect" coords="220,672,357,696">
<area href="classXfc_1_1Gtk_1_1Range.html" alt="Xfc::Gtk::Range" shape="rect" coords="220,728,357,752">
<area href="classXfc_1_1Gtk_1_1Ruler.html" alt="Xfc::Gtk::Ruler" shape="rect" coords="220,784,357,808">
<area href="classXfc_1_1Gtk_1_1Separator.html" alt="Xfc::Gtk::Separator" shape="rect" coords="220,840,357,864">
</map>
<a href="classXfc_1_1Gtk_1_1Widget-members.html">List of all members.</a><h2>Basic Signal Prototypes</h2>
<ul>
<li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ShowSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6f29c6dba8b19ed7d538c756f9de8596">show_signal</a>
<dl class="el"><dd class="mdescRight">Show signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#17bfc7dce72663c026e19b602eeb3250">signal_show()</a>).  <a href="#6f29c6dba8b19ed7d538c756f9de8596"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">HideSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#88ad1552b5c4781a4c6a02f1fdb8190f">hide_signal</a>
<dl class="el"><dd class="mdescRight">Hide signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5e0419fe1123d2f657622a16f2c68655">signal_hide()</a>).  <a href="#88ad1552b5c4781a4c6a02f1fdb8190f"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">MapSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6fda631b20d7d2aa0785fd9f8df950f0">map_signal</a>
<dl class="el"><dd class="mdescRight">Map signal (see signal_Map()).  <a href="#6fda631b20d7d2aa0785fd9f8df950f0"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">UnmapSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#3254863ec7cddf5b9e2d8138500f1e28">unmap_signal</a>
<dl class="el"><dd class="mdescRight">Unmap signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#22e73a422f40d2b1660f90e7687e91a6">signal_unmap()</a>).  <a href="#3254863ec7cddf5b9e2d8138500f1e28"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">RealizeSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4afcd174ead1473d028c5d0be7f6397c">realize_signal</a>
<dl class="el"><dd class="mdescRight">Realize signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8d659e300502b77e3c7b574715995152">signal_realize()</a>).  <a href="#4afcd174ead1473d028c5d0be7f6397c"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">UnrealizeSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c0cb44f462e66e1dffb6fd80f57625ce">unrealize_signal</a>
<dl class="el"><dd class="mdescRight">Unrealize signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f4fdcba7d93e60aeaf2b758cfd47bd6b">signal_unrealize()</a>).  <a href="#c0cb44f462e66e1dffb6fd80f57625ce"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">SizeRequestSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bc57450a1276b628b7393cd4a0381def">size_request_signal</a>
<dl class="el"><dd class="mdescRight">Size request signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0e76cfeed6840141b05345daf11b6f62">signal_size_request()</a>).  <a href="#bc57450a1276b628b7393cd4a0381def"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">SizeAllocateSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dd0e58f8a734f59df665ee8d66a8a2d5">size_allocate_signal</a>
<dl class="el"><dd class="mdescRight">Size allocate signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#51b3efb74adc317fe9f70c885f9e61d9">signal_size_allocate()</a>).  <a href="#dd0e58f8a734f59df665ee8d66a8a2d5"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">StateChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#81b8c1e825681f3d572e3248b5d04ccb">state_changed_signal</a>
<dl class="el"><dd class="mdescRight">State changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#176778d4af5613922959db3cf8c8e464">signal_state_changed()</a>).  <a href="#81b8c1e825681f3d572e3248b5d04ccb"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ParentSetSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#177afd65eb2a95669e229dad495da33d">parent_set_signal</a>
<dl class="el"><dd class="mdescRight">Parent set signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6a39e540da54e4f10b6748c4d463e818">signal_parent_set()</a>).  <a href="#177afd65eb2a95669e229dad495da33d"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">HierarchyChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1417a39363c1ad1fc3b9c3998a7ff056">hierarchy_changed_signal</a>
<dl class="el"><dd class="mdescRight">Hierarchy changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8782d715f5659ce928cb77471655d25d">signal_hierarchy_changed()</a>).  <a href="#1417a39363c1ad1fc3b9c3998a7ff056"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">StyleSetSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1e5c6d696d20004c06894e9e44bff571">style_set_signal</a>
<dl class="el"><dd class="mdescRight"><a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> set signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2bfd96313f6c2ff17bf929a472e4c953">signal_style_set()</a>).  <a href="#1e5c6d696d20004c06894e9e44bff571"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DirectionChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#548ed98d46be28498725aa4288273456">direction_changed_signal</a>
<dl class="el"><dd class="mdescRight">Direction changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#84b7eac2845461af36647331d6c1a916">signal_direction_changed()</a>).  <a href="#548ed98d46be28498725aa4288273456"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">GrabNotifySignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c6d4ac6535351113e64a21da840a1c8e">grab_notify_signal</a>
<dl class="el"><dd class="mdescRight">Grab notify signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b4a24972d1e208a45662ab9ec2f78601">signal_grab_notify()</a>).  <a href="#c6d4ac6535351113e64a21da840a1c8e"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ChildNotifySignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ce6ef6a7cd9c70e3b335e157c8738d05">child_notify_signal</a>
<dl class="el"><dd class="mdescRight">Child notify signal (see signal_child_notify()).  <a href="#ce6ef6a7cd9c70e3b335e157c8738d05"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">MnemonicActivateSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2554b1654f387651af404f2a4d120236">mnemonic_activate_signal</a>
<dl class="el"><dd class="mdescRight">Mnemonic activate signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a317d321cc1d783a695b3732cdf24cac">signal_mnemonic_activate()</a>).  <a href="#2554b1654f387651af404f2a4d120236"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">GrabFocusSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8f0cc552475e98ebf01671cbdd52f155">grab_focus_signal</a>
<dl class="el"><dd class="mdescRight">Grab focus signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#97d7b5c2f7406b4ffb2774e3c60217b1">signal_grab_focus()</a>).  <a href="#8f0cc552475e98ebf01671cbdd52f155"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">FocusSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#37d2a04e192616035e29f38899b8da40">focus_signal</a>
<dl class="el"><dd class="mdescRight">Focus signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#af8b5100dae6718f1185ce4bd3ed42fd">signal_focus()</a>).  <a href="#37d2a04e192616035e29f38899b8da40"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">AccelClosuresChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9252b7c75fe5cfeb01c5276760139290">accel_closures_changed_signal</a>
<dl class="el"><dd class="mdescRight">Accel closures changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#24506eee68b25c3e547567d0b25870bc">signal_accel_closures_changed()</a>).  <a href="#9252b7c75fe5cfeb01c5276760139290"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ScreenChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e13d1d516306242e5e57fc42696d6c83">screen_changed_signal</a>
<dl class="el"><dd class="mdescRight">Screen changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dda4ec70b68830e4615e62acebd55768">signal_screen_changed()</a>).  <a href="#e13d1d516306242e5e57fc42696d6c83"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">CanActivateAccelSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#cdf68baf8311ab9e0bf49edcc789592f">can_activate_accel_signal</a>
<dl class="el"><dd class="mdescRight">Can activate accel signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#adee8af211cce0b2d50a22192bdfbb0b">signal_can_activate_accel()</a>).  <a href="#cdf68baf8311ab9e0bf49edcc789592f"></a><br></dl></ul>
<h2>Selection Signal Prototypes</h2>
<ul>
<li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">SelectionGetSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#122965a21d3133a2104520f9d6823780">selection_get_signal</a>
<dl class="el"><dd class="mdescRight">Selection get signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dc96a76c3c51e340bcb46c8a94bb5d6c">signal_selection_get()</a>).  <a href="#122965a21d3133a2104520f9d6823780"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">SelectionReceivedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9ec6d213e5536261aba62cf6fb27a2dc">selection_received_signal</a>
<dl class="el"><dd class="mdescRight">Selection received signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#58e569723fdbb064e9b52d75a8bf3b40">signal_selection_received()</a>).  <a href="#9ec6d213e5536261aba62cf6fb27a2dc"></a><br></dl></ul>
<h2>Drag Source-side Signal Prototypes</h2>
<ul>
<li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragBeginSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d57e146d14d494c238823747a4d4667d">drag_begin_signal</a>
<dl class="el"><dd class="mdescRight">Drag begin signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f674928b0bba76b663b73a74c11c4f05">signal_drag_begin()</a>).  <a href="#d57e146d14d494c238823747a4d4667d"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragEndSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ef47733a5035ea40a3dd6363c1ba04a5">drag_end_signal</a>
<dl class="el"><dd class="mdescRight">Drag end signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#422589e89a6e3fac29aa85106520ee43">signal_drag_end()</a>).  <a href="#ef47733a5035ea40a3dd6363c1ba04a5"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragDataGetSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7cea22c9c449f183d4775d0ccfde82b0">drag_data_get_signal</a>
<dl class="el"><dd class="mdescRight">Drag data get signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#eaa9d9fe2067490340754642e0b2fc57">signal_drag_data_get()</a>).  <a href="#7cea22c9c449f183d4775d0ccfde82b0"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragDataDeleteSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#49ed703724ccf0faa93bdf92d8d7c11e">drag_data_delete_signal</a>
<dl class="el"><dd class="mdescRight">Drag data delete signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e44064466ce0490a3de74dbd4fc70b5b">signal_drag_data_delete()</a>).  <a href="#49ed703724ccf0faa93bdf92d8d7c11e"></a><br></dl></ul>
<h2>Drag Target-side Signal Prototypes</h2>
<ul>
<li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragLeaveSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#17930903ab58c6599fcbcf3636f105fa">drag_leave_signal</a>
<dl class="el"><dd class="mdescRight">Drag leave signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6736edea849737ae7f96065097752e17">signal_drag_leave()</a>).  <a href="#17930903ab58c6599fcbcf3636f105fa"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragMotionSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fb7c6cbccea83645a10d40640637c816">drag_motion_signal</a>
<dl class="el"><dd class="mdescRight">Drag motion signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ec4e37a70a1d71665a170506e0a22968">signal_drag_motion()</a>).  <a href="#fb7c6cbccea83645a10d40640637c816"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragDropSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b08ee7cf7fce79771dca93202f7cbcb6">drag_drop_signal</a>
<dl class="el"><dd class="mdescRight">Drag drop signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d75dc38d611ba871eddde651d6148dd0">signal_drag_drop()</a>).  <a href="#b08ee7cf7fce79771dca93202f7cbcb6"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragDataReceivedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#33957a279a6f714caedafacaece5a271">drag_data_received_signal</a>
<dl class="el"><dd class="mdescRight">Drag data received signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#290df63fa2eceaa768f3489c290ca6b5">signal_drag_data_received()</a>).  <a href="#33957a279a6f714caedafacaece5a271"></a><br></dl></ul>
<h2>GDK Event Signal Prototypes</h2>
<ul>
<li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">EventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#945661eec99a08746a55151307cd3179">event_signal</a>
<dl class="el"><dd class="mdescRight">Event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#94b859cf217745a51e8bf2d5344deeed">signal_event()</a>).  <a href="#945661eec99a08746a55151307cd3179"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">EventAfterSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#86046864ecf8d1374a4d5b8e51453022">event_after_signal</a>
<dl class="el"><dd class="mdescRight">Event after signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#82454f65f975154fb0eba5bda1c67bf8">signal_event_after()</a>).  <a href="#86046864ecf8d1374a4d5b8e51453022"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ButtonPressEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f0d5a35af13f4d50f138be9411219523">button_press_event_signal</a>
<dl class="el"><dd class="mdescRight"><a class="el" href="classXfc_1_1Gtk_1_1Button.html">Button</a> press event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#29fe506a596b4dd2ba9587f36856c295">signal_button_press_event()</a>).  <a href="#f0d5a35af13f4d50f138be9411219523"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ButtonReleaseEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a5b3b1cd485d38403697d1f4c27c32cf">button_release_event_signal</a>
<dl class="el"><dd class="mdescRight"><a class="el" href="classXfc_1_1Gtk_1_1Button.html">Button</a> release event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e64acae5ede5633c48a71db725073ae4">signal_button_release_event()</a>).  <a href="#a5b3b1cd485d38403697d1f4c27c32cf"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ScrollEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c2e45a31f5691888e708429ea4eadc99">scroll_event_signal</a>
<dl class="el"><dd class="mdescRight">Scroll event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#53ad3abad2d53e759f2b4d094a848faf">signal_scroll_event()</a>).  <a href="#c2e45a31f5691888e708429ea4eadc99"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">MotionNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#155da826283bd1a8f9f6eb7c2ef4b8af">motion_notify_event_signal</a>
<dl class="el"><dd class="mdescRight">Motion notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#615730e9863688c17e3b59bd8fe555e6">signal_motion_notify_event()</a>).  <a href="#155da826283bd1a8f9f6eb7c2ef4b8af"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DeleteEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#3e53cb2132ea42e28113b4467b9b804e">delete_event_signal</a>
<dl class="el"><dd class="mdescRight">Delete event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d9f60271ae6ab5a596cd5603e37054ca">signal_delete_event()</a>).  <a href="#3e53cb2132ea42e28113b4467b9b804e"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">DestroyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e3cd13a015fd917162aa302327906f2b">destroy_event_signal</a>
<dl class="el"><dd class="mdescRight">Destroy event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#96511ba76557b4fb334cedaae683af0e">signal_destroy_event()</a>).  <a href="#e3cd13a015fd917162aa302327906f2b"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ExposeEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fcdf427515d7dac9d214fc76243c1094">expose_event_signal</a>
<dl class="el"><dd class="mdescRight">Expose event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#49c2b89395ef7816abcc45b6e5d3b4a0">signal_expose_event()</a>).  <a href="#fcdf427515d7dac9d214fc76243c1094"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">KeyPressEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d0f1c73c5ea5a418aaa0be6f383aeb36">key_press_event_signal</a>
<dl class="el"><dd class="mdescRight">Key press event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a4f274e1336592abc88c5b88cc011250">signal_key_press_event()</a>).  <a href="#d0f1c73c5ea5a418aaa0be6f383aeb36"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">KeyReleaseEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c929e677fd2b77931e30cf92da78220a">key_release_event_signal</a>
<dl class="el"><dd class="mdescRight">Key release event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d1701b246d69c2f7be75ce1989c3c6ba">signal_key_release_event()</a>).  <a href="#c929e677fd2b77931e30cf92da78220a"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">EnterNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#038fdae9c71dc9a4268a90204bff4edf">enter_notify_event_signal</a>
<dl class="el"><dd class="mdescRight">Enter notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f002eee0271857b758fa83402eaa8e88">signal_enter_notify_event()</a>).  <a href="#038fdae9c71dc9a4268a90204bff4edf"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">LeaveNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f2c4dfa1cbd086eea346eb17f0cd878c">leave_notify_event_signal</a>
<dl class="el"><dd class="mdescRight">Leave notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2cfa16cdff20f7922480ef1c690e72a7">signal_leave_notify_event()</a>).  <a href="#f2c4dfa1cbd086eea346eb17f0cd878c"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ConfigureEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#55dc27b89136915626f0e9b1793c4acc">configure_event_signal</a>
<dl class="el"><dd class="mdescRight">Configure event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#44489a74e958dabe17016828b55cea3f">signal_configure_event()</a>).  <a href="#55dc27b89136915626f0e9b1793c4acc"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">FocusInEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c12ebb0b6b58e8575ceb14f1eb1db78a">focus_in_event_signal</a>
<dl class="el"><dd class="mdescRight">Focus in event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a4f0f1a9bf07c14b919327ca6fb0b915">signal_focus_in_event()</a>).  <a href="#c12ebb0b6b58e8575ceb14f1eb1db78a"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">FocusOutEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6b27bf4402005431100ca4e33a5b7b8a">focus_out_event_signal</a>
<dl class="el"><dd class="mdescRight">Focus out event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b8da2eb022bd51e7bdb2a3e56136751c">signal_focus_out_event()</a>).  <a href="#6b27bf4402005431100ca4e33a5b7b8a"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">MapEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#202bf743f5670b6bb93e66d9a388b734">map_event_signal</a>
<dl class="el"><dd class="mdescRight">Map event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2c3d1f74275ef213a4e29924bb908257">signal_map_event()</a>).  <a href="#202bf743f5670b6bb93e66d9a388b734"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">UnmapEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ba6066189411962d92d607206602b56c">unmap_event_signal</a>
<dl class="el"><dd class="mdescRight">Unmap event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#297ca5a50d37ee22a446b7154949b35e">signal_unmap_event()</a>).  <a href="#ba6066189411962d92d607206602b56c"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">PropertyNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#eace3f2fe9b1a7c7091530c02d0fd3f9">property_notify_event_signal</a>
<dl class="el"><dd class="mdescRight">Property notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#de929461102ab0c0d90ce22a640d998b">signal_property_notify_event()</a>).  <a href="#eace3f2fe9b1a7c7091530c02d0fd3f9"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">SelectionClearEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2363cf2758916625e5d6736dd471c21a">selection_clear_event_signal</a>
<dl class="el"><dd class="mdescRight">Selection clear event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5a13503cffa1a17ac3eaf466ac4b2e81">signal_selection_clear_event()</a>).  <a href="#2363cf2758916625e5d6736dd471c21a"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">SelectionRequestEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bbbdeb9079eb679b8315a83d81420dbe">selection_request_event_signal</a>
<dl class="el"><dd class="mdescRight">Selection request event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#297deef498809d3cf1616e5c8d37d09f">signal_selection_request_event()</a>).  <a href="#bbbdeb9079eb679b8315a83d81420dbe"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">SelectionNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#217e18844168ab9954fa32fb504b913b">selection_notify_event_signal</a>
<dl class="el"><dd class="mdescRight">Selection notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#adc0ce8251024ba8b9eefefae6438692">signal_selection_notify_event()</a>).  <a href="#217e18844168ab9954fa32fb504b913b"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ProximityInEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#68cdd670bf8bc3a6f6d15433211e0006">proximity_in_event_signal</a>
<dl class="el"><dd class="mdescRight">Proximity in event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#653316981d2bef7c693facee31dab25b">signal_proximity_in_event()</a>).  <a href="#68cdd670bf8bc3a6f6d15433211e0006"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ProximityOutEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2aa9b7209624d56c2e46d14de8d3a049">proximity_out_event_signal</a>
<dl class="el"><dd class="mdescRight">Proximity out event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2377cf4e2c86969da0e6ea639065fe76">signal_proximity_out_event()</a>).  <a href="#2aa9b7209624d56c2e46d14de8d3a049"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">VisibilityNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f2753621e9384574533e7d7b608384a9">visibility_notify_event_signal</a>
<dl class="el"><dd class="mdescRight">Visibility notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#58a89e3fc1f71bf2bd18258bec52911d">signal_visibility_notify_event()</a>).  <a href="#f2753621e9384574533e7d7b608384a9"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">ClientEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#071e21f9562347ba7fb7a98496919913">client_event_signal</a>
<dl class="el"><dd class="mdescRight">Client event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#03337f141db2566c5a5101cccfdb3180">signal_client_event()</a>).  <a href="#071e21f9562347ba7fb7a98496919913"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">NoExposeEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#62be093016425319adda2eb63da87834">no_expose_event_signal</a>
<dl class="el"><dd class="mdescRight">No expose event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#64e7ca5a1e689b739baa1c33ddfafcd8">signal_no_expose_event()</a>).  <a href="#62be093016425319adda2eb63da87834"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">WindowStateEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#3c073f33f3bd3c935bbd60b7189ad060">window_state_event_signal</a>
<dl class="el"><dd class="mdescRight"><a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> state event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#de207a8ba498a6583a4ea4f0f478784d">signal_window_state_event()</a>).  <a href="#3c073f33f3bd3c935bbd60b7189ad060"></a><br></dl></ul>
<h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="7cf31b1c61e01ec0a3cae36f41f3da4a"></a><!-- doxytag: member="Xfc::Gtk::Widget::gtk_widget" ref="7cf31b1c61e01ec0a3cae36f41f3da4a" args="() const" -->
GtkWidget * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7cf31b1c61e01ec0a3cae36f41f3da4a">gtk_widget</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GtkWidget structure. <br></dl><li><a class="anchor" name="f87ce0c72abe35f5e77e0588ce0655cb"></a><!-- doxytag: member="Xfc::Gtk::Widget::operator GtkWidget *" ref="f87ce0c72abe35f5e77e0588ce0655cb" args="() const" -->
<a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f87ce0c72abe35f5e77e0588ce0655cb">operator GtkWidget *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; safely converts a <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> to a GtkWidget pointer. <br></dl><li><a class="anchor" name="11147be1ef41a8a50a121dfc82fb2930"></a><!-- doxytag: member="Xfc::Gtk::Widget::is_toplevel" ref="11147be1ef41a8a50a121dfc82fb2930" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#11147be1ef41a8a50a121dfc82fb2930">is_toplevel</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget is a toplevel widget. <br></dl><li><a class="anchor" name="389d1d2894bc98132ddf650e2fe00b58"></a><!-- doxytag: member="Xfc::Gtk::Widget::has_no_window" ref="389d1d2894bc98132ddf650e2fe00b58" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#389d1d2894bc98132ddf650e2fe00b58">has_no_window</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget doesn't have it's own <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>. <br></dl><li><a class="anchor" name="4cff7099656a8bc4cecafd38e3a6a539"></a><!-- doxytag: member="Xfc::Gtk::Widget::is_realized" ref="4cff7099656a8bc4cecafd38e3a6a539" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4cff7099656a8bc4cecafd38e3a6a539">is_realized</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget is realized. <br></dl><li><a class="anchor" name="9785bc55c26f9329d12364f795234ab2"></a><!-- doxytag: member="Xfc::Gtk::Widget::is_mapped" ref="9785bc55c26f9329d12364f795234ab2" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9785bc55c26f9329d12364f795234ab2">is_mapped</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget is mapped. <br></dl><li><a class="anchor" name="89f5db83aff85d8b66e48123c4c6661c"></a><!-- doxytag: member="Xfc::Gtk::Widget::is_visible" ref="89f5db83aff85d8b66e48123c4c6661c" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#89f5db83aff85d8b66e48123c4c6661c">is_visible</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget is visible. <br></dl><li><a class="anchor" name="e41dea61b0064a5a43785c073e0cf582"></a><!-- doxytag: member="Xfc::Gtk::Widget::is_drawable" ref="e41dea61b0064a5a43785c073e0cf582" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e41dea61b0064a5a43785c073e0cf582">is_drawable</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget is mapped and visible. <br></dl><li><a class="anchor" name="6704a32e42d92cb1898b4b687b5906b1"></a><!-- doxytag: member="Xfc::Gtk::Widget::sensitive" ref="6704a32e42d92cb1898b4b687b5906b1" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6704a32e42d92cb1898b4b687b5906b1">sensitive</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c99f3596db588313d102f5b12eed3c9cbc">Gtk::SENSITIVE</a> flag has be set on the widget. <br></dl><li><a class="anchor" name="0fa1f476fa42f813e9c6e93d2cd8fee8"></a><!-- doxytag: member="Xfc::Gtk::Widget::parent_sensitive" ref="0fa1f476fa42f813e9c6e93d2cd8fee8" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0fa1f476fa42f813e9c6e93d2cd8fee8">parent_sensitive</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c9e1170301c96fad178acd63ee8e50f5ad">Gtk::PARENT_SENSITIVE</a> flag has be set on the widget. <br></dl><li><a class="anchor" name="ee04ec2b1b821d5ca27a9f3dc754c9fd"></a><!-- doxytag: member="Xfc::Gtk::Widget::is_sensitive" ref="ee04ec2b1b821d5ca27a9f3dc754c9fd" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ee04ec2b1b821d5ca27a9f3dc754c9fd">is_sensitive</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget is effectively sensitive. <br></dl><li><a class="anchor" name="6118f0aaa3794937f6cf871e605d8d07"></a><!-- doxytag: member="Xfc::Gtk::Widget::can_focus" ref="6118f0aaa3794937f6cf871e605d8d07" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6118f0aaa3794937f6cf871e605d8d07">can_focus</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget is able to handle focus grabs. <br></dl><li><a class="anchor" name="e88bba147c7b9e959236d4da285bf9f3"></a><!-- doxytag: member="Xfc::Gtk::Widget::has_focus" ref="e88bba147c7b9e959236d4da285bf9f3" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e88bba147c7b9e959236d4da285bf9f3">has_focus</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget has grabbed the focus and no other widget has done so more recently. <br></dl><li><a class="anchor" name="cde1120cdf4449a55e688868e07d09e4"></a><!-- doxytag: member="Xfc::Gtk::Widget::can_default" ref="cde1120cdf4449a55e688868e07d09e4" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#cde1120cdf4449a55e688868e07d09e4">can_default</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget is allowed to receive the default action via <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1c1296110f2cd529d06294e54fbaf0c6">grab_default()</a>. <br></dl><li><a class="anchor" name="208dde302f2cf2a4416355295d1d21c6"></a><!-- doxytag: member="Xfc::Gtk::Widget::has_default" ref="208dde302f2cf2a4416355295d1d21c6" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#208dde302f2cf2a4416355295d1d21c6">has_default</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget currently is receiving the default action. <br></dl><li><a class="anchor" name="661658fbff740460f50661ec4fe2a228"></a><!-- doxytag: member="Xfc::Gtk::Widget::has_grab" ref="661658fbff740460f50661ec4fe2a228" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#661658fbff740460f50661ec4fe2a228">has_grab</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget is in the grab_widgets stack, and will be the preferred one for receiving events other than ones of cosmetic value. <br></dl><li><a class="anchor" name="0de90a9a6d2f90c3a0ca26b68a8e2e2e"></a><!-- doxytag: member="Xfc::Gtk::Widget::has_rc_style" ref="0de90a9a6d2f90c3a0ca26b68a8e2e2e" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0de90a9a6d2f90c3a0ca26b68a8e2e2e">has_rc_style</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widgets style has been looked up through the rc mechanism. <br></dl><li><a class="anchor" name="f5a9b892fa457e3c3c81f07012ab45c7"></a><!-- doxytag: member="Xfc::Gtk::Widget::is_composite_child" ref="f5a9b892fa457e3c3c81f07012ab45c7" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f5a9b892fa457e3c3c81f07012ab45c7">is_composite_child</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget is a composite child of its parent. <br></dl><li><a class="anchor" name="f6f1b6ba19a423f6bc92a7640f60bdc0"></a><!-- doxytag: member="Xfc::Gtk::Widget::is_app_paintable" ref="f6f1b6ba19a423f6bc92a7640f60bdc0" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f6f1b6ba19a423f6bc92a7640f60bdc0">is_app_paintable</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c9ba4cadd7f5a6a678609f0405f5e6d38c">Gtk::APP_PAINTABLE</a> flag has been set on the widget. <br></dl><li><a class="anchor" name="18d1ed3b6f9ace80a60ba4233335ba4b"></a><!-- doxytag: member="Xfc::Gtk::Widget::receives_default" ref="18d1ed3b6f9ace80a60ba4233335ba4b" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#18d1ed3b6f9ace80a60ba4233335ba4b">receives_default</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the widget when focused will receive the default action even if there is a different widget set as default. <br></dl><li><a class="anchor" name="db5cff5918728298616847daee4cb867"></a><!-- doxytag: member="Xfc::Gtk::Widget::is_double_buffered" ref="db5cff5918728298616847daee4cb867" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#db5cff5918728298616847daee4cb867">is_double_buffered</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c9bc2c1dc99638146f1a614234c2e80ba0">Gtk::DOUBLE_BUFFERED</a> flag has been set on the widget. <br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#21c78a3000996fb96911f79f62329f0d">get_no_show_all</a> () const
<dl class="el"><dd class="mdescRight">Returns the current value of the "no_show_all" property, which determines whether calls to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8899912c1b7fbc45f079eb881378855e">show_all()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5aa49027f31a9e81c744a85dbb447230">hide_all()</a> will affect this widget.  <a href="#21c78a3000996fb96911f79f62329f0d"></a><br></dl><li><a class="anchor" name="02ef96f5ca58eb0b101c0ffb21d39e93"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_state" ref="02ef96f5ca58eb0b101c0ffb21d39e93" args="() const" -->
<a class="el" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#02ef96f5ca58eb0b101c0ffb21d39e93">get_state</a> () const
<dl class="el"><dd class="mdescRight">Returns the current state of the widget. <br></dl><li><a class="anchor" name="c26414506a65e78fd2e75b69517960f8"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_allocation" ref="c26414506a65e78fd2e75b69517960f8" args="() const" -->
const <a class="el" href="classXfc_1_1Gtk_1_1Allocation.html">Allocation</a> &amp; <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c26414506a65e78fd2e75b69517960f8">get_allocation</a> () const
<dl class="el"><dd class="mdescRight">Returns the size allocated to the widget. <br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1Requisition.html">Requisition</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7948898892ec0a131dab68118f90f594">get_child_requisition</a> () const
<dl class="el"><dd class="mdescRight">Obtains the child widget requisition (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8b5d8c7c83be88fc4154c009bf84b7c4">get_child_requisition(Requisition&amp;) const</a>).  <a href="#7948898892ec0a131dab68118f90f594"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8b5d8c7c83be88fc4154c009bf84b7c4">get_child_requisition</a> (<a class="el" href="classXfc_1_1Gtk_1_1Requisition.html">Requisition</a> &amp;requisition) const
<dl class="el"><dd class="mdescRight">Obtains the child widget requisition, unless someone has forced a particular geometry on the widget, in which case it returns that geometry instead of the widget's requisition.  <a href="#8b5d8c7c83be88fc4154c009bf84b7c4"></a><br></dl><li><a class="anchor" name="372987c45c49c185ca68a645753170f8"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_window" ref="372987c45c49c185ca68a645753170f8" args="() const" -->
<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#372987c45c49c185ca68a645753170f8">get_window</a> () const
<dl class="el"><dd class="mdescRight">Returns the widget's window or its parent window if it doesn't have a window (which will be indicated by the <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c953af0c2deac47de6edbc4db12f2e1570">Gtk::NO_WINDOW</a> flag being set). <br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#99abb30388c66d53434cec932f0ac86b">is_focus</a> () const
<dl class="el"><dd class="mdescRight">Determines if the widget is the focus widget within its toplevel.  <a href="#99abb30388c66d53434cec932f0ac86b"></a><br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#67762edd0d99cd07c80b39ed6b1994f6">get_name</a> () const
<dl class="el"><dd class="mdescRight">Retrieves the name of the widget (see set_name() for the significance of widget names).  <a href="#67762edd0d99cd07c80b39ed6b1994f6"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c4c559af388602448a1878b70674d07a">get_child_visible</a> () const
<dl class="el"><dd class="mdescRight">Returns the value set with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d0ec3fe0fd2f1ec6e206458d5d67ac37">set_child_visible()</a>.  <a href="#c4c559af388602448a1878b70674d07a"></a><br></dl><li><a class="anchor" name="8c16f6a7667f95fdc476e7657e8500ea"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_parent" ref="8c16f6a7667f95fdc476e7657e8500ea" args="() const" -->
<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8c16f6a7667f95fdc476e7657e8500ea">get_parent</a> () const
<dl class="el"><dd class="mdescRight">Returns the parent container of widget, or null. <br></dl><li><a class="anchor" name="4f64f5a81d3b70a287f1dada668a1788"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_parent_window" ref="4f64f5a81d3b70a287f1dada668a1788" args="() const" -->
<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4f64f5a81d3b70a287f1dada668a1788">get_parent_window</a> () const
<dl class="el"><dd class="mdescRight">Returns the widget's parent window. <br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1327f22a0393deafa7a6b2662dc9d580">get_size_request</a> (int *width, int *height) const
<dl class="el"><dd class="mdescRight">Gets the size request that was explicitly set for the widget using <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#24e094379581001370a84c3e734b5086">set_size_request()</a>.  <a href="#1327f22a0393deafa7a6b2662dc9d580"></a><br></dl><li><a class="anchor" name="a4e5a9664e8d156db26c0f49337054e2"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_extension_events" ref="a4e5a9664e8d156db26c0f49337054e2" args="() const" -->
<a class="el" href="namespaceXfc_1_1Gdk.html#6a40c7183f0539c8c67394dc8a22a917">Gdk::ExtensionMode</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a4e5a9664e8d156db26c0f49337054e2">get_extension_events</a> () const
<dl class="el"><dd class="mdescRight">Retrieves the extension events the widget will receive (see Gdk::Input::set_extension_events()). <br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1d84b43225b3adf011d8f39203458690">get_toplevel</a> () const
<dl class="el"><dd class="mdescRight">This method returns the topmost widget in the container hierarchy the widget is a part of.  <a href="#1d84b43225b3adf011d8f39203458690"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#258504c5914b92444076b4a13e968bb6">get_ancestor</a> (GType widget_type) const
<dl class="el"><dd class="mdescRight">Gets the first ancestor of widget with type widget_type.  <a href="#258504c5914b92444076b4a13e968bb6"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c2c87010818a72f1d04657da1b1bbe9f">get_colormap</a> () const
<dl class="el"><dd class="mdescRight">Returns the colormap that will be used to render the widget.  <a href="#c2c87010818a72f1d04657da1b1bbe9f"></a><br></dl><li><a class="anchor" name="dbadb1e9ac0959244b41fb0f09c6a5af"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_visual" ref="dbadb1e9ac0959244b41fb0f09c6a5af" args="() const" -->
const <a class="el" href="classXfc_1_1Gdk_1_1Visual.html">Gdk::Visual</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dbadb1e9ac0959244b41fb0f09c6a5af">get_visual</a> () const
<dl class="el"><dd class="mdescRight">Returns the visual that will be used to render widget. <br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b86a8b7121b747b1631845620f2ad4f9">get_screen</a> () const
<dl class="el"><dd class="mdescRight">Get the <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> from the toplevel window associated with this widget.  <a href="#b86a8b7121b747b1631845620f2ad4f9"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ffd4ab3d6b155b0b27720cdaa9a7a7ee">has_screen</a> () const
<dl class="el"><dd class="mdescRight">Checks whether there is a <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> is associated with this widget.  <a href="#ffd4ab3d6b155b0b27720cdaa9a7a7ee"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1e913a53641155f0ef9af4370feea24c">get_display</a> () const
<dl class="el"><dd class="mdescRight">Get the <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a> for the toplevel window associated with this widget.  <a href="#1e913a53641155f0ef9af4370feea24c"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#48742f7d3af2a1bab794cd221e944d1c">get_root_window</a> () const
<dl class="el"><dd class="mdescRight">The root window is useful for such purposes as creating a popup <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> associated with the window.  <a href="#48742f7d3af2a1bab794cd221e944d1c"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1Settings.html">Settings</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e00c4701fb64c107746e56a83d838e17">get_settings</a> () const
<dl class="el"><dd class="mdescRight">Gets the settings object holding the settings (global property settings, <a class="el" href="classXfc_1_1Gtk_1_1RC.html">RC</a> file information, etc) used for this widget.  <a href="#e00c4701fb64c107746e56a83d838e17"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a030c1e3cf5b7f275e20855e17b1c604">get_clipboard</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> selection=GDK_SELECTION_CLIPBOARD) const
<dl class="el"><dd class="mdescRight">Returns the clipboard object for the given selection to be used with widget.  <a href="#a030c1e3cf5b7f275e20855e17b1c604"></a><br></dl><li><a class="anchor" name="ca3f99c6ebb38dd9055c41cab7f5b8c2"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_accessible" ref="ca3f99c6ebb38dd9055c41cab7f5b8c2" args="() const" -->
<a class="el" href="classXfc_1_1Atk_1_1Object.html">Atk::Object</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ca3f99c6ebb38dd9055c41cab7f5b8c2">get_accessible</a> () const
<dl class="el"><dd class="mdescRight">Returns an accessible object for this widget. <br></dl><li><a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">Gdk::EventMaskField</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c710ef642daf70c05686487e44ecd112">get_events</a> () const
<dl class="el"><dd class="mdescRight">Gets the event mask for the widget (a bitfield containing flags from the <a class="el" href="namespaceXfc_1_1Gdk.html#f215b70aefcd2357d37bf457ce88c577">Gdk::EventMask</a> enumeration).  <a href="#c710ef642daf70c05686487e44ecd112"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a4887c401cd73c9f95837b413674d6d3">get_pointer</a> (int *x, int *y) const
<dl class="el"><dd class="mdescRight">Obtains the location of the mouse pointer in widget coordinates.  <a href="#a4887c401cd73c9f95837b413674d6d3"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Point.html">Gdk::Point</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d92b9b3392dfdf3deb90840719146231">get_pointer</a> () const
<dl class="el"><dd class="mdescRight">Obtains the location of the mouse pointer in widget coordinates.  <a href="#d92b9b3392dfdf3deb90840719146231"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#32542915e8f8eb18c026cefc0b051910">is_ancestor</a> (<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> *ancestor) const
<dl class="el"><dd class="mdescRight">Determines whether the widget is somewhere inside <em>ancestor</em>, possibly within an intermediate container.  <a href="#32542915e8f8eb18c026cefc0b051910"></a><br></dl><li><a class="anchor" name="d2e9da33227d9a731f069f2333e25e60"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_style" ref="d2e9da33227d9a731f069f2333e25e60" args="() const" -->
<a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d2e9da33227d9a731f069f2333e25e60">get_style</a> () const
<dl class="el"><dd class="mdescRight">Returns the widget <a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#53d57cdf79b45a08d3650ddc1e728c42">set_style()</a>. <br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7e9f937918a47aedfb9ebeee48eaf1c6">rc_get_style</a> () const
<dl class="el"><dd class="mdescRight">Finds all matching <a class="el" href="classXfc_1_1Gtk_1_1RC.html">RC</a> styles for a given widget, composites them together, and then creates a <a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> representing the composite appearance.  <a href="#7e9f937918a47aedfb9ebeee48eaf1c6"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1RcStyle.html">RcStyle</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c471db10f64edd2236a69d57b8420bbd">get_modifier_style</a> () const
<dl class="el"><dd class="mdescRight">Returns the current modifier style for the widget (as set by <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a>).  <a href="#c471db10f64edd2236a69d57b8420bbd"></a><br></dl><li><a class="anchor" name="5b96e83a66d22c82a27f1992e7ea9ea6"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_composite_name" ref="5b96e83a66d22c82a27f1992e7ea9ea6" args="() const" -->
<a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5b96e83a66d22c82a27f1992e7ea9ea6">get_composite_name</a> () const
<dl class="el"><dd class="mdescRight">Returns the composite name of the widget or a null <a class="el" href="classXfc_1_1String.html">String</a> if the widget is not a composite child. <br></dl><li><a class="el" href="classXfc_1_1Pango_1_1Context.html">Pango::Context</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5ef20cc10a065baf8d2ecd5a92d8bf4e">get_pango_context</a> () const
<dl class="el"><dd class="mdescRight">Returns a <a class="el" href="classXfc_1_1Pango_1_1Context.html">Pango::Context</a> with the appropriate colormap, font description and base direction for the widget.  <a href="#5ef20cc10a065baf8d2ecd5a92d8bf4e"></a><br></dl><li><a class="anchor" name="3d132e33a1ba88e1f02a0f279bf56378"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_direction" ref="3d132e33a1ba88e1f02a0f279bf56378" args="() const" -->
<a class="el" href="namespaceXfc_1_1Gtk.html#a0e16bc97f4e6e915aab3365d7f8d6c4">TextDirection</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#3d132e33a1ba88e1f02a0f279bf56378">get_direction</a> () const
<dl class="el"><dd class="mdescRight">Returns the reading direction for the widget (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b988c1512ac41160cdb44b3d0d6b3769">set_direction()</a>). <br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#42fde289bb0c47a910adfd298fcc453e">style_get_property</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;property_name, <a class="el" href="classXfc_1_1G_1_1Value.html">G::Value</a> &amp;value)
<dl class="el"><dd class="mdescRight">Gets the value of a style property of the widget.  <a href="#42fde289bb0c47a910adfd298fcc453e"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0e5c395a1d0e149ef2f983fa1b04cfdb">path</a> (<a class="el" href="classXfc_1_1String.html">String</a> &amp;path, <a class="el" href="classXfc_1_1String.html">String</a> &amp;path_reversed) const
<dl class="el"><dd class="mdescRight">Obtains the full path to the widget.  <a href="#0e5c395a1d0e149ef2f983fa1b04cfdb"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#492a91e2a9e786edf7a279719dd0a67d">class_path</a> (<a class="el" href="classXfc_1_1String.html">String</a> &amp;path, <a class="el" href="classXfc_1_1String.html">String</a> &amp;path_reversed) const
<dl class="el"><dd class="mdescRight">Same as <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0e5c395a1d0e149ef2f983fa1b04cfdb">path()</a>, but always uses the name of a widget's type, never uses a custom name set with set_name().  <a href="#492a91e2a9e786edf7a279719dd0a67d"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#505215cea2d040497ac37144da41b49a">set_flags</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#40b56ef2f8bfaadfd3ab79e49adc69a7">WidgetFlagsField</a> flags)
<dl class="el"><dd class="mdescRight">Turns on certain widget flags.  <a href="#505215cea2d040497ac37144da41b49a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#adfcc2d331d40e353363eaa8e11890b5">unset_flags</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#40b56ef2f8bfaadfd3ab79e49adc69a7">WidgetFlagsField</a> flags)
<dl class="el"><dd class="mdescRight">Turns off certain widget flags.  <a href="#adfcc2d331d40e353363eaa8e11890b5"></a><br></dl><li><a class="anchor" name="5382ddf601e00a2c0a89a88687e6113d"></a><!-- doxytag: member="Xfc::Gtk::Widget::unparent" ref="5382ddf601e00a2c0a89a88687e6113d" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5382ddf601e00a2c0a89a88687e6113d">unparent</a> ()
<dl class="el"><dd class="mdescRight">Used in widget implementations; should be called by implementations of the remove method on <a class="el" href="classXfc_1_1Gtk_1_1Container.html">Gtk::Container</a>, to dissociate a child from the container. <br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#89dc83a4d424c700b9dc9430d18c9fc0">show</a> ()
<dl class="el"><dd class="mdescRight">Flags a widget to be displayed.  <a href="#89dc83a4d424c700b9dc9430d18c9fc0"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#440c456397ad449d54f107a92abc7877">show</a> (bool visible)
<dl class="el"><dd class="mdescRight">Convenience method that combines the functionality of <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#89dc83a4d424c700b9dc9430d18c9fc0">show()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#18467883235d80a8b6f4b7c61ddbd4a9">hide()</a>.  <a href="#440c456397ad449d54f107a92abc7877"></a><br></dl><li><a class="anchor" name="18467883235d80a8b6f4b7c61ddbd4a9"></a><!-- doxytag: member="Xfc::Gtk::Widget::hide" ref="18467883235d80a8b6f4b7c61ddbd4a9" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#18467883235d80a8b6f4b7c61ddbd4a9">hide</a> ()
<dl class="el"><dd class="mdescRight">Reverses the effects of <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#89dc83a4d424c700b9dc9430d18c9fc0">show()</a>, causing the widget to be hidden (invisible to the user). <br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#51eae4b5ef109b6ef59bab07aa602a05">show_now</a> ()
<dl class="el"><dd class="mdescRight">Shows a widget.  <a href="#51eae4b5ef109b6ef59bab07aa602a05"></a><br></dl><li><a class="anchor" name="8899912c1b7fbc45f079eb881378855e"></a><!-- doxytag: member="Xfc::Gtk::Widget::show_all" ref="8899912c1b7fbc45f079eb881378855e" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8899912c1b7fbc45f079eb881378855e">show_all</a> ()
<dl class="el"><dd class="mdescRight">Recursively shows a widget, and any child widgets (if the widget is a container). <br></dl><li><a class="anchor" name="5aa49027f31a9e81c744a85dbb447230"></a><!-- doxytag: member="Xfc::Gtk::Widget::hide_all" ref="5aa49027f31a9e81c744a85dbb447230" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5aa49027f31a9e81c744a85dbb447230">hide_all</a> ()
<dl class="el"><dd class="mdescRight">Recursively hides a widget and any child widgets. <br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a57d7955d439269bc8bf3b7c92502191">set_no_show_all</a> (bool no_show_all)
<dl class="el"><dd class="mdescRight">Sets the "no_show_all" property, which determines whether calls to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8899912c1b7fbc45f079eb881378855e">show_all()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5aa49027f31a9e81c744a85dbb447230">hide_all()</a> will affect this widget.  <a href="#a57d7955d439269bc8bf3b7c92502191"></a><br></dl><li><a class="anchor" name="2d61dd9a519f2c7e94799802f0eb8c81"></a><!-- doxytag: member="Xfc::Gtk::Widget::map" ref="2d61dd9a519f2c7e94799802f0eb8c81" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2d61dd9a519f2c7e94799802f0eb8c81">map</a> ()
<dl class="el"><dd class="mdescRight">Used in widget implementations; causes the widget to be mapped if it isn't already (visible on the screen). <br></dl><li><a class="anchor" name="145ecbfcac6312191a051ba953647ff5"></a><!-- doxytag: member="Xfc::Gtk::Widget::unmap" ref="145ecbfcac6312191a051ba953647ff5" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#145ecbfcac6312191a051ba953647ff5">unmap</a> ()
<dl class="el"><dd class="mdescRight">Used in widget implementations; causes the widget to be unmapped if it's currently mapped (no longer visible on the screen). <br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#80b4fca2f9eaed298515065692fcdcf8">realize</a> ()
<dl class="el"><dd class="mdescRight">Creates the GDK (windowing system) resources associated with a widget.  <a href="#80b4fca2f9eaed298515065692fcdcf8"></a><br></dl><li><a class="anchor" name="9ac0f35ac228b90d79ea19b9278b244b"></a><!-- doxytag: member="Xfc::Gtk::Widget::unrealize" ref="9ac0f35ac228b90d79ea19b9278b244b" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9ac0f35ac228b90d79ea19b9278b244b">unrealize</a> ()
<dl class="el"><dd class="mdescRight">Used in widget implementations; causes a widget to be unrealized (frees all GDK resources associated with the widget, such as <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7cf31b1c61e01ec0a3cae36f41f3da4a">gtk_widget()</a>-&gt;window). <br></dl><li><a class="anchor" name="e5f47fcbecdf34638645c08ff4f3835a"></a><!-- doxytag: member="Xfc::Gtk::Widget::queue_draw" ref="e5f47fcbecdf34638645c08ff4f3835a" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e5f47fcbecdf34638645c08ff4f3835a">queue_draw</a> ()
<dl class="el"><dd class="mdescRight">Equivalent to calling <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8cab7a57649c6a60cc0167bc4e87f13f">queue_draw_area()</a> for the entire area of a widget. <br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8cab7a57649c6a60cc0167bc4e87f13f">queue_draw_area</a> (int x, int y, int width, int height)
<dl class="el"><dd class="mdescRight">Invalidates the rectangular area of the widget defined by x, y, width and height by calling Gdk::Window::invalidate_rect() on the widget's window and all its child windows.  <a href="#8cab7a57649c6a60cc0167bc4e87f13f"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ed13e8ec0f724aca97aca22607236d30">queue_draw_area</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Gdk::Rectangle</a> &amp;rectangle)
<dl class="el"><dd class="mdescRight">Invalidates the rectangular area of the widget defined by rectangle by calling Gdk::Window::invalidate_rect() on the widget's window and all its child windows.  <a href="#ed13e8ec0f724aca97aca22607236d30"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#214c3751972dc9a038ae3ec43cc4e2a7">queue_resize</a> ()
<dl class="el"><dd class="mdescRight">This method is only for use in widget implementations.  <a href="#214c3751972dc9a038ae3ec43cc4e2a7"></a><br></dl><li><a class="anchor" name="ee156c1bfc1fe220cca158a9eb38d9be"></a><!-- doxytag: member="Xfc::Gtk::Widget::queue_resize_no_redraw" ref="ee156c1bfc1fe220cca158a9eb38d9be" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ee156c1bfc1fe220cca158a9eb38d9be">queue_resize_no_redraw</a> ()
<dl class="el"><dd class="mdescRight">This function works like <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#214c3751972dc9a038ae3ec43cc4e2a7">queue_resize()</a>, except that the widget is not invalidated. <br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9bbfcdf4796c1e194750837080343bdd">size_request</a> (<a class="el" href="classXfc_1_1Gtk_1_1Requisition.html">Requisition</a> *requisition)
<dl class="el"><dd class="mdescRight">Typically used when implementing a <a class="el" href="classXfc_1_1Gtk_1_1Container.html">Container</a> subclass; obtains the preferred size of the widget.  <a href="#9bbfcdf4796c1e194750837080343bdd"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#90c6becce9ed59bff1e14476ec2c3c29">size_allocate</a> (const <a class="el" href="classXfc_1_1Gtk_1_1Allocation.html">Allocation</a> &amp;allocation)
<dl class="el"><dd class="mdescRight">This method is only used by <a class="el" href="classXfc_1_1Gtk_1_1Container.html">Container</a> subclasses to assign a size and position to their child widgets.  <a href="#90c6becce9ed59bff1e14476ec2c3c29"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7d325be1f004b99a594d89318ce7614a">add_accelerator</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;accel_signal, <a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> &amp;accel_group, const <a class="el" href="classXfc_1_1Gtk_1_1AccelKey.html">AccelKey</a> &amp;accel_key)
<dl class="el"><dd class="mdescRight">Installs an accelerator for this widget in accel_group that causes accel_signal to be emitted if the accelerator is activated.  <a href="#7d325be1f004b99a594d89318ce7614a"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#3e80b7483645111139e04a21ccc7237f">remove_accelerator</a> (<a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> &amp;accel_group, const <a class="el" href="classXfc_1_1Gtk_1_1AccelKey.html">AccelKey</a> &amp;accel_key)
<dl class="el"><dd class="mdescRight">Removes an accelerator from the widget previously installed with add_accelerator().  <a href="#3e80b7483645111139e04a21ccc7237f"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1b5fd017a082c839cdd463e3a850ae6b">set_accel_path</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;accel_path, <a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> &amp;accel_group)
<dl class="el"><dd class="mdescRight">Given an accelerator group <em>accel_group</em> and an accelerator path <em>accel_path</em>, sets up an accelerator in accel_group so whenever the key binding that is defined for accel_path is pressed, the widget will be activated.  <a href="#1b5fd017a082c839cdd463e3a850ae6b"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fe049ce2c9c66f5afb72442f22dd8b64">list_accel_closures</a> (std::vector&lt; GClosure * &gt; &amp;closures)
<dl class="el"><dd class="mdescRight">Lists the closures used by the widget for accelerator group connections with <a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html#7538e051c3f9eba5b10d338a8edfaa98">Gtk::AccelGroup::connect()</a>.  <a href="#fe049ce2c9c66f5afb72442f22dd8b64"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f5ff065ba932f27fd1ccdd3d5f8bc792">can_activate_accel</a> (unsigned int signal_id)
<dl class="el"><dd class="mdescRight">Determines whether an accelerator that activates the signal identified by <em>signal_id</em> can currently be activated.  <a href="#f5ff065ba932f27fd1ccdd3d5f8bc792"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#40d627ac232137df963a6228a9a57448">can_activate_accel</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;signal_name)
<dl class="el"><dd class="mdescRight">Determines whether an accelerator that activates the signal identified by <em>signal_name</em> can currently be activated (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f5ff065ba932f27fd1ccdd3d5f8bc792">can_activate_accel(unsigned int)</a>).  <a href="#40d627ac232137df963a6228a9a57448"></a><br></dl><li>int <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#55fd745ba651d627fdfb2af4fa203106">send_expose</a> (const <a class="el" href="classXfc_1_1Gdk_1_1EventExpose.html">Gdk::EventExpose</a> &amp;event)
<dl class="el"><dd class="mdescRight">This rarely-used method is used to emit an <em>expose_event</em> signal on the widget.  <a href="#55fd745ba651d627fdfb2af4fa203106"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1f256d2aec87fb438488f4f733ad4f81">mnemonic_activate</a> (bool group_cycling)
<dl class="el"><dd class="mdescRight">Actviates the widget if it's suitable for mnemonic actviaton.  <a href="#1f256d2aec87fb438488f4f733ad4f81"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e6c4c09b41c3c29e2f3e2e130765ff0e">event</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Event.html">Gdk::Event</a> &amp;event)
<dl class="el"><dd class="mdescRight">This rarely-used method is used to emit the event signals on a widget (those signals should never be emitted without using this method to do so).  <a href="#e6c4c09b41c3c29e2f3e2e130765ff0e"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#581be0ca571efe2cebb17f3a261bfce1">activate</a> ()
<dl class="el"><dd class="mdescRight">For widgets that can be activated (buttons, menu items, etc) this method activates them.  <a href="#581be0ca571efe2cebb17f3a261bfce1"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#07b6646fb2340acfd681247397e92cda">set_scroll_adjustments</a> (<a class="el" href="classXfc_1_1Gtk_1_1Adjustment.html">Adjustment</a> *hadjustment, <a class="el" href="classXfc_1_1Gtk_1_1Adjustment.html">Adjustment</a> *vadjustment)
<dl class="el"><dd class="mdescRight">Sets the widget's scroll adjustments.  <a href="#07b6646fb2340acfd681247397e92cda"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#875a1ae46089f8732e53fa5e41d33335">reparent</a> (<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;new_parent)
<dl class="el"><dd class="mdescRight">Moves a widget from one <a class="el" href="classXfc_1_1Gtk_1_1Container.html">Container</a> to another, handling reference count issues to avoid destroying the widget.  <a href="#875a1ae46089f8732e53fa5e41d33335"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#69ab4f48efd95cf3bb3e4cc7eb6dddb0">intersect</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Gdk::Rectangle</a> &amp;area, <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Gdk::Rectangle</a> *intersection)
<dl class="el"><dd class="mdescRight">Computes the intersection of a widget's area and <em>area</em>, storing the intersection in <em>intersection</em>, and returns true if there was an intersection.  <a href="#69ab4f48efd95cf3bb3e4cc7eb6dddb0"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Gdk::Rectangle</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7c8984a9798d5e2c4ed61de7b23b857c">intersect</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Gdk::Rectangle</a> &amp;area)
<dl class="el"><dd class="mdescRight">Computes the intersection of a widget's area and <em>area</em>, and returns the intersection as a rectanlge.  <a href="#7c8984a9798d5e2c4ed61de7b23b857c"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Region.html">Gdk::Region</a> &gt; <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#3d0e03a63ec097b192f7e2d10987de83">intersect</a> (<a class="el" href="classXfc_1_1Gdk_1_1Region.html">Gdk::Region</a> &amp;region)
<dl class="el"><dd class="mdescRight">Computes the intersection of a widget's area and <em>region</em>, and returns the intersection as a new <a class="el" href="classXfc_1_1Gdk_1_1Region.html">Gdk::Region</a>.  <a href="#3d0e03a63ec097b192f7e2d10987de83"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b352485cdf0b239d7371b8a9c6d6f7db">freeze_child_notify</a> ()
<dl class="el"><dd class="mdescRight">Stops the emission of <em>child_notify</em> signals on the widget.  <a href="#b352485cdf0b239d7371b8a9c6d6f7db"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#807a7c6bf3e2a48cb009d91f10546a9e">child_notify</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;child_property)
<dl class="el"><dd class="mdescRight">Emits a <em>child_notify</em> signal for the child property <em>child_property</em> on the widget.  <a href="#807a7c6bf3e2a48cb009d91f10546a9e"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4c9a57588e3b31f44e8c82da637357fe">thaw_child_notify</a> ()
<dl class="el"><dd class="mdescRight">Reverts the effect of a prevoious call to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b352485cdf0b239d7371b8a9c6d6f7db">freeze_child_notify()</a>.  <a href="#4c9a57588e3b31f44e8c82da637357fe"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2faac78256ebb7930dc1d0812f77f19f">grab_focus</a> ()
<dl class="el"><dd class="mdescRight">Causes the widget to have the keyboard focus for the <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> it's inside.  <a href="#2faac78256ebb7930dc1d0812f77f19f"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1c1296110f2cd529d06294e54fbaf0c6">grab_default</a> ()
<dl class="el"><dd class="mdescRight">Causes the widget to become the default widget.  <a href="#1c1296110f2cd529d06294e54fbaf0c6"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0c65ad766fe498f5ad1b6c3fbc8600d2">set_name</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;name)
<dl class="el"><dd class="mdescRight">Widgets can be named, which allows you to refer to them in a gtkrc file.  <a href="#0c65ad766fe498f5ad1b6c3fbc8600d2"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4e4acd0b89b63bf7929db752e76ec433">set_state</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a> state)
<dl class="el"><dd class="mdescRight">Used in widget implementations; sets the state of the widget (insensitive, prelighted, etc).  <a href="#4e4acd0b89b63bf7929db752e76ec433"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5d4c47ee11b05fc5e79a21fc70ed3c5e">set_sensitive</a> (bool sensitive)
<dl class="el"><dd class="mdescRight">Sets the sensitivity of the widget.  <a href="#5d4c47ee11b05fc5e79a21fc70ed3c5e"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ad586e62735f47e717a6ffa4405da6a6">set_app_paintable</a> (bool app_paintable)
<dl class="el"><dd class="mdescRight">Sets the <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c9ba4cadd7f5a6a678609f0405f5e6d38c">Gtk::APP_PAINTABLE</a> flags on the widget.  <a href="#ad586e62735f47e717a6ffa4405da6a6"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#46da3ae55128596cbd64744859fd35a5">set_double_buffered</a> (bool double_buffered)
<dl class="el"><dd class="mdescRight">Widgets are double buffered by default; you can use this function to turn off the buffering.  <a href="#46da3ae55128596cbd64744859fd35a5"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a9a3ab10ce909a7bf1cb480d83a575f6">set_redraw_on_allocate</a> (bool redraw_on_allocate)
<dl class="el"><dd class="mdescRight">When a widgets size allocation changes, sets whether the entire widget is queued for drawing or not.  <a href="#a9a3ab10ce909a7bf1cb480d83a575f6"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dbd679ef62d4f8b9634229a7da6c9da1">set_parent</a> (<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;parent)
<dl class="el"><dd class="mdescRight">Sets the container as the parent of widget, and takes care of some details such as updating the state and style of the child to reflect its new location.  <a href="#dbd679ef62d4f8b9634229a7da6c9da1"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c9b5bd324796a58fbecaa070abe167ca">set_parent_window</a> (<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> *parent_window)
<dl class="el"><dd class="mdescRight">Sets a non default parent window for widget.  <a href="#c9b5bd324796a58fbecaa070abe167ca"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d0ec3fe0fd2f1ec6e206458d5d67ac37">set_child_visible</a> (bool is_visible)
<dl class="el"><dd class="mdescRight">Sets whether the widget should be mapped along with its parent when its parent is mapped and the widget has been shown with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#89dc83a4d424c700b9dc9430d18c9fc0">show()</a>.  <a href="#d0ec3fe0fd2f1ec6e206458d5d67ac37"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#86f0ae26c49ed54845b4d6ea52ac4bad">child_focus</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#cb399182c672579f9bce45564fabd10f">DirectionType</a> direction)
<dl class="el"><dd class="mdescRight">Moves the focus to the child widget.  <a href="#86f0ae26c49ed54845b4d6ea52ac4bad"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#24e094379581001370a84c3e734b5086">set_size_request</a> (int width, int height)
<dl class="el"><dd class="mdescRight">Sets the minimum size of a widget; that is, the widget's size request will be width by height.  <a href="#24e094379581001370a84c3e734b5086"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#06f53f990c65616d0f680ecd32ae630a">set_events</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">Gdk::EventMaskField</a> events)
<dl class="el"><dd class="mdescRight">Sets the event mask (see <a class="el" href="namespaceXfc_1_1Gdk.html#f215b70aefcd2357d37bf457ce88c577">Gdk::EventMask</a>) for a widget.  <a href="#06f53f990c65616d0f680ecd32ae630a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9f1a749538a1ab0ffb2361678901874e">add_events</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">Gdk::EventMaskField</a> events)
<dl class="el"><dd class="mdescRight">Adds the events in the bitfield <em>events</em> to the event mask for the widget (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#06f53f990c65616d0f680ecd32ae630a">set_events()</a>).  <a href="#9f1a749538a1ab0ffb2361678901874e"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#491a8eb8d2c7b4cd7297d0896c9d3a60">set_extension_events</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#6a40c7183f0539c8c67394dc8a22a917">Gdk::ExtensionMode</a> mode)
<dl class="el"><dd class="mdescRight">Sets the extension events mask to <em>mode</em> (see <a class="el" href="namespaceXfc_1_1Gdk.html#6a40c7183f0539c8c67394dc8a22a917">Gdk::ExtensionMode</a> and Gdk::Input::set_extension_events()).  <a href="#491a8eb8d2c7b4cd7297d0896c9d3a60"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#43c629f6b651c0dc209016d278cd75fc">set_colormap</a> (<a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a> &amp;colormap)
<dl class="el"><dd class="mdescRight">Sets the colormap for the widget to <em>colormap</em>.  <a href="#43c629f6b651c0dc209016d278cd75fc"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#df04285b15497506dd9ab063f084c1e8">translate_coordinates</a> (<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;src_widget, int src_x, int src_y, int *dest_x, int *dest_y) const
<dl class="el"><dd class="mdescRight">Translate coordinates relative to src_widget's allocation to coordinates relative to this widget's allocation.  <a href="#df04285b15497506dd9ab063f084c1e8"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#53d57cdf79b45a08d3650ddc1e728c42">set_style</a> (<a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> &amp;style)
<dl class="el"><dd class="mdescRight">Sets the <a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> for the widget.  <a href="#53d57cdf79b45a08d3650ddc1e728c42"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bc3751e620e23469a09f74940afac23a">ensure_style</a> ()
<dl class="el"><dd class="mdescRight">Ensures that the widget has a style.  <a href="#bc3751e620e23469a09f74940afac23a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style</a> (<a class="el" href="classXfc_1_1Gtk_1_1RcStyle.html">RcStyle</a> &amp;style)
<dl class="el"><dd class="mdescRight">Modifies style values on the widget.  <a href="#6ee0cf2a19285d405164ef94da93a2e9"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c3e7bce80c4253899382374742c40ec5">modify_fg</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a> state, const <a class="el" href="classXfc_1_1Gdk_1_1Color.html">Gdk::Color</a> *color)
<dl class="el"><dd class="mdescRight">Sets the foreground color for the widget in a particular state.  <a href="#c3e7bce80c4253899382374742c40ec5"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fb887de4c1f3424b9c5a9f245bd2910f">modify_bg</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a> state, const <a class="el" href="classXfc_1_1Gdk_1_1Color.html">Gdk::Color</a> *color)
<dl class="el"><dd class="mdescRight">Sets the background color for the widget in a particular state.  <a href="#fb887de4c1f3424b9c5a9f245bd2910f"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0f9ca2d7a76b3beb80088e0962881b67">modify_text</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a> state, const <a class="el" href="classXfc_1_1Gdk_1_1Color.html">Gdk::Color</a> *color)
<dl class="el"><dd class="mdescRight">Sets the text color for the widget in a particular state.  <a href="#0f9ca2d7a76b3beb80088e0962881b67"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#97a153f8171a24884a52727c6444b43b">modify_base</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a> state, const <a class="el" href="classXfc_1_1Gdk_1_1Color.html">Gdk::Color</a> *color)
<dl class="el"><dd class="mdescRight">Sets the base color for the widget in a particular state.  <a href="#97a153f8171a24884a52727c6444b43b"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fcc8b7875eed5d84d3e556371e22f502">modify_font</a> (const <a class="el" href="classXfc_1_1Pango_1_1FontDescription.html">Pango::FontDescription</a> *font_desc)
<dl class="el"><dd class="mdescRight">Sets the font to use for the widget.  <a href="#fcc8b7875eed5d84d3e556371e22f502"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Pango_1_1Context.html">Pango::Context</a> &gt; <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#edade1fbad742313d285cede0135a174">create_pango_context</a> ()
<dl class="el"><dd class="mdescRight">Creates a new <a class="el" href="classXfc_1_1Pango_1_1Context.html">Pango::Context</a> with the appropriate colormap, font description, and base direction for drawing text for this widget (see also <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5ef20cc10a065baf8d2ecd5a92d8bf4e">get_pango_context()</a>).  <a href="#edade1fbad742313d285cede0135a174"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Pango_1_1Layout.html">Pango::Layout</a> &gt; <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b5e767648f758e7f11d691c542e468a7">create_pango_layout</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;text)
<dl class="el"><dd class="mdescRight">Creates a new <a class="el" href="classXfc_1_1Pango_1_1Layout.html">Pango::Layout</a> with the appropriate colormap, font description, and base direction for drawing text for this widget.  <a href="#b5e767648f758e7f11d691c542e468a7"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &gt; <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6e3c25d0404f97ab2364432ac76a28c9">render_icon</a> (const <a class="el" href="classXfc_1_1Gtk_1_1StockId.html">StockId</a> &amp;stock_id, <a class="el" href="namespaceXfc_1_1Gtk.html#7dcd2f2d59523925457282711a37dfd5">IconSize</a> size, const char *detail=0)
<dl class="el"><dd class="mdescRight">A convenience method that uses the theme engine and <a class="el" href="classXfc_1_1Gtk_1_1RC.html">RC</a> file settings for the widget to look up stock_id and render it to a pixbuf.  <a href="#6e3c25d0404f97ab2364432ac76a28c9"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8f5e1b1a86c708dd116f51adb8221ce9">set_composite_name</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;name)
<dl class="el"><dd class="mdescRight">Sets a widgets composite name.  <a href="#8f5e1b1a86c708dd116f51adb8221ce9"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#737ecd03de45e3e66f0d926840c6372c">reset_rc_styles</a> ()
<dl class="el"><dd class="mdescRight">Reset the styles of the widget and all descendents, so when they are looked up again, they get the correct values for the currently loaded <a class="el" href="classXfc_1_1Gtk_1_1RC.html">RC</a> file settings.  <a href="#737ecd03de45e3e66f0d926840c6372c"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b988c1512ac41160cdb44b3d0d6b3769">set_direction</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#a0e16bc97f4e6e915aab3365d7f8d6c4">TextDirection</a> dir)
<dl class="el"><dd class="mdescRight">Sets the reading direction on a particular widget.  <a href="#b988c1512ac41160cdb44b3d0d6b3769"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4ac40c2f282820b775e250a8146a5959">shape_combine_mask</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Gdk::Bitmap</a> &amp;shape_mask, int offset_x, int offset_y)
<dl class="el"><dd class="mdescRight">Sets a shape for this widget's GDK window.  <a href="#4ac40c2f282820b775e250a8146a5959"></a><br></dl><li><a class="anchor" name="72d6726c63d17dcffa00e5e5d4f0b08d"></a><!-- doxytag: member="Xfc::Gtk::Widget::shape_combine_mask" ref="72d6726c63d17dcffa00e5e5d4f0b08d" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#72d6726c63d17dcffa00e5e5d4f0b08d">shape_combine_mask</a> ()
<dl class="el"><dd class="mdescRight">Removes an exisitng shape from this widget's GDK window. <br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9edf3e0ec4ca371f3e40681c64dc522c">list_mnemonic_labels</a> (std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> * &gt; &amp;widgets)
<dl class="el"><dd class="mdescRight">Returns a list of the widgets, normally labels, for which this widget is a the target of a mnemonic (see for example, <a class="el" href="classXfc_1_1Gtk_1_1Label.html#8a1293d4e52f45444847b91050ca5260">Gtk::Label::set_mnemonic_widget()</a>).  <a href="#9edf3e0ec4ca371f3e40681c64dc522c"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#33d9efa87c2dd234e80c62586af58da7">add_mnemonic_label</a> (<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;label)
<dl class="el"><dd class="mdescRight">Adds a widget to the list of mnemonic labels for this widget (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9edf3e0ec4ca371f3e40681c64dc522c">Gtk::Widget::list_mnemonic_labels()</a>).  <a href="#33d9efa87c2dd234e80c62586af58da7"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#aa7ab48be740ae80f71ce4e5cedace87">remove_mnemonic_label</a> (<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;label)
<dl class="el"><dd class="mdescRight">Removes a widget from the list of mnemonic labels for this widget (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9edf3e0ec4ca371f3e40681c64dc522c">Gtk::Widget::list_mnemonic_labels()</a>).  <a href="#aa7ab48be740ae80f71ce4e5cedace87"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Keyboard and Pointer Grab Methods</div></td></tr>
<ul>
<li><a class="el" href="namespaceXfc_1_1Gdk.html#a122cdf630b777e48fce8da9f57a01b6">Gdk::GrabStatus</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7ba1f608d05fdb4aa6fe635c36d461df">keyboard_grab</a> (bool owner_events=false, unsigned int time=GDK_CURRENT_TIME)
<dl class="el"><dd class="mdescRight">Grabs the keyboard so that all events are passed to this widget until the keyboard is ungrabbed with <a class="el" href="namespaceXfc_1_1Gdk.html#18d3b377328e00747fe591469bdc91f6">Gdk::keyboard_ungrab()</a>.  <a href="#7ba1f608d05fdb4aa6fe635c36d461df"></a><br></dl><li><a class="el" href="namespaceXfc_1_1Gdk.html#a122cdf630b777e48fce8da9f57a01b6">Gdk::GrabStatus</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b86b234b154111b58ffa69fdb0e65a41">pointer_grab</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">Gdk::EventMaskField</a> event_mask, <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> *confine_to=0, <a class="el" href="classXfc_1_1Gdk_1_1Cursor.html">Gdk::Cursor</a> *cursor=0, bool owner_events=false, unsigned int time=GDK_CURRENT_TIME)
<dl class="el"><dd class="mdescRight">Grabs the pointer (usually a mouse) so that all events are passed to this widget until the pointer is ungrabbed with <a class="el" href="namespaceXfc_1_1Gdk.html#c01264f9bd5744449473c344b96ae9b8">Gdk::pointer_ungrab()</a>, or the grab widget becomes unviewable.  <a href="#b86b234b154111b58ffa69fdb0e65a41"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Selection Methods (from gtkselection.h)</div></td></tr>
<ul>
<li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#891aa866e1b85c440b06a905f3265682">selection_owner_get</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> selection)
<dl class="el"><dd class="mdescRight">Returns whether the widget owns <em>selection</em>.  <a href="#891aa866e1b85c440b06a905f3265682"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1a510a9bd15f87c3b7d8ce5db22c924d">selection_owner_set</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> selection, unsigned int time, const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a> *display=0)
<dl class="el"><dd class="mdescRight">Claim ownership of a given selection for a particular widget.  <a href="#1a510a9bd15f87c3b7d8ce5db22c924d"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#95463a6bd5e41394320dbc682d22591f">selection_add_target</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> selection, <a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> target, unsigned int info)
<dl class="el"><dd class="mdescRight">Adds the specified target to the list of supported targets for the widget and selection.  <a href="#95463a6bd5e41394320dbc682d22591f"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#629dd90b8a3e6e40557bcc0204011b31">selection_add_target</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> selection, const <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &amp;entry)
<dl class="el"><dd class="mdescRight">Adds the specified target to the list of supported targets for the widget and selection.  <a href="#629dd90b8a3e6e40557bcc0204011b31"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#297733c8ff0ca4fb52839ffa491cb29f">selection_add_targets</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> selection, const std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &gt; &amp;targets)
<dl class="el"><dd class="mdescRight">Adds the targets specified in <em>targets</em> to the list of supported targets for the widget and selection.  <a href="#297733c8ff0ca4fb52839ffa491cb29f"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9317959f9a382d746ce3f2652c2615f6">selection_clear_targets</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> selection)
<dl class="el"><dd class="mdescRight">Remove all targets registered for the given selection for the widget.  <a href="#9317959f9a382d746ce3f2652c2615f6"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a99f2bf2b3dd0adb1c5ba84f112fcd85">selection_convert</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> selection, <a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> target, unsigned int time=GDK_CURRENT_TIME)
<dl class="el"><dd class="mdescRight">Requests the contents of a selection.  <a href="#a99f2bf2b3dd0adb1c5ba84f112fcd85"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#adaed493024e5dc494012b6cae63a751">selection_remove_all</a> ()
<dl class="el"><dd class="mdescRight">Removes all handlers and unsets ownership of all selections for the widget.  <a href="#adaed493024e5dc494012b6cae63a751"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Drag-and-Drop Target Methods (from gtkdnd.h)</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#55ec947a7bf19e2a54804560dd972d56">drag_get_data</a> (<a class="el" href="classXfc_1_1Gtk_1_1DragContext.html">DragContext</a> &amp;context, <a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> target, unsigned int time=GDK_CURRENT_TIME)
<dl class="el"><dd class="mdescRight">Gets the data associated with a drag.  <a href="#55ec947a7bf19e2a54804560dd972d56"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0c9f1821383f18786feeca063d0df314">drag_highlight</a> ()
<dl class="el"><dd class="mdescRight">Draws a highlight around the widget.  <a href="#0c9f1821383f18786feeca063d0df314"></a><br></dl><li><a class="anchor" name="fedcbabc8fc4c676ca84d67a27a49b26"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_unhighlight" ref="fedcbabc8fc4c676ca84d67a27a49b26" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fedcbabc8fc4c676ca84d67a27a49b26">drag_unhighlight</a> ()
<dl class="el"><dd class="mdescRight">Removes a highlight set by <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0c9f1821383f18786feeca063d0df314">drag_highlight()</a> from the widget. <br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0db2fd7ddd3f007189134c474f582e54">drag_dest_set</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#9ec7f9211b2bc5afd55804c223b85ac4">DestDefaultsField</a> flags, const <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &amp;target, <a class="el" href="namespaceXfc_1_1Gdk.html#34899cc9ad073dfff1a1cecf41046825">Gdk::DragActionField</a> actions)
<dl class="el"><dd class="mdescRight">Sets the widget as a potential drop destination.  <a href="#0db2fd7ddd3f007189134c474f582e54"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e9b25e8a5a60f3c2da984db3ee2c5f84">drag_dest_set</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#9ec7f9211b2bc5afd55804c223b85ac4">DestDefaultsField</a> flags, const std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &gt; &amp;targets, <a class="el" href="namespaceXfc_1_1Gdk.html#34899cc9ad073dfff1a1cecf41046825">Gdk::DragActionField</a> actions)
<dl class="el"><dd class="mdescRight">Sets the widget as a potential drop destination.  <a href="#e9b25e8a5a60f3c2da984db3ee2c5f84"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8b32a49c483df1129628964bbb7c1f23">drag_dest_set_proxy</a> (<a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> *proxy_window, <a class="el" href="namespaceXfc_1_1Gdk.html#87518899c90c08b4b0e7e3e89d53a094">Gdk::DragProtocol</a> protocol, bool use_coordinates)
<dl class="el"><dd class="mdescRight">Sets the widget as a proxy for drops to another window.  <a href="#8b32a49c483df1129628964bbb7c1f23"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#259bc1b156948fd1aa58212f14ebb6c2">drag_dest_unset</a> ()
<dl class="el"><dd class="mdescRight">Clears information about a drop destination set with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0db2fd7ddd3f007189134c474f582e54">drag_dest_set()</a>.  <a href="#259bc1b156948fd1aa58212f14ebb6c2"></a><br></dl><li><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7a2ab44ab0e4782fd3ef1c1786507bad">drag_dest_find_target</a> (const <a class="el" href="classXfc_1_1Gtk_1_1DragContext.html">DragContext</a> &amp;context, const <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a> *target_list=0)
<dl class="el"><dd class="mdescRight">Looks for a match between context.targets() and the target_list, returning the first matching target, otherwise returning GDK_NONE.  <a href="#7a2ab44ab0e4782fd3ef1c1786507bad"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#30be3016d3f93956e3f3ae94c71bf2ff">drag_dest_get_target_list</a> () const
<dl class="el"><dd class="mdescRight">Returns the list of targets this widget can accept from drag-and-drop.  <a href="#30be3016d3f93956e3f3ae94c71bf2ff"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#23e46a182839ab5942567e045bd948ca">drag_dest_set_target_list</a> (<a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a> *target_list)
<dl class="el"><dd class="mdescRight">Sets the target types that this widget can accept from drag-and-drop.  <a href="#23e46a182839ab5942567e045bd948ca"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#455b364e84056e15afc6ad982186018c">drag_dest_add_text_targets</a> ()
<dl class="el"><dd class="mdescRight">Add the text targets supported by Gtk::Selection to the target list of the drag destination.  <a href="#455b364e84056e15afc6ad982186018c"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#18427b01393c0ef0207d2af8253f07ab">drag_dest_add_image_targets</a> ()
<dl class="el"><dd class="mdescRight">Add the image targets supported by Gtk::Selection to the target list of the drag destination.  <a href="#18427b01393c0ef0207d2af8253f07ab"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4be15c9196a0ce5146ff281fcb64bfa3">drag_dest_add_uri_targets</a> ()
<dl class="el"><dd class="mdescRight">Add the URI targets supported by Gtk::Selection to the target list of the drag destination.  <a href="#4be15c9196a0ce5146ff281fcb64bfa3"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Drag-and-Drop Source Methods (from gtkdnd.h)</div></td></tr>
<ul>
<li><a class="el" href="classXfc_1_1Gtk_1_1DragContext.html">DragContext</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9ebdd9b7b9290c6deaf27a16b59eaf0d">drag_source_begin</a> (const <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a> &amp;targets, <a class="el" href="namespaceXfc_1_1Gdk.html#34899cc9ad073dfff1a1cecf41046825">Gdk::DragActionField</a> actions, int button, const <a class="el" href="classXfc_1_1Gdk_1_1Event.html">Gdk::Event</a> &amp;event)
<dl class="el"><dd class="mdescRight">Initiates a drag on the source side.  <a href="#9ebdd9b7b9290c6deaf27a16b59eaf0d"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#83b713b73fb29ce222e0bda43791feef">drag_source_set</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">Gdk::ModifierTypeField</a> start_button_mask, const <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &amp;target, <a class="el" href="namespaceXfc_1_1Gdk.html#34899cc9ad073dfff1a1cecf41046825">Gdk::DragActionField</a> actions)
<dl class="el"><dd class="mdescRight">Sets up the widget so that GTK+ will start a drag operation when the user clicks and drags on the widget.  <a href="#83b713b73fb29ce222e0bda43791feef"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#408d35d4a635fe0002657b4ddffbb570">drag_source_set</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">Gdk::ModifierTypeField</a> start_button_mask, const std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &gt; &amp;targets, <a class="el" href="namespaceXfc_1_1Gdk.html#34899cc9ad073dfff1a1cecf41046825">Gdk::DragActionField</a> actions)
<dl class="el"><dd class="mdescRight">Sets up the widget so that GTK+ will start a drag operation when the user clicks and drags on the widget.  <a href="#408d35d4a635fe0002657b4ddffbb570"></a><br></dl><li><a class="anchor" name="b4bd30ab63b5adbec8051bc21102dd01"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_unset" ref="b4bd30ab63b5adbec8051bc21102dd01" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b4bd30ab63b5adbec8051bc21102dd01">drag_source_unset</a> ()
<dl class="el"><dd class="mdescRight">Undoes the effects of <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#83b713b73fb29ce222e0bda43791feef">drag_source_set()</a>. <br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f6c28a8d92ee00a16cf17d1b106e75f2">drag_source_get_target_list</a> () const
<dl class="el"><dd class="mdescRight">Gets the list of targets this widget can provide for drag-and-drop.  <a href="#f6c28a8d92ee00a16cf17d1b106e75f2"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bcb24f0893df9d780ab14fafdfc54617">drag_source_set_target_list</a> (<a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a> *target_list)
<dl class="el"><dd class="mdescRight">Changes the target types that this widget offers for drag-and-drop.  <a href="#bcb24f0893df9d780ab14fafdfc54617"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e0c660114410254ac2875720d6dccdaf">drag_source_add_text_targets</a> ()
<dl class="el"><dd class="mdescRight">Add the text targets supported by Gtk::Selection to the target list of the drag source.  <a href="#e0c660114410254ac2875720d6dccdaf"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#10e06ab83fb839441d784748235407c7">drag_source_add_image_targets</a> ()
<dl class="el"><dd class="mdescRight">Add the image targets supported by Gtk::Selection to the target list of the drag source.  <a href="#10e06ab83fb839441d784748235407c7"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e8d1c2cfb9b3cf85427b28c1c82da80e">drag_source_add_uri_targets</a> ()
<dl class="el"><dd class="mdescRight">Add the URI targets supported by Gtk::Selection to the target list of the drag source.  <a href="#e8d1c2cfb9b3cf85427b28c1c82da80e"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4677eb2ca573372914e54d7c092677e6">drag_source_set_icon</a> (<a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a> *colormap, <a class="el" href="classXfc_1_1Gdk_1_1Pixmap.html">Gdk::Pixmap</a> *pixmap, <a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Gdk::Bitmap</a> *mask)
<dl class="el"><dd class="mdescRight">Sets the icon that will be used for drags from the widget from a pixmap and mask.  <a href="#4677eb2ca573372914e54d7c092677e6"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#77a9552dd400cce6f32afdd54872c754">drag_source_set_icon_pixbuf</a> (<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &amp;pixbuf)
<dl class="el"><dd class="mdescRight">Sets the icon that will be used for drags from the widget from a <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a>.  <a href="#77a9552dd400cce6f32afdd54872c754"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#511294fc062823570e5ca161821f2f9a">drag_source_set_icon_stock</a> (const <a class="el" href="classXfc_1_1Gtk_1_1StockId.html">StockId</a> &amp;stock_id)
<dl class="el"><dd class="mdescRight">Sets the icon that will be used for drags from the widget to a stock icon.  <a href="#511294fc062823570e5ca161821f2f9a"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4f0ef4f0527cda399e34515d7e64bd5c">drag_check_threshold</a> (int start_x, int start_y, int current_x, int current_y)
<dl class="el"><dd class="mdescRight">Checks to see if a mouse drag starting at (start_x, start_y) and ending at (current_x, current_y) has passed the GTK+ drag threshhold, and thus should trigger the beginning of a drag-and-drop operation.  <a href="#4f0ef4f0527cda399e34515d7e64bd5c"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Basic Signal Proxies</div></td></tr>
<ul>
<li><a class="anchor" name="17bfc7dce72663c026e19b602eeb3250"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_show" ref="17bfc7dce72663c026e19b602eeb3250" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ShowSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#17bfc7dce72663c026e19b602eeb3250">signal_show</a> ()
<dl class="el"><dd class="mdescRight">Connect to the show_signal; emitted when a widget becomes visible. <br></dl><li><a class="anchor" name="5e0419fe1123d2f657622a16f2c68655"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_hide" ref="5e0419fe1123d2f657622a16f2c68655" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">HideSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5e0419fe1123d2f657622a16f2c68655">signal_hide</a> ()
<dl class="el"><dd class="mdescRight">Connect to the hide_signal; emitted when a widget is hidden (invisible to the user). <br></dl><li><a class="anchor" name="fa4bd284135052789e635085c9476145"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_map" ref="fa4bd284135052789e635085c9476145" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">MapSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fa4bd284135052789e635085c9476145">signal_map</a> ()
<dl class="el"><dd class="mdescRight">Connect to the map_signal; emitted when a widget becomes mapped. <br></dl><li><a class="anchor" name="22e73a422f40d2b1660f90e7687e91a6"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_unmap" ref="22e73a422f40d2b1660f90e7687e91a6" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">UnmapSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#22e73a422f40d2b1660f90e7687e91a6">signal_unmap</a> ()
<dl class="el"><dd class="mdescRight">Connect to the unmap_signal; emitted when a widget becomes unmapped. <br></dl><li><a class="anchor" name="8d659e300502b77e3c7b574715995152"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_realize" ref="8d659e300502b77e3c7b574715995152" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">RealizeSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8d659e300502b77e3c7b574715995152">signal_realize</a> ()
<dl class="el"><dd class="mdescRight">Connect to the realize_signal; emitted when a widget is realized. <br></dl><li><a class="anchor" name="f4fdcba7d93e60aeaf2b758cfd47bd6b"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_unrealize" ref="f4fdcba7d93e60aeaf2b758cfd47bd6b" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">UnrealizeSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f4fdcba7d93e60aeaf2b758cfd47bd6b">signal_unrealize</a> ()
<dl class="el"><dd class="mdescRight">Connect to the unrealize_signal; emitted when a widget is unrealized. <br></dl><li><a class="anchor" name="0e76cfeed6840141b05345daf11b6f62"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_size_request" ref="0e76cfeed6840141b05345daf11b6f62" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SizeRequestSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0e76cfeed6840141b05345daf11b6f62">signal_size_request</a> ()
<dl class="el"><dd class="mdescRight">Connect to the size_request_signal; emitted to obtain the preferred size of a widget. <br></dl><li><a class="anchor" name="51b3efb74adc317fe9f70c885f9e61d9"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_size_allocate" ref="51b3efb74adc317fe9f70c885f9e61d9" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SizeAllocateSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#51b3efb74adc317fe9f70c885f9e61d9">signal_size_allocate</a> ()
<dl class="el"><dd class="mdescRight">Connect to the size_allocate_signal; emitted when a child widget is allocated a size and position. <br></dl><li><a class="anchor" name="176778d4af5613922959db3cf8c8e464"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_state_changed" ref="176778d4af5613922959db3cf8c8e464" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">StateChangedSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#176778d4af5613922959db3cf8c8e464">signal_state_changed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the state_changed_signal; emitted when the widget state changes. <br></dl><li><a class="anchor" name="6a39e540da54e4f10b6748c4d463e818"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_parent_set" ref="6a39e540da54e4f10b6748c4d463e818" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ParentSetSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6a39e540da54e4f10b6748c4d463e818">signal_parent_set</a> ()
<dl class="el"><dd class="mdescRight">Connect to the parent_set_signal; emitted when the parent container of the widget is set. <br></dl><li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">HierarchyChangedSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8782d715f5659ce928cb77471655d25d">signal_hierarchy_changed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the hierarchy_changed_signal; emitted when there is a change in the hierarchy to which the widget belongs.  <a href="#8782d715f5659ce928cb77471655d25d"></a><br></dl><li><a class="anchor" name="2bfd96313f6c2ff17bf929a472e4c953"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_style_set" ref="2bfd96313f6c2ff17bf929a472e4c953" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">StyleSetSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2bfd96313f6c2ff17bf929a472e4c953">signal_style_set</a> ()
<dl class="el"><dd class="mdescRight">Connect to the style_set_signal; emitted when the widget style is changed. <br></dl><li><a class="anchor" name="84b7eac2845461af36647331d6c1a916"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_direction_changed" ref="84b7eac2845461af36647331d6c1a916" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DirectionChangedSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#84b7eac2845461af36647331d6c1a916">signal_direction_changed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the direction_changed_signal; emitted when the reading direction on the widget is changed. <br></dl><li><a class="anchor" name="b4a24972d1e208a45662ab9ec2f78601"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_grab_notify" ref="b4a24972d1e208a45662ab9ec2f78601" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">GrabNotifySignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b4a24972d1e208a45662ab9ec2f78601">signal_grab_notify</a> ()
<dl class="el"><dd class="mdescRight">Connect to the grab_notify_signal; emitted to notify the widget whether it is the current grabbed widget in an application. <br></dl><li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ChildNotifySignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ed1fc79786f01158aad15d3f158543ac">signal_child_notify</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;property_name)
<dl class="el"><dd class="mdescRight">Connect to the child_notify_signal; emitted for each child property that changes on a widget.  <a href="#ed1fc79786f01158aad15d3f158543ac"></a><br></dl><li><a class="anchor" name="a317d321cc1d783a695b3732cdf24cac"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_mnemonic_activate" ref="a317d321cc1d783a695b3732cdf24cac" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">MnemonicActivateSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a317d321cc1d783a695b3732cdf24cac">signal_mnemonic_activate</a> ()
<dl class="el"><dd class="mdescRight">Connect to the mnemonic_activate_signal; emitted to activate the widget when the mnemonic key it's associated with is pressed. <br></dl><li><a class="anchor" name="97d7b5c2f7406b4ffb2774e3c60217b1"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_grab_focus" ref="97d7b5c2f7406b4ffb2774e3c60217b1" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">GrabFocusSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#97d7b5c2f7406b4ffb2774e3c60217b1">signal_grab_focus</a> ()
<dl class="el"><dd class="mdescRight">Connect to the grab_focus_signal; emitted when the widget receives the keyboard focus for the <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> it's inside. <br></dl><li><a class="anchor" name="af8b5100dae6718f1185ce4bd3ed42fd"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_focus" ref="af8b5100dae6718f1185ce4bd3ed42fd" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">FocusSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#af8b5100dae6718f1185ce4bd3ed42fd">signal_focus</a> ()
<dl class="el"><dd class="mdescRight">Connect to the focus_signal; emitted when on a child widget when it receives the focus (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#86f0ae26c49ed54845b4d6ea52ac4bad">child_focus()</a>). <br></dl><li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">AccelClosuresChangedSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#24506eee68b25c3e547567d0b25870bc">signal_accel_closures_changed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the accel_closures_changed_signal; emitted whenever the closures used by the widget for accelerator group connections are changed.  <a href="#24506eee68b25c3e547567d0b25870bc"></a><br></dl><li><a class="anchor" name="dda4ec70b68830e4615e62acebd55768"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_screen_changed" ref="dda4ec70b68830e4615e62acebd55768" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ScreenChangedSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dda4ec70b68830e4615e62acebd55768">signal_screen_changed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the screen_changed_signal; emitted when the <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> on which the widget is displayed is changed. <br></dl><li><a class="anchor" name="adee8af211cce0b2d50a22192bdfbb0b"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_can_activate_accel" ref="adee8af211cce0b2d50a22192bdfbb0b" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">CanActivateAccelSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#adee8af211cce0b2d50a22192bdfbb0b">signal_can_activate_accel</a> ()
<dl class="el"><dd class="mdescRight">Connect to the can_activate_accel_signal; emitted to determine whether an accelerator that activates the indentifed signal can currently be activated. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Selection Signal Proxies</div></td></tr>
<ul>
<li><a class="anchor" name="dc96a76c3c51e340bcb46c8a94bb5d6c"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_selection_get" ref="dc96a76c3c51e340bcb46c8a94bb5d6c" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SelectionGetSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dc96a76c3c51e340bcb46c8a94bb5d6c">signal_selection_get</a> ()
<dl class="el"><dd class="mdescRight">Connect to the selection_get_signal; emitted when the selection data is requested, if this widget is the selection owner. <br></dl><li><a class="anchor" name="58e569723fdbb064e9b52d75a8bf3b40"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_selection_received" ref="58e569723fdbb064e9b52d75a8bf3b40" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SelectionReceivedSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#58e569723fdbb064e9b52d75a8bf3b40">signal_selection_received</a> ()
<dl class="el"><dd class="mdescRight">Connect to the selection_received_signal; emitted to notify the widget that the requested selection data has been converted and provided by the selection owner. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Source-side Drag Signal Proxies</div></td></tr>
<ul>
<li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragBeginSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f674928b0bba76b663b73a74c11c4f05">signal_drag_begin</a> ()
<dl class="el"><dd class="mdescRight">Connect to the drag_begin_signal; emitted on the drag source when a drag is started.  <a href="#f674928b0bba76b663b73a74c11c4f05"></a><br></dl><li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragEndSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#422589e89a6e3fac29aa85106520ee43">signal_drag_end</a> ()
<dl class="el"><dd class="mdescRight">Connect to the drag_end_signal; emitted on the drag source when a drag is finished.  <a href="#422589e89a6e3fac29aa85106520ee43"></a><br></dl><li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragDataGetSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#eaa9d9fe2067490340754642e0b2fc57">signal_drag_data_get</a> ()
<dl class="el"><dd class="mdescRight">Connect to the drag_data_get_signal; emitted on the drag source when the drop site requests the data of the first target supported.  <a href="#eaa9d9fe2067490340754642e0b2fc57"></a><br></dl><li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragDataDeleteSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e44064466ce0490a3de74dbd4fc70b5b">signal_drag_data_delete</a> ()
<dl class="el"><dd class="mdescRight">Connect to the drag_data_delete_signal; emitted on the drag source when a drag with the action <a class="el" href="namespaceXfc_1_1Gdk.html#cdc94d623b0fc1294b910d9fdbbf8086e8007ba2985ccbc3b43ef697df40f312">Gdk::ACTION_MOVE</a> is successfully completed.  <a href="#e44064466ce0490a3de74dbd4fc70b5b"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Target-side Drag Signal Proxies</div></td></tr>
<ul>
<li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragLeaveSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6736edea849737ae7f96065097752e17">signal_drag_leave</a> ()
<dl class="el"><dd class="mdescRight">Connect to the drag_leave_signal; emitted on the drop site when the cursor leaves the widget.  <a href="#6736edea849737ae7f96065097752e17"></a><br></dl><li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragMotionSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ec4e37a70a1d71665a170506e0a22968">signal_drag_motion</a> ()
<dl class="el"><dd class="mdescRight">Connect to the drag_motion_signal; emitted on the drop site when the user moves the cursor over the widget during a drag.  <a href="#ec4e37a70a1d71665a170506e0a22968"></a><br></dl><li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragDropSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d75dc38d611ba871eddde651d6148dd0">signal_drag_drop</a> ()
<dl class="el"><dd class="mdescRight">Connect to the drag_drop_signal; emitted on the drop site when the user drops the data onto the widget.  <a href="#d75dc38d611ba871eddde651d6148dd0"></a><br></dl><li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragDataReceivedSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#290df63fa2eceaa768f3489c290ca6b5">signal_drag_data_received</a> ()
<dl class="el"><dd class="mdescRight">Connect to the drag_data_received_signal; emitted on the drop site when the dragged data has been received.  <a href="#290df63fa2eceaa768f3489c290ca6b5"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">GDK Event Signal Proxies</div></td></tr>
<ul>
<li><a class="anchor" name="94b859cf217745a51e8bf2d5344deeed"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_event" ref="94b859cf217745a51e8bf2d5344deeed" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">EventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#94b859cf217745a51e8bf2d5344deeed">signal_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the event_signal; emitted when any GDK event occurs. <br></dl><li>const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">EventAfterSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#82454f65f975154fb0eba5bda1c67bf8">signal_event_after</a> ()
<dl class="el"><dd class="mdescRight">Connect to the event_after_signal; emitted after any GDK event occurs.  <a href="#82454f65f975154fb0eba5bda1c67bf8"></a><br></dl><li><a class="anchor" name="29fe506a596b4dd2ba9587f36856c295"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_button_press_event" ref="29fe506a596b4dd2ba9587f36856c295" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ButtonPressEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#29fe506a596b4dd2ba9587f36856c295">signal_button_press_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the button_press_event_signal; emitted when a mouse button has been pressed. <br></dl><li><a class="anchor" name="e64acae5ede5633c48a71db725073ae4"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_button_release_event" ref="e64acae5ede5633c48a71db725073ae4" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ButtonReleaseEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e64acae5ede5633c48a71db725073ae4">signal_button_release_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the button_release_event_signal; emitted when a mouse button has been released. <br></dl><li><a class="anchor" name="53ad3abad2d53e759f2b4d094a848faf"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_scroll_event" ref="53ad3abad2d53e759f2b4d094a848faf" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ScrollEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#53ad3abad2d53e759f2b4d094a848faf">signal_scroll_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the scroll_event_signal; emitted when a mouse wheel is scrolled either up or down. <br></dl><li><a class="anchor" name="615730e9863688c17e3b59bd8fe555e6"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_motion_notify_event" ref="615730e9863688c17e3b59bd8fe555e6" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">MotionNotifyEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#615730e9863688c17e3b59bd8fe555e6">signal_motion_notify_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the motion_notify_event_signal; emitted when the mouse is moved. <br></dl><li><a class="anchor" name="d9f60271ae6ab5a596cd5603e37054ca"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_delete_event" ref="d9f60271ae6ab5a596cd5603e37054ca" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DeleteEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d9f60271ae6ab5a596cd5603e37054ca">signal_delete_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the delete_event_signal; emitted when the user tries to close an application from the window manager frame. <br></dl><li><a class="anchor" name="96511ba76557b4fb334cedaae683af0e"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_destroy_event" ref="96511ba76557b4fb334cedaae683af0e" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DestroyEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#96511ba76557b4fb334cedaae683af0e">signal_destroy_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the destroy_event_signal; emitted when the widget has been destroyed. <br></dl><li><a class="anchor" name="49c2b89395ef7816abcc45b6e5d3b4a0"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_expose_event" ref="49c2b89395ef7816abcc45b6e5d3b4a0" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ExposeEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#49c2b89395ef7816abcc45b6e5d3b4a0">signal_expose_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the expose_event_signal; emitted when all or part of the widget has become visible and needs to be redrawn. <br></dl><li><a class="anchor" name="a4f274e1336592abc88c5b88cc011250"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_key_press_event" ref="a4f274e1336592abc88c5b88cc011250" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">KeyPressEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a4f274e1336592abc88c5b88cc011250">signal_key_press_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the key_press_event_signal; emitted when a key is pressed. <br></dl><li><a class="anchor" name="d1701b246d69c2f7be75ce1989c3c6ba"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_key_release_event" ref="d1701b246d69c2f7be75ce1989c3c6ba" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">KeyReleaseEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d1701b246d69c2f7be75ce1989c3c6ba">signal_key_release_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the key_release_event_signal; emitted when a key is released. <br></dl><li><a class="anchor" name="f002eee0271857b758fa83402eaa8e88"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_enter_notify_event" ref="f002eee0271857b758fa83402eaa8e88" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">EnterNotifyEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f002eee0271857b758fa83402eaa8e88">signal_enter_notify_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the enter_notify_event_signal; emitted when the widget is entered. <br></dl><li><a class="anchor" name="2cfa16cdff20f7922480ef1c690e72a7"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_leave_notify_event" ref="2cfa16cdff20f7922480ef1c690e72a7" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">LeaveNotifyEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2cfa16cdff20f7922480ef1c690e72a7">signal_leave_notify_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the leave_notify_event_signal; emitted when then widget is exited. <br></dl><li><a class="anchor" name="44489a74e958dabe17016828b55cea3f"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_configure_event" ref="44489a74e958dabe17016828b55cea3f" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ConfigureEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#44489a74e958dabe17016828b55cea3f">signal_configure_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the configure_event_signal; emitted when the size, position or stacking order of the widget is changed. <br></dl><li><a class="anchor" name="a4f0f1a9bf07c14b919327ca6fb0b915"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_focus_in_event" ref="a4f0f1a9bf07c14b919327ca6fb0b915" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">FocusInEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a4f0f1a9bf07c14b919327ca6fb0b915">signal_focus_in_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the focus_in_event_signal; emitted when the widget gains the keyboard focus (the focus widget gets keyboard events). <br></dl><li><a class="anchor" name="b8da2eb022bd51e7bdb2a3e56136751c"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_focus_out_event" ref="b8da2eb022bd51e7bdb2a3e56136751c" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">FocusOutEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b8da2eb022bd51e7bdb2a3e56136751c">signal_focus_out_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the focus_out_event_signal; emitted when the widget looses the keyboard focus. <br></dl><li><a class="anchor" name="2c3d1f74275ef213a4e29924bb908257"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_map_event" ref="2c3d1f74275ef213a4e29924bb908257" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">MapEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2c3d1f74275ef213a4e29924bb908257">signal_map_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the map_event_signal; emitted when the widget has been mapped (visible on the screen). <br></dl><li><a class="anchor" name="297ca5a50d37ee22a446b7154949b35e"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_unmap_event" ref="297ca5a50d37ee22a446b7154949b35e" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">UnmapEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#297ca5a50d37ee22a446b7154949b35e">signal_unmap_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the unmap_event_signal; emitted when the widget has been mapped (no longer visible on the screen). <br></dl><li><a class="anchor" name="de929461102ab0c0d90ce22a640d998b"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_property_notify_event" ref="de929461102ab0c0d90ce22a640d998b" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">PropertyNotifyEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#de929461102ab0c0d90ce22a640d998b">signal_property_notify_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the property_notify_event_signal; emitted when a property on the widget has been changed or deleted. <br></dl><li><a class="anchor" name="5a13503cffa1a17ac3eaf466ac4b2e81"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_selection_clear_event" ref="5a13503cffa1a17ac3eaf466ac4b2e81" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SelectionClearEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5a13503cffa1a17ac3eaf466ac4b2e81">signal_selection_clear_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the selection_clear_event_signal; emitted when an application has lost ownership of a selection. <br></dl><li><a class="anchor" name="297deef498809d3cf1616e5c8d37d09f"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_selection_request_event" ref="297deef498809d3cf1616e5c8d37d09f" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SelectionRequestEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#297deef498809d3cf1616e5c8d37d09f">signal_selection_request_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the selection_request_event_signal; emitted when another application has requested a selection. <br></dl><li><a class="anchor" name="adc0ce8251024ba8b9eefefae6438692"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_selection_notify_event" ref="adc0ce8251024ba8b9eefefae6438692" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SelectionNotifyEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#adc0ce8251024ba8b9eefefae6438692">signal_selection_notify_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the selection_notify_event_signal; emitted when a selection has been received. <br></dl><li><a class="anchor" name="653316981d2bef7c693facee31dab25b"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_proximity_in_event" ref="653316981d2bef7c693facee31dab25b" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ProximityInEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#653316981d2bef7c693facee31dab25b">signal_proximity_in_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the proximity_in_event_signal; emitted when an input device has moved into contact with a sensing surface (such as a touchscreen or graphics tablet). <br></dl><li><a class="anchor" name="2377cf4e2c86969da0e6ea639065fe76"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_proximity_out_event" ref="2377cf4e2c86969da0e6ea639065fe76" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ProximityOutEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2377cf4e2c86969da0e6ea639065fe76">signal_proximity_out_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the proximity_out_event_signal; emitted when an input device has moved out of contact with a sensing surface. <br></dl><li><a class="anchor" name="58a89e3fc1f71bf2bd18258bec52911d"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_visibility_notify_event" ref="58a89e3fc1f71bf2bd18258bec52911d" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">VisibilityNotifyEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#58a89e3fc1f71bf2bd18258bec52911d">signal_visibility_notify_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the visibility_notify_event_signal; emitted when the widget's visibility status has changed (either fully obscured, partially obscured or unobscured). <br></dl><li><a class="anchor" name="03337f141db2566c5a5101cccfdb3180"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_client_event" ref="03337f141db2566c5a5101cccfdb3180" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ClientEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#03337f141db2566c5a5101cccfdb3180">signal_client_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the client_event_signal; emitted when a message has been received from another application. <br></dl><li><a class="anchor" name="64e7ca5a1e689b739baa1c33ddfafcd8"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_no_expose_event" ref="64e7ca5a1e689b739baa1c33ddfafcd8" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">NoExposeEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#64e7ca5a1e689b739baa1c33ddfafcd8">signal_no_expose_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the no_expose_event_signal; emitted when all or part of the widget has become visible, but no expose event was generated. <br></dl><li><a class="anchor" name="de207a8ba498a6583a4ea4f0f478784d"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_window_state_event" ref="de207a8ba498a6583a4ea4f0f478784d" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">WindowStateEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#de207a8ba498a6583a4ea4f0f478784d">signal_window_state_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the window_state_event_signal; emitted when the state of a toplevel window changes (either not shown, minimized, maximized, sticky or fullscreen). <br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>static const <a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c5ba7b2ea0919ec9adf43c1b6b2bdeca">get_default_style</a> ()
<dl class="el"><dd class="mdescRight">Returns the default style used by all widgets initially.  <a href="#c5ba7b2ea0919ec9adf43c1b6b2bdeca"></a><br></dl><li><a class="anchor" name="1cdc90e8f1a034a3a6740d02bc072b08"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_default_colormap" ref="1cdc90e8f1a034a3a6740d02bc072b08" args="()" -->
static <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1cdc90e8f1a034a3a6740d02bc072b08">get_default_colormap</a> ()
<dl class="el"><dd class="mdescRight">Returns the default colormap used to create widgets. <br></dl><li>static const <a class="el" href="classXfc_1_1Gdk_1_1Visual.html">Gdk::Visual</a> * <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9e04e6fdaee0045d1ebc0fb966c4676e">get_default_visual</a> ()
<dl class="el"><dd class="mdescRight">Returns the visual of the default colormap.  <a href="#9e04e6fdaee0045d1ebc0fb966c4676e"></a><br></dl><li><a class="anchor" name="dc79c0700ef3cffba0fb35763e0de7dc"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_default_direction" ref="dc79c0700ef3cffba0fb35763e0de7dc" args="()" -->
static <a class="el" href="namespaceXfc_1_1Gtk.html#a0e16bc97f4e6e915aab3365d7f8d6c4">TextDirection</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dc79c0700ef3cffba0fb35763e0de7dc">get_default_direction</a> ()
<dl class="el"><dd class="mdescRight">Returns the current default reading direction (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2b8e3cb53fb1eb451b579d45763a83b2">set_default_direction()</a>). <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>static void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#994aa7b469117de80741d4c9cbdf3895">push_colormap</a> (<a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a> &amp;cmap)
<dl class="el"><dd class="mdescRight">Pushes <em>cmap</em> onto a global stack of colormaps; the topmost colormap on the stack will be used to create all widgets.  <a href="#994aa7b469117de80741d4c9cbdf3895"></a><br></dl><li>static void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bad3faa1076e44c146329d81ffc9b675">push_composite_child</a> ()
<dl class="el"><dd class="mdescRight">A composite child is a child that's an implementation detail of the container it's inside and should not be visible to people using the container.  <a href="#bad3faa1076e44c146329d81ffc9b675"></a><br></dl><li><a class="anchor" name="b86410bdcca490b6c6b5dfd5be68398e"></a><!-- doxytag: member="Xfc::Gtk::Widget::pop_composite_child" ref="b86410bdcca490b6c6b5dfd5be68398e" args="()" -->
static void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b86410bdcca490b6c6b5dfd5be68398e">pop_composite_child</a> ()
<dl class="el"><dd class="mdescRight">Cancels the effect of a previous call to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bad3faa1076e44c146329d81ffc9b675">push_composite_child()</a>. <br></dl><li><a class="anchor" name="7c5c39318f4d717301043f9e6802dddd"></a><!-- doxytag: member="Xfc::Gtk::Widget::pop_colormap" ref="7c5c39318f4d717301043f9e6802dddd" args="()" -->
static void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7c5c39318f4d717301043f9e6802dddd">pop_colormap</a> ()
<dl class="el"><dd class="mdescRight">Removes a colormap pushed with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#994aa7b469117de80741d4c9cbdf3895">push_colormap()</a>. <br></dl><li>static void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e010d5543fe65dc5b8d988849541d5c6">set_default_colormap</a> (<a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a> *colormap)
<dl class="el"><dd class="mdescRight">Sets the default colormap to use when creating widgets.  <a href="#e010d5543fe65dc5b8d988849541d5c6"></a><br></dl><li>static void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2b8e3cb53fb1eb451b579d45763a83b2">set_default_direction</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#a0e16bc97f4e6e915aab3365d7f8d6c4">TextDirection</a> dir)
<dl class="el"><dd class="mdescRight">Sets the default reading direction for widgets where the direction has not been explicitly set by <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b988c1512ac41160cdb44b3d0d6b3769">set_direction()</a>.  <a href="#2b8e3cb53fb1eb451b579d45763a83b2"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Selection Methods (from gtkselection.h)</div></td></tr>
<ul>
<li>static bool <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6511ed909485e1094aeb98fe66361eda">selection_owner_unset</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> selection, unsigned int time, const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a> *display=0)
<dl class="el"><dd class="mdescRight">Releases ownership of a given selection.  <a href="#6511ed909485e1094aeb98fe66361eda"></a><br></dl></ul>
<h2>Protected Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#03667e96de93ea8779fb409c951d9503">set_allocation</a> (const <a class="el" href="classXfc_1_1Gtk_1_1Allocation.html">Allocation</a> &amp;allocation)
<dl class="el"><dd class="mdescRight">Sets the position and size allocated to a child widget.  <a href="#03667e96de93ea8779fb409c951d9503"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#670de87739c9f143b6ddc648fc969ba9">set_window</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> &amp;window)
<dl class="el"><dd class="mdescRight">Sets the <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> for the widget.  <a href="#670de87739c9f143b6ddc648fc969ba9"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GtkWidget C++ wrapper class. 
<p>
<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> is the base class for widgets that make up the graphical user interface, such as windows, menus, buttons, scrollbars, editors, drawing areas, and so on.<p>
After implementing a widget in your application you frequently need to set some widget-specific attributes, such as the widget's size, position, and so on. When the user interacts with a widget, such as pulling down a menu and making a selection, clicking a button, or moving a scrollbar, your application needs to respond by calling a callback slot that you supply. Callback slots are objects that call the class or static method that you want attached to a user action.<p>
A parent-child relationship must be established between widgets in your application, such as by packing a button into a box or adding a menu item to a menu. These releationships provide management capabitilies and help determine the layout of the user interface. After widgets are created, parent-child relationships established, and callback slots attached you need to display the widgets. This is accomplished by calling <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#89dc83a4d424c700b9dc9430d18c9fc0">show()</a> on a widget, or <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8899912c1b7fbc45f079eb881378855e">show_all()</a> on the parent widget to to show all the child widgets at once.<p>
Any user action in you interface causes the corresponding widget to emit a signal, to which your callback slot has been attached. You can respond to these signals in two ways. The first way is to derive a new class from the widget, such as <a class="el" href="classXfc_1_1Gtk_1_1Button.html">Gtk::Button</a>, and override one or more of its inherited virutal signal handlers, such as on_clicked() for the button's "clicked" signal. Continuing with <a class="el" href="classXfc_1_1Gtk_1_1Button.html">Gtk::Button</a>, the second way is to create an instance of <a class="el" href="classXfc_1_1Gtk_1_1Button.html">Gtk::Button</a> and attach to it your clicked callback slot, by calling signal_clicked().connect(slot());<p>
<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> implements this <a class="el" href="classXfc_1_1Atk_1_1Implementor.html">Atk::Implementor</a> interface. Calling <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ca3f99c6ebb38dd9055c41cab7f5b8c2">get_accessible()</a> is the same as calling <a class="el" href="classXfc_1_1Atk_1_1Implementor.html#f733a5c354da495d146b9780c86883ef">ref_accessible()</a> inherited from <a class="el" href="classXfc_1_1Atk_1_1Implementor.html">Atk::Implementor</a>, except <a class="el" href="classXfc_1_1Atk_1_1Implementor.html#f733a5c354da495d146b9780c86883ef">ref_accessible()</a> returns a smart pointer.<p>
<b>See also:</b> the <a href="../../howto/html/widgets.html">Widget</a>, <a href="../../howto/html/composite_widgets.html">Composite Widget</a> and <a href="../../howto/html/custom_widgets.html">Custom Widget</a> HOWTOs and examples. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="7963259a348e451a7fd5c623c4cc500a"></a><!-- doxytag: member="Xfc::Gtk::Widget::Widget" ref="7963259a348e451a7fd5c623c4cc500a" args="(GtkWidget *widget, bool owns_reference=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::Widget::Widget           </td>
          <td>(</td>
          <td class="paramtype">GtkWidget *&nbsp;</td>
          <td class="paramname"> <em>widget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> from an existing GtkWidget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>widget</em>&nbsp;</td><td>A pointer to a GtkWidget. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>widget</em> can be a newly created GtkWidget or an existing GtkWidget (see G::Object::Object). 
</div>
</div><p>
<a class="anchor" name="7963259a348e451a7fd5c623c4cc500a"></a><!-- doxytag: member="Xfc::Gtk::Widget::Widget" ref="7963259a348e451a7fd5c623c4cc500a" args="(GtkWidget *widget, bool owns_reference=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::Widget::Widget           </td>
          <td>(</td>
          <td class="paramtype">GtkWidget *&nbsp;</td>
          <td class="paramname"> <em>widget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> from an existing GtkWidget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>widget</em>&nbsp;</td><td>A pointer to a GtkWidget. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>widget</em> can be a newly created GtkWidget or an existing GtkWidget (see G::Object::Object). 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="03667e96de93ea8779fb409c951d9503"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_allocation" ref="03667e96de93ea8779fb409c951d9503" args="(const Allocation &amp;allocation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_allocation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1Allocation.html">Allocation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the position and size allocated to a child widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>allocation</em>&nbsp;</td><td>The position and size to be allocated to the widget.</td></tr>
  </table>
</dl>
This method can be called from the widget's virtual <em>on_size_request</em> to set the allocation (see the Dial example program). 
</div>
</div><p>
<a class="anchor" name="670de87739c9f143b6ddc648fc969ba9"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_window" ref="670de87739c9f143b6ddc648fc969ba9" args="(const Gdk::Window &amp;window)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_window           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>window</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> for the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>window</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>.</td></tr>
  </table>
</dl>
This method only works if <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7cf31b1c61e01ec0a3cae36f41f3da4a">gtk_widget()</a>-&gt;window is null. It is only for use when implementing a custom widget that derives directly from <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a>. After creating a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> for the custom widget in the widget's virtual <em>on_realize()</em> method you should call this method to set the window. If the widget already has a <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> nothing happens (see the Dial example program). 
</div>
</div><p>
<a class="anchor" name="21c78a3000996fb96911f79f62329f0d"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_no_show_all" ref="21c78a3000996fb96911f79f62329f0d" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::get_no_show_all           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current value of the "no_show_all" property, which determines whether calls to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8899912c1b7fbc45f079eb881378855e">show_all()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5aa49027f31a9e81c744a85dbb447230">hide_all()</a> will affect this widget. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current value of the "no_show_all" property. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7948898892ec0a131dab68118f90f594"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_child_requisition" ref="7948898892ec0a131dab68118f90f594" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1Requisition.html">Requisition</a> Xfc::Gtk::Widget::get_child_requisition           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the child widget requisition (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8b5d8c7c83be88fc4154c009bf84b7c4">get_child_requisition(Requisition&amp;) const</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1Gtk_1_1Requisition.html">Requisition</a> that holds the child widget's width and height. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b5d8c7c83be88fc4154c009bf84b7c4"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_child_requisition" ref="8b5d8c7c83be88fc4154c009bf84b7c4" args="(Requisition &amp;requisition) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::get_child_requisition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Requisition.html">Requisition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>requisition</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the child widget requisition, unless someone has forced a particular geometry on the widget, in which case it returns that geometry instead of the widget's requisition. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>requisition</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gtk_1_1Requisition.html">Requisition</a> to be filled in.</td></tr>
  </table>
</dl>
This method is only for use in widget implementations. It differs from <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9bbfcdf4796c1e194750837080343bdd">size_request()</a> in that it retrieves the last size request value from <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7cf31b1c61e01ec0a3cae36f41f3da4a">gtk_widget()</a>-&gt;requisition, while <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9bbfcdf4796c1e194750837080343bdd">size_request()</a> actually calls the "size_request" method on the widget to compute the size request and fill in <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7cf31b1c61e01ec0a3cae36f41f3da4a">gtk_widget()</a>-&gt;requisition, and only then returns <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7cf31b1c61e01ec0a3cae36f41f3da4a">gtk_widget()</a>-&gt;requisition. Because this method does not call the "size_request" method, it can only be used when you know that <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7cf31b1c61e01ec0a3cae36f41f3da4a">gtk_widget()</a>-&gt;requisition is up-to-date, that is, <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9bbfcdf4796c1e194750837080343bdd">size_request()</a> has been called since the last time a resize was queued. In general, only container implementations have this information; applications should use <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9bbfcdf4796c1e194750837080343bdd">size_request()</a>. 
</div>
</div><p>
<a class="anchor" name="99abb30388c66d53434cec932f0ac86b"></a><!-- doxytag: member="Xfc::Gtk::Widget::is_focus" ref="99abb30388c66d53434cec932f0ac86b" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::is_focus           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if the widget is the focus widget within its toplevel. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the widget is the focus widget.</dd></dl>
This does not mean that the HAS_FOCUS flag is necessarily set; HAS_FOCUS will only be set if the toplevel widget additionally has the global input focus. 
</div>
</div><p>
<a class="anchor" name="67762edd0d99cd07c80b39ed6b1994f6"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_name" ref="67762edd0d99cd07c80b39ed6b1994f6" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Gtk::Widget::get_name           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the name of the widget (see set_name() for the significance of widget names). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The name of the widget. </dd></dl>

<p>
Reimplemented in <a class="el" href="classXfc_1_1Gtk_1_1AboutDialog.html#91217bb293425ae094be68e015727fcb">Xfc::Gtk::AboutDialog</a>.
</div>
</div><p>
<a class="anchor" name="c4c559af388602448a1878b70674d07a"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_child_visible" ref="c4c559af388602448a1878b70674d07a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::get_child_visible           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value set with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d0ec3fe0fd2f1ec6e206458d5d67ac37">set_child_visible()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the widget is mapped with the parent.</dd></dl>
If you feel a need to use this method, your code probably needs reorganization. This method is only useful for container implementations and never should be called by an application. 
</div>
</div><p>
<a class="anchor" name="1327f22a0393deafa7a6b2662dc9d580"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_size_request" ref="1327f22a0393deafa7a6b2662dc9d580" args="(int *width, int *height) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::get_size_request           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the size request that was explicitly set for the widget using <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#24e094379581001370a84c3e734b5086">set_size_request()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The return location for the width, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The return location for the height, or null.</td></tr>
  </table>
</dl>
A value of -1 stored in <em>width</em> or <em>height</em> indicates that that dimension has not been set explicitly and the natural requisition of the widget will be used intead. See <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#24e094379581001370a84c3e734b5086">set_size_request()</a>. To get the size a widget will actually use, call <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9bbfcdf4796c1e194750837080343bdd">size_request()</a> instead of this method. 
</div>
</div><p>
<a class="anchor" name="1d84b43225b3adf011d8f39203458690"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_toplevel" ref="1d84b43225b3adf011d8f39203458690" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a>* Xfc::Gtk::Widget::get_toplevel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the topmost widget in the container hierarchy the widget is a part of. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The topmost ancestor of widget, or widget itself if there's no ancestor.</dd></dl>
If widget has no parent widgets, it will be returned as the topmost widget. No reference will be added to the returned widget; it should not be unreferenced. Note the difference in behavior vs <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#258504c5914b92444076b4a13e968bb6">get_ancestor()</a>; get_ancestor(Gtk::TYPE_WINDOW) would return null if widget wasn't inside a toplevel window, and if the window was inside a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a>-derived widget which was in turn inside the toplevel <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a>. While the second case may seem unlikely, it actually happens when a <a class="el" href="classXfc_1_1Gtk_1_1Plug.html">Plug</a> is embedded inside a <a class="el" href="classXfc_1_1Gtk_1_1Socket.html">Socket</a> within the same application.<p>
To reliably find the toplevel <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a>, use <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1d84b43225b3adf011d8f39203458690">get_toplevel()</a> and check is_top_level() on the result. <div class="fragment"><pre class="fragment">&lt; Gtk::Widget *toplevel = widget-&gt;get_toplevel();
&lt; <span class="keywordflow">if</span> (<a class="code" href="classXfc_1_1Gtk_1_1Widget.html#11147be1ef41a8a50a121dfc82fb2930">is_toplevel</a>())
&lt; {
&lt;       <span class="comment">// Perform action on toplevel.</span>
&lt; }
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="258504c5914b92444076b4a13e968bb6"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_ancestor" ref="258504c5914b92444076b4a13e968bb6" args="(GType widget_type) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a>* Xfc::Gtk::Widget::get_ancestor           </td>
          <td>(</td>
          <td class="paramtype">GType&nbsp;</td>
          <td class="paramname"> <em>widget_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the first ancestor of widget with type widget_type. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>widget_type</em>&nbsp;</td><td>The ancestor type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The ancestor widget, or null if not found.</dd></dl>
For example, get_ancestor(GTK_TYPE_BOX) gets the first <a class="el" href="classXfc_1_1Gtk_1_1Box.html">Box</a> that's an ancestor of the widget. No reference will be added to the returned widget; it should not be unreferenced. See note about checking for a toplevel <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> in the docs for <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1d84b43225b3adf011d8f39203458690">get_toplevel()</a>. 
</div>
</div><p>
<a class="anchor" name="c2c87010818a72f1d04657da1b1bbe9f"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_colormap" ref="c2c87010818a72f1d04657da1b1bbe9f" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a>* Xfc::Gtk::Widget::get_colormap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the colormap that will be used to render the widget. 
<p>
No reference will be added to the returned colormap; it should not be unreferenced. 
</div>
</div><p>
<a class="anchor" name="b86a8b7121b747b1631845620f2ad4f9"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_screen" ref="b86a8b7121b747b1631845620f2ad4f9" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a>* Xfc::Gtk::Widget::get_screen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> from the toplevel window associated with this widget. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> for the toplevel for this widget.</dd></dl>
This function can only be called after the widget has been added to a widget hierarchy with a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> at the top. In general, you should only create screen specific resources when a widget has been realized, and you should free those resources when the widget is unrealized. 
<p>
Reimplemented in <a class="el" href="classXfc_1_1Gtk_1_1Invisible.html#e6768f51c7feec63a6cfb826db6d4c04">Xfc::Gtk::Invisible</a>, and <a class="el" href="classXfc_1_1Gtk_1_1Window.html#89fca906d29f72ab1dfe560aa469fd38">Xfc::Gtk::Window</a>.
</div>
</div><p>
<a class="anchor" name="ffd4ab3d6b155b0b27720cdaa9a7a7ee"></a><!-- doxytag: member="Xfc::Gtk::Widget::has_screen" ref="ffd4ab3d6b155b0b27720cdaa9a7a7ee" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::has_screen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether there is a <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> is associated with this widget. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if there is a <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> associcated with the widget.</dd></dl>
All toplevel widgets have an associated screen, as do all widgets added into a heirarchy with a toplevel window at the top. 
</div>
</div><p>
<a class="anchor" name="1e913a53641155f0ef9af4370feea24c"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_display" ref="1e913a53641155f0ef9af4370feea24c" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a>* Xfc::Gtk::Widget::get_display           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a> for the toplevel window associated with this widget. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a> for the toplevel for this widget.</dd></dl>
This method can only be called after the widget has been added to a widget hierarchy with a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> at the top. In general, you should only create display specific resources when a widget has been realized, and you should free those resources when the widget is unrealized. 
</div>
</div><p>
<a class="anchor" name="48742f7d3af2a1bab794cd221e944d1c"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_root_window" ref="48742f7d3af2a1bab794cd221e944d1c" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a>* Xfc::Gtk::Widget::get_root_window           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The root window is useful for such purposes as creating a popup <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> associated with the window. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> root window for the toplevel for this widget.</dd></dl>
In general, you should only create display specific resources when a widget has been realized, and you should free those resources when the widget is unrealized. 
</div>
</div><p>
<a class="anchor" name="e00c4701fb64c107746e56a83d838e17"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_settings" ref="e00c4701fb64c107746e56a83d838e17" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1Settings.html">Settings</a>* Xfc::Gtk::Widget::get_settings           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the settings object holding the settings (global property settings, <a class="el" href="classXfc_1_1Gtk_1_1RC.html">RC</a> file information, etc) used for this widget. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The relevant <a class="el" href="classXfc_1_1Gtk_1_1Settings.html">Settings</a> object.</dd></dl>
Note that this method can only be called when the <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> is attached to a toplevel, since the settings object is specific to a particular <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a>. 
</div>
</div><p>
<a class="anchor" name="a030c1e3cf5b7f275e20855e17b1c604"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_clipboard" ref="a030c1e3cf5b7f275e20855e17b1c604" args="(Gdk::Atom selection=GDK_SELECTION_CLIPBOARD) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Clipboard</a>* Xfc::Gtk::Widget::get_clipboard           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>selection</em> = <code>GDK_SELECTION_CLIPBOARD</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the clipboard object for the given selection to be used with widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection</em>&nbsp;</td><td>A <a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> which identifies the clipboard to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The appropriate clipboard object.</dd></dl>
The widget must have a <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a> associated with it, and so must be attached to a toplevel window. GDK_SELECTION_CLIPBOARD gives the default clipboard. Another common value is GDK_SELECTION_PRIMARY, which gives the primary X selection. If no clipboard already exists, a new one will be created. Once a clipboard object has been created, it is persistent for all time. All clipboard objects are owned by GTK+ and will be freed when GTK+ is removed from memory. 
</div>
</div><p>
<a class="anchor" name="c710ef642daf70c05686487e44ecd112"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_events" ref="c710ef642daf70c05686487e44ecd112" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">Gdk::EventMaskField</a> Xfc::Gtk::Widget::get_events           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the event mask for the widget (a bitfield containing flags from the <a class="el" href="namespaceXfc_1_1Gdk.html#f215b70aefcd2357d37bf457ce88c577">Gdk::EventMask</a> enumeration). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The event mask for the widget.</dd></dl>
These are the events that the widget will receive. 
</div>
</div><p>
<a class="anchor" name="a4887c401cd73c9f95837b413674d6d3"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_pointer" ref="a4887c401cd73c9f95837b413674d6d3" args="(int *x, int *y) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::get_pointer           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the location of the mouse pointer in widget coordinates. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The return location for the X coordinate, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The return location for the Y coordinate, or null.</td></tr>
  </table>
</dl>
<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> coordinates are a bit odd; for historical reasons, they are defined as <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> coordinates for widgets that are not <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c953af0c2deac47de6edbc4db12f2e1570">Gtk::NO_WINDOW</a> widgets, and are relative to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c26414506a65e78fd2e75b69517960f8">get_allocation()</a>.x and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c26414506a65e78fd2e75b69517960f8">get_allocation()</a>.y for widgets that are <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c953af0c2deac47de6edbc4db12f2e1570">Gtk::NO_WINDOW</a> widgets. 
</div>
</div><p>
<a class="anchor" name="d92b9b3392dfdf3deb90840719146231"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_pointer" ref="d92b9b3392dfdf3deb90840719146231" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Point.html">Gdk::Point</a> Xfc::Gtk::Widget::get_pointer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the location of the mouse pointer in widget coordinates. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The widget coordinates stored in a <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Gdk::Point</a>.</dd></dl>
<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> coordinates are a bit odd; for historical reasons, they are defined as <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> coordinates for widgets that are not <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c953af0c2deac47de6edbc4db12f2e1570">Gtk::NO_WINDOW</a> widgets, and are relative to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c26414506a65e78fd2e75b69517960f8">get_allocation()</a>.x and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c26414506a65e78fd2e75b69517960f8">get_allocation()</a>.y for widgets that are <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c953af0c2deac47de6edbc4db12f2e1570">Gtk::NO_WINDOW</a> widgets. 
</div>
</div><p>
<a class="anchor" name="32542915e8f8eb18c026cefc0b051910"></a><!-- doxytag: member="Xfc::Gtk::Widget::is_ancestor" ref="32542915e8f8eb18c026cefc0b051910" args="(Widget *ancestor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::is_ancestor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> *&nbsp;</td>
          <td class="paramname"> <em>ancestor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the widget is somewhere inside <em>ancestor</em>, possibly within an intermediate container. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ancestor</em>&nbsp;</td><td>Another <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if ancestor contains the widget as a child, grandchild, great grandchild, etc. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e9f937918a47aedfb9ebeee48eaf1c6"></a><!-- doxytag: member="Xfc::Gtk::Widget::rc_get_style" ref="7e9f937918a47aedfb9ebeee48eaf1c6" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a>* Xfc::Gtk::Widget::rc_get_style           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds all matching <a class="el" href="classXfc_1_1Gtk_1_1RC.html">RC</a> styles for a given widget, composites them together, and then creates a <a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> representing the composite appearance. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The resulting style. No refcount is added to the returned style, so if you want to keep this style around, you should add a reference yourself.</dd></dl>
GTK+ actually keeps a cache of previously created styles, so a new style may not be created. 
</div>
</div><p>
<a class="anchor" name="c471db10f64edd2236a69d57b8420bbd"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_modifier_style" ref="c471db10f64edd2236a69d57b8420bbd" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1RcStyle.html">RcStyle</a>* Xfc::Gtk::Widget::get_modifier_style           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current modifier style for the widget (as set by <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a>). 
<p>
If no style has previously set, a new <a class="el" href="classXfc_1_1Gtk_1_1RcStyle.html">RcStyle</a> will be created with all values unset, and set as the modifier style for the widget. If you make changes to this rc style, you must call <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a>, passing in the returned rc style, to make sure that your changes take effect.<p>
<b>Caution:</b> passing the style back to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a> will normally end up destroying it, because <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a> copies the passed-in style and sets the copy as the new modifier style, thus dropping any reference to the old modifier style. Add a reference to the modifier style if you want to keep it alive. 
</div>
</div><p>
<a class="anchor" name="5ef20cc10a065baf8d2ecd5a92d8bf4e"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_pango_context" ref="5ef20cc10a065baf8d2ecd5a92d8bf4e" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pango_1_1Context.html">Pango::Context</a>* Xfc::Gtk::Widget::get_pango_context           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a <a class="el" href="classXfc_1_1Pango_1_1Context.html">Pango::Context</a> with the appropriate colormap, font description and base direction for the widget. 
<p>
Unlike the context returned by <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#edade1fbad742313d285cede0135a174">create_pango_context()</a>, this context is owned by the widget (it can be used as long as widget exists), and will be updated to match any changes to the widget's attributes.<p>
If you create and keep a <a class="el" href="classXfc_1_1Pango_1_1Layout.html">Pango::Layout</a> using this context, you must deal with changes to the context by calling <a class="el" href="classXfc_1_1Pango_1_1Layout.html#c1410ab29d67ab2903e2cdf6ab7d8ddd">Pango::Layout::context_changed()</a> on the layout in response to the <em>style_set</em> and <em>direction_set</em> signals for the widget. 
</div>
</div><p>
<a class="anchor" name="42fde289bb0c47a910adfd298fcc453e"></a><!-- doxytag: member="Xfc::Gtk::Widget::style_get_property" ref="42fde289bb0c47a910adfd298fcc453e" args="(const String &amp;property_name, G::Value &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::style_get_property           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Value.html">G::Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of a style property of the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property_name</em>&nbsp;</td><td>The name of a style property. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The location to return the property value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e5c395a1d0e149ef2f983fa1b04cfdb"></a><!-- doxytag: member="Xfc::Gtk::Widget::path" ref="0e5c395a1d0e149ef2f983fa1b04cfdb" args="(String &amp;path, String &amp;path_reversed) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::path           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path_reversed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the full path to the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The location to store the path string, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path_reversed</em>&nbsp;</td><td>The location to store path string, or null.</td></tr>
  </table>
</dl>
The path is simply the name of a widget and all its parents in the container hierarchy, separated by periods. The name of a widget comes from <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#67762edd0d99cd07c80b39ed6b1994f6">get_name()</a>. Paths are used to apply styles to a widget in gtkrc configuration files. <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> names are the type of the widget by default (e.g. "Button") or can be set to an application-specific value with set_name(). By setting the name of a widget, you allow users or theme authors to apply styles to that specific widget in their gtkrc file. <em>path_reversed</em> fills in the path in reverse order, i.e. starting with widget's name instead of starting with the name of widget's outermost ancestor. 
</div>
</div><p>
<a class="anchor" name="492a91e2a9e786edf7a279719dd0a67d"></a><!-- doxytag: member="Xfc::Gtk::Widget::class_path" ref="492a91e2a9e786edf7a279719dd0a67d" args="(String &amp;path, String &amp;path_reversed) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::class_path           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path_reversed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0e5c395a1d0e149ef2f983fa1b04cfdb">path()</a>, but always uses the name of a widget's type, never uses a custom name set with set_name(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The location to store the path string, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path_reversed</em>&nbsp;</td><td>The location to store path string, or null. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c5ba7b2ea0919ec9adf43c1b6b2bdeca"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_default_style" ref="c5ba7b2ea0919ec9adf43c1b6b2bdeca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a>* Xfc::Gtk::Widget::get_default_style           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the default style used by all widgets initially. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The default style. This <a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> object is owned by GTK+ and should not be modified or unreferenced. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e04e6fdaee0045d1ebc0fb966c4676e"></a><!-- doxytag: member="Xfc::Gtk::Widget::get_default_visual" ref="9e04e6fdaee0045d1ebc0fb966c4676e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classXfc_1_1Gdk_1_1Visual.html">Gdk::Visual</a>* Xfc::Gtk::Widget::get_default_visual           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the visual of the default colormap. 
<p>
Not really useful; used to be useful before <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html#a1923fad93d81f90daa26ac6d2b72f6f">Gdk::Colormap::get_visual()</a> existed. 
</div>
</div><p>
<a class="anchor" name="505215cea2d040497ac37144da41b49a"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_flags" ref="505215cea2d040497ac37144da41b49a" args="(WidgetFlagsField flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_flags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#40b56ef2f8bfaadfd3ab79e49adc69a7">WidgetFlagsField</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Turns on certain widget flags. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c9">Gtk::WidgetFlags</a> to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="adfcc2d331d40e353363eaa8e11890b5"></a><!-- doxytag: member="Xfc::Gtk::Widget::unset_flags" ref="adfcc2d331d40e353363eaa8e11890b5" args="(WidgetFlagsField flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::unset_flags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#40b56ef2f8bfaadfd3ab79e49adc69a7">WidgetFlagsField</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Turns off certain widget flags. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c9">Gtk::WidgetFlags</a> to unset. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="89dc83a4d424c700b9dc9430d18c9fc0"></a><!-- doxytag: member="Xfc::Gtk::Widget::show" ref="89dc83a4d424c700b9dc9430d18c9fc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::show           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flags a widget to be displayed. 
<p>
Any widget that isn't shown will not appear on the screen. If you want to show all the widgets in a container, it's easier to call widget_show_all() on the container, instead of individually showing the widgets.<p>
Remember that you have to show the container containing a widget, in addition to the widget itself, before it will appear onscreen. When a toplevel container is shown, it is immediately realized and mapped; other shown widgets are realized and mapped when their toplevel container is realized and mapped. 
</div>
</div><p>
<a class="anchor" name="440c456397ad449d54f107a92abc7877"></a><!-- doxytag: member="Xfc::Gtk::Widget::show" ref="440c456397ad449d54f107a92abc7877" args="(bool visible)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::show           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>visible</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method that combines the functionality of <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#89dc83a4d424c700b9dc9430d18c9fc0">show()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#18467883235d80a8b6f4b7c61ddbd4a9">hide()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>visible</em>&nbsp;</td><td>Set <em>true</em> to show the widget, or <em>false</em> to hide it.</td></tr>
  </table>
</dl>
This method is useful when you want to use another boolean value to toggle the visibility of this widget. 
</div>
</div><p>
<a class="anchor" name="51eae4b5ef109b6ef59bab07aa602a05"></a><!-- doxytag: member="Xfc::Gtk::Widget::show_now" ref="51eae4b5ef109b6ef59bab07aa602a05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::show_now           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shows a widget. 
<p>
If the widget is an unmapped toplevel widget (i.e. a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> that has not yet been shown), enter the main loop and wait for the window to actually be mapped. Be careful; because the main loop is running, anything can happen during this method. 
</div>
</div><p>
<a class="anchor" name="a57d7955d439269bc8bf3b7c92502191"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_no_show_all" ref="a57d7955d439269bc8bf3b7c92502191" args="(bool no_show_all)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_no_show_all           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>no_show_all</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the "no_show_all" property, which determines whether calls to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8899912c1b7fbc45f079eb881378855e">show_all()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5aa49027f31a9e81c744a85dbb447230">hide_all()</a> will affect this widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>no_show_all</em>&nbsp;</td><td>The new value for the "no_show_all" property.</td></tr>
  </table>
</dl>
This is mostly for use in constructing widget hierarchies with externally controlled visibility, see <a class="el" href="classXfc_1_1Gtk_1_1UIManager.html">Gtk::UIManager</a>. 
</div>
</div><p>
<a class="anchor" name="80b4fca2f9eaed298515065692fcdcf8"></a><!-- doxytag: member="Xfc::Gtk::Widget::realize" ref="80b4fca2f9eaed298515065692fcdcf8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::realize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates the GDK (windowing system) resources associated with a widget. 
<p>
For example, a widget's GDK window will be created when a widget is realized. Normally realization happens implicitly; if you show a widget and all its parent containers, then the widget will be realized and mapped automatically. Realizing a widget requires all the widget's parent widgets to be realized. Calling <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#80b4fca2f9eaed298515065692fcdcf8">realize()</a> realizes the widget's parents in addition to widget itself. If a widget is not yet inside a toplevel window when you realize it, bad things will happen.<p>
This method is primarily used in widget implementations, and isn't very useful otherwise. Many times when you think you might need it, a better approach is to connect to a signal that will be called after the widget is realized automatically, such as <em>expose_event</em> signal. Or simply connect to the <em>realize</em> signal specifying <em>after</em> as true in the signal's connect method. 
</div>
</div><p>
<a class="anchor" name="8cab7a57649c6a60cc0167bc4e87f13f"></a><!-- doxytag: member="Xfc::Gtk::Widget::queue_draw_area" ref="8cab7a57649c6a60cc0167bc4e87f13f" args="(int x, int y, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::queue_draw_area           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates the rectangular area of the widget defined by x, y, width and height by calling Gdk::Window::invalidate_rect() on the widget's window and all its child windows. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X coordinate of upper-left corner of rectangle to redraw. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y coordinate of upper-left corner of rectangle to redraw </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of region to draw. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of region to draw.</td></tr>
  </table>
</dl>
Once the main loop becomes idle (after the current batch of events has been processed, roughly), the window will receive expose events for the union of all regions that have been invalidated.<p>
Normally you would only use this method in widget implementations. You might also use it, or Gdk::Window::invalidate_rect() directly, to schedule a redraw of a <a class="el" href="classXfc_1_1Gtk_1_1DrawingArea.html">DrawingArea</a> or some portion thereof. Frequently you can just call Gdk::Window::invalidate_rect() or Gdk::Window::invalidate_region() instead of this method. Those methods will invalidate only a single window, instead of the widget and all its children.<p>
The advantage of adding to the invalidated region compared to simply drawing immediately is efficiency; using an invalid region ensures that you only have to redraw one time. 
</div>
</div><p>
<a class="anchor" name="ed13e8ec0f724aca97aca22607236d30"></a><!-- doxytag: member="Xfc::Gtk::Widget::queue_draw_area" ref="ed13e8ec0f724aca97aca22607236d30" args="(const Gdk::Rectangle &amp;rectangle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::queue_draw_area           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Gdk::Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rectangle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates the rectangular area of the widget defined by rectangle by calling Gdk::Window::invalidate_rect() on the widget's window and all its child windows. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rectangle</em>&nbsp;</td><td>A rectangle that specifies the area of the widget to invalidate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="214c3751972dc9a038ae3ec43cc4e2a7"></a><!-- doxytag: member="Xfc::Gtk::Widget::queue_resize" ref="214c3751972dc9a038ae3ec43cc4e2a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::queue_resize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is only for use in widget implementations. 
<p>
Flags a widget to have its size renegotiated; should be called when a widget for some reason has a new size request. For example, when you change the text in a <a class="el" href="classXfc_1_1Gtk_1_1Label.html">Label</a>, <a class="el" href="classXfc_1_1Gtk_1_1Label.html">Label</a> queues a resize to ensure there's enough space for the new text. 
</div>
</div><p>
<a class="anchor" name="9bbfcdf4796c1e194750837080343bdd"></a><!-- doxytag: member="Xfc::Gtk::Widget::size_request" ref="9bbfcdf4796c1e194750837080343bdd" args="(Requisition *requisition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::size_request           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Requisition.html">Requisition</a> *&nbsp;</td>
          <td class="paramname"> <em>requisition</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Typically used when implementing a <a class="el" href="classXfc_1_1Gtk_1_1Container.html">Container</a> subclass; obtains the preferred size of the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>requisition</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1Requisition.html">Requisition</a> to be filled in.</td></tr>
  </table>
</dl>
The container uses this information to arrange its child widgets and decide what size allocations to give them with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#90c6becce9ed59bff1e14476ec2c3c29">size_allocate()</a>.<p>
You can also call this function from an application, with some caveats. Most notably, getting a size request requires the widget to be associated with a screen, because font information may be needed. Multihead-aware applications should keep this in mind. Also remember that the size request is not necessarily the size a widget will actually be allocated. See also <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7948898892ec0a131dab68118f90f594">get_child_requisition()</a>. 
</div>
</div><p>
<a class="anchor" name="90c6becce9ed59bff1e14476ec2c3c29"></a><!-- doxytag: member="Xfc::Gtk::Widget::size_allocate" ref="90c6becce9ed59bff1e14476ec2c3c29" args="(const Allocation &amp;allocation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::size_allocate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1Allocation.html">Allocation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is only used by <a class="el" href="classXfc_1_1Gtk_1_1Container.html">Container</a> subclasses to assign a size and position to their child widgets. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>allocation</em>&nbsp;</td><td>The position and size to be allocated to the widget. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7d325be1f004b99a594d89318ce7614a"></a><!-- doxytag: member="Xfc::Gtk::Widget::add_accelerator" ref="7d325be1f004b99a594d89318ce7614a" args="(const String &amp;accel_signal, AccelGroup &amp;accel_group, const AccelKey &amp;accel_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::add_accelerator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>accel_signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>accel_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1AccelKey.html">AccelKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>accel_key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Installs an accelerator for this widget in accel_group that causes accel_signal to be emitted if the accelerator is activated. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>accel_signal</em>&nbsp;</td><td>The widget signal to emit on accelerator activation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>accel_group</em>&nbsp;</td><td>The accelerator group for this widget, added to its toplevel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>accel_key</em>&nbsp;</td><td>An <a class="el" href="classXfc_1_1Gtk_1_1AccelKey.html">AccelKey</a> that holds the accelerator key, modifier and flag values.</td></tr>
  </table>
</dl>
The accel_group needs to be added to the widget's toplevel via <a class="el" href="classXfc_1_1Gtk_1_1Window.html#2e9d3b1accd9df9ab34de6750cd782e2">Gtk::Window::add_accel_group()</a>, and the signal must be of type G_RUN_ACTION. Accelerators added through this function are not user changeable during runtime. If you want to support accelerators that can be changed by the user, use Gtk::AccelMap::add_entry() and set_accel_path() or Gtk::MenuItem::set_accel_path() instead. 
</div>
</div><p>
<a class="anchor" name="3e80b7483645111139e04a21ccc7237f"></a><!-- doxytag: member="Xfc::Gtk::Widget::remove_accelerator" ref="3e80b7483645111139e04a21ccc7237f" args="(AccelGroup &amp;accel_group, const AccelKey &amp;accel_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::remove_accelerator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>accel_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1AccelKey.html">AccelKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>accel_key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an accelerator from the widget previously installed with add_accelerator(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>accel_group</em>&nbsp;</td><td>The accel group for this widget. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>accel_key</em>&nbsp;</td><td>An <a class="el" href="classXfc_1_1Gtk_1_1AccelKey.html">AccelKey</a> that holds the accelerator key, modifier and flag values. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether an accelerator was installed and could be removed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b5fd017a082c839cdd463e3a850ae6b"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_accel_path" ref="1b5fd017a082c839cdd463e3a850ae6b" args="(const String &amp;accel_path, AccelGroup &amp;accel_group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_accel_path           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>accel_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>accel_group</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an accelerator group <em>accel_group</em> and an accelerator path <em>accel_path</em>, sets up an accelerator in accel_group so whenever the key binding that is defined for accel_path is pressed, the widget will be activated. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>accel_path</em>&nbsp;</td><td>The path used to look up the the accelerator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>accel_group</em>&nbsp;</td><td>The accelerator group.</td></tr>
  </table>
</dl>
This removes any accelerators (for any accelerator group) installed by previous calls to set_accel_path(). Associating accelerators with paths allows them to be modified by the user and the modifications to be saved for future use. (See Gtk::AccelMap_save().)<p>
This method is a low level function that would most likely be used by a menu creation system like ItemFactory. If you use ItemFactory, setting up accelerator paths will be done automatically. Even when you you aren't using ItemFactory, if you only want to set up accelerators on menu items Gtk::MenuItem::set_accel_path() provides a somewhat more convenient interface. 
</div>
</div><p>
<a class="anchor" name="fe049ce2c9c66f5afb72442f22dd8b64"></a><!-- doxytag: member="Xfc::Gtk::Widget::list_accel_closures" ref="fe049ce2c9c66f5afb72442f22dd8b64" args="(std::vector&lt; GClosure * &gt; &amp;closures)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::list_accel_closures           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; GClosure * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>closures</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lists the closures used by the widget for accelerator group connections with <a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html#7538e051c3f9eba5b10d338a8edfaa98">Gtk::AccelGroup::connect()</a>. 
<p>
/* T <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>closures</em>&nbsp;</td><td>A reference to a vector of GClosure* to hold the list of closures. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the vector is not empty.</dd></dl>
The closures can be used to monitor accelerator changes on the widget, by connecting to the <em>accel_changed</em> signal of the <a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> of a closure, which can be found out with <a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html#2ce8521b7823cb641627709fb43fb65f">Gtk::AccelGroup::from_accel_closure()</a>. 
</div>
</div><p>
<a class="anchor" name="f5ff065ba932f27fd1ccdd3d5f8bc792"></a><!-- doxytag: member="Xfc::Gtk::Widget::can_activate_accel" ref="f5ff065ba932f27fd1ccdd3d5f8bc792" args="(unsigned int signal_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::can_activate_accel           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>signal_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether an accelerator that activates the signal identified by <em>signal_id</em> can currently be activated. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signal_id</em>&nbsp;</td><td>The id of a signal installed on the widget. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the accelerator can be activated.</dd></dl>
The determination is made by emitting the <em>can_activate_accel</em> signal on the widget. If the signal isn't overridden by a handler or in a derived widget, then the default check is that the widget must be sensitive, and the widget and all its parents mapped. 
</div>
</div><p>
<a class="anchor" name="40d627ac232137df963a6228a9a57448"></a><!-- doxytag: member="Xfc::Gtk::Widget::can_activate_accel" ref="40d627ac232137df963a6228a9a57448" args="(const String &amp;signal_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::can_activate_accel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>signal_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether an accelerator that activates the signal identified by <em>signal_name</em> can currently be activated (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f5ff065ba932f27fd1ccdd3d5f8bc792">can_activate_accel(unsigned int)</a>). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signal_name</em>&nbsp;</td><td>The name of a signal installed on the widget. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the accelerator can be activated. </dd></dl>

</div>
</div><p>
<a class="anchor" name="55fd745ba651d627fdfb2af4fa203106"></a><!-- doxytag: member="Xfc::Gtk::Widget::send_expose" ref="55fd745ba651d627fdfb2af4fa203106" args="(const Gdk::EventExpose &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Gtk::Widget::send_expose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1EventExpose.html">Gdk::EventExpose</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This rarely-used method is used to emit an <em>expose_event</em> signal on the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>A Gdk::GdkEventExpose. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The return from the event signal emission (true if the event was handled).</dd></dl>
This method is not normally used directly. The only time it is used is when propagating an expose event to a child NO_WINDOW widget, and that is normally done using <a class="el" href="classXfc_1_1Gtk_1_1Container.html#e53a73acaff06abee1c0d6b2c522ee3a">Gtk::Container::propagate_expose()</a>.<p>
If you want to force an area of a window to be redrawn, use Gdk::Window::invalidate_rect() or Gdk::Window::invalidate_region(). To cause the redraw to be done immediately, follow that call with a call to <a class="el" href="classXfc_1_1Gdk_1_1Window.html#5250420ef05e8ed00cee17450263a6b4">Gdk::Window::process_updates()</a>. 
</div>
</div><p>
<a class="anchor" name="1f256d2aec87fb438488f4f733ad4f81"></a><!-- doxytag: member="Xfc::Gtk::Widget::mnemonic_activate" ref="1f256d2aec87fb438488f4f733ad4f81" args="(bool group_cycling)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::mnemonic_activate           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>group_cycling</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Actviates the widget if it's suitable for mnemonic actviaton. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>group_cycling</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the widget was activated. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e6c4c09b41c3c29e2f3e2e130765ff0e"></a><!-- doxytag: member="Xfc::Gtk::Widget::event" ref="e6c4c09b41c3c29e2f3e2e130765ff0e" args="(const Gdk::Event &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::event           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Event.html">Gdk::Event</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This rarely-used method is used to emit the event signals on a widget (those signals should never be emitted without using this method to do so). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Event.html">Gdk::Event</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The return from the event signal emission (true if the event was handled).</dd></dl>
If you want to synthesize an event though, don't use this function; instead, use gtk_main_do_event() so the event will behave as if it were in the event queue. Don't synthesize expose events; instead, use Gdk::Window::invalidate_rect() to invalidate a region of the window. 
</div>
</div><p>
<a class="anchor" name="581be0ca571efe2cebb17f3a261bfce1"></a><!-- doxytag: member="Xfc::Gtk::Widget::activate" ref="581be0ca571efe2cebb17f3a261bfce1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::activate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For widgets that can be activated (buttons, menu items, etc) this method activates them. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the widget was activatable.</dd></dl>
Activation is what happens when you press <em>Enter</em> on a widget during key navigation; clicking a button, selecting a menu item, etc. If the widget isn't activatable, this method returns false. 
<p>
Reimplemented in <a class="el" href="classXfc_1_1Gtk_1_1MenuItem.html#df65cb6ecd71ea62d9bd6bd3ece99f12">Xfc::Gtk::MenuItem</a>.
</div>
</div><p>
<a class="anchor" name="07b6646fb2340acfd681247397e92cda"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_scroll_adjustments" ref="07b6646fb2340acfd681247397e92cda" args="(Adjustment *hadjustment, Adjustment *vadjustment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::set_scroll_adjustments           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Adjustment.html">Adjustment</a> *&nbsp;</td>
          <td class="paramname"> <em>hadjustment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Adjustment.html">Adjustment</a> *&nbsp;</td>
          <td class="paramname"> <em>vadjustment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the widget's scroll adjustments. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hadjustment</em>&nbsp;</td><td>An adjustment for horizontal scrolling, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vadjustment</em>&nbsp;</td><td>An adjustment for vertical scrolling, or null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the widget supports scrolling.</dd></dl>
For widgets that support scrolling, sets the scroll adjustments and returns true. For widgets that don't support scrolling, does nothing and returns false. Widgets that don't support scrolling can be scrolled by placing them in a <a class="el" href="classXfc_1_1Gtk_1_1Viewport.html">Viewport</a>, which does support scrolling. 
</div>
</div><p>
<a class="anchor" name="875a1ae46089f8732e53fa5e41d33335"></a><!-- doxytag: member="Xfc::Gtk::Widget::reparent" ref="875a1ae46089f8732e53fa5e41d33335" args="(Widget &amp;new_parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::reparent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>new_parent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves a widget from one <a class="el" href="classXfc_1_1Gtk_1_1Container.html">Container</a> to another, handling reference count issues to avoid destroying the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_parent</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1Container.html">Container</a> to move the widget into. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="69ab4f48efd95cf3bb3e4cc7eb6dddb0"></a><!-- doxytag: member="Xfc::Gtk::Widget::intersect" ref="69ab4f48efd95cf3bb3e4cc7eb6dddb0" args="(const Gdk::Rectangle &amp;area, Gdk::Rectangle *intersection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::intersect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Gdk::Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Gdk::Rectangle</a> *&nbsp;</td>
          <td class="paramname"> <em>intersection</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the intersection of a widget's area and <em>area</em>, storing the intersection in <em>intersection</em>, and returns true if there was an intersection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>area</em>&nbsp;</td><td>A rectangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>intersection</em>&nbsp;</td><td>The rectangle to store intersection of the widget and <em>area</em>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if there was an intersection.</dd></dl>
The intersection may be null if you're only interested in whether there was an intersection. 
</div>
</div><p>
<a class="anchor" name="7c8984a9798d5e2c4ed61de7b23b857c"></a><!-- doxytag: member="Xfc::Gtk::Widget::intersect" ref="7c8984a9798d5e2c4ed61de7b23b857c" args="(const Gdk::Rectangle &amp;area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Gdk::Rectangle</a> Xfc::Gtk::Widget::intersect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Rectangle.html">Gdk::Rectangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>area</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the intersection of a widget's area and <em>area</em>, and returns the intersection as a rectanlge. 
<p>
that stores . <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>area</em>&nbsp;</td><td>A rectangle. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A rectangle storing the intersection if there was an intersection.</dd></dl>
The returned rectangle will be empty if there was no intersection. 
</div>
</div><p>
<a class="anchor" name="3d0e03a63ec097b192f7e2d10987de83"></a><!-- doxytag: member="Xfc::Gtk::Widget::intersect" ref="3d0e03a63ec097b192f7e2d10987de83" args="(Gdk::Region &amp;region)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Region.html">Gdk::Region</a>&gt; Xfc::Gtk::Widget::intersect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Region.html">Gdk::Region</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the intersection of a widget's area and <em>region</em>, and returns the intersection as a new <a class="el" href="classXfc_1_1Gdk_1_1Region.html">Gdk::Region</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>a <a class="el" href="classXfc_1_1Gdk_1_1Region.html">Gdk::Region</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to a new <a class="el" href="classXfc_1_1Gdk_1_1Region.html">Gdk::Region</a> holding the intersection of the widget and <em>region</em>.</dd></dl>
<em>region</em> must be in the same coordinate system as the widget's allocation. That is, relative to the widget's GDK window for NO_WINDOW widgets; relative to the parent window of widget's GDK window for widgets with their own window. The coordinates returned are relative to the widget's GDK window for NO_WINDOW widgets, and relative to the parent window of widget's GDK window for widgets with their own window. The returned region may be empty, use <a class="el" href="classXfc_1_1Gdk_1_1Region.html#ecc363e7bd8ec8fa840580e8721cba56">Gdk::Region::empty()</a> to check. 
</div>
</div><p>
<a class="anchor" name="b352485cdf0b239d7371b8a9c6d6f7db"></a><!-- doxytag: member="Xfc::Gtk::Widget::freeze_child_notify" ref="b352485cdf0b239d7371b8a9c6d6f7db" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::freeze_child_notify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stops the emission of <em>child_notify</em> signals on the widget. 
<p>
The signals are queued until <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4c9a57588e3b31f44e8c82da637357fe">thaw_child_notify()</a> is called on the widget. 
</div>
</div><p>
<a class="anchor" name="807a7c6bf3e2a48cb009d91f10546a9e"></a><!-- doxytag: member="Xfc::Gtk::Widget::child_notify" ref="807a7c6bf3e2a48cb009d91f10546a9e" args="(const String &amp;child_property)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::child_notify           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>child_property</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emits a <em>child_notify</em> signal for the child property <em>child_property</em> on the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>child_property</em>&nbsp;</td><td>The name of a child property installed on the class of widget's parent. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4c9a57588e3b31f44e8c82da637357fe"></a><!-- doxytag: member="Xfc::Gtk::Widget::thaw_child_notify" ref="4c9a57588e3b31f44e8c82da637357fe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::thaw_child_notify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reverts the effect of a prevoious call to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b352485cdf0b239d7371b8a9c6d6f7db">freeze_child_notify()</a>. 
<p>
This causes all queued <em>child_notify</em> signals on widget to be emitted. 
</div>
</div><p>
<a class="anchor" name="2faac78256ebb7930dc1d0812f77f19f"></a><!-- doxytag: member="Xfc::Gtk::Widget::grab_focus" ref="2faac78256ebb7930dc1d0812f77f19f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::grab_focus           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Causes the widget to have the keyboard focus for the <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> it's inside. 
<p>
The widget must be a focusable widget, such as an <a class="el" href="classXfc_1_1Gtk_1_1Entry.html">Entry</a>; something like <a class="el" href="classXfc_1_1Gtk_1_1Frame.html">Frame</a> won't work. More precisely, it must have the <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c9f3c481a633714b8d78db9d3b793972a2">Gtk::CAN_FOCUS</a> flag set. 
</div>
</div><p>
<a class="anchor" name="1c1296110f2cd529d06294e54fbaf0c6"></a><!-- doxytag: member="Xfc::Gtk::Widget::grab_default" ref="1c1296110f2cd529d06294e54fbaf0c6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::grab_default           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Causes the widget to become the default widget. 
<p>
The widget must have the <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c9939b4a16fe3ef463f2a5045a29744bce">Gtk::CAN_DEFAULT</a> flag set; typically you have to set this flag yourself by calling set_flags(Gtk::CAN_DEFAULT). The default widget is activated when the user presses <em>Enter</em> in a window. Default widgets must be activatable, that is, <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#581be0ca571efe2cebb17f3a261bfce1">activate()</a> should affect them. 
</div>
</div><p>
<a class="anchor" name="0c65ad766fe498f5ad1b6c3fbc8600d2"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_name" ref="0c65ad766fe498f5ad1b6c3fbc8600d2" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Widgets can be named, which allows you to refer to them in a gtkrc file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name for the widget.</td></tr>
  </table>
</dl>
You can apply a style to widgets with a particular name in the gtkrc file. See the GTK+ documentation for gtkrc files (on the same page as the docs for GtkRcStyle). 
<p>
Reimplemented in <a class="el" href="classXfc_1_1Gtk_1_1AboutDialog.html#5fe61a74cfc48aa10676869023facb3d">Xfc::Gtk::AboutDialog</a>.
</div>
</div><p>
<a class="anchor" name="4e4acd0b89b63bf7929db752e76ec433"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_state" ref="4e4acd0b89b63bf7929db752e76ec433" args="(StateType state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_state           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used in widget implementations; sets the state of the widget (insensitive, prelighted, etc). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The new state for the widget.</td></tr>
  </table>
</dl>
Usually you should set the state using wrapper functions such as <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5d4c47ee11b05fc5e79a21fc70ed3c5e">set_sensitive()</a>. 
</div>
</div><p>
<a class="anchor" name="5d4c47ee11b05fc5e79a21fc70ed3c5e"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_sensitive" ref="5d4c47ee11b05fc5e79a21fc70ed3c5e" args="(bool sensitive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_sensitive           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sensitive</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the sensitivity of the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sensitive</em>&nbsp;</td><td><em>true</em> to make the widget sensitive.</td></tr>
  </table>
</dl>
A widget is sensitive if the user can interact with it. Insensitive widgets are <em>grayed out</em> and the user can't interact with them. Insensitive widgets are known as <em>inactive, disabled, or ghosted</em> in some other toolkits. 
</div>
</div><p>
<a class="anchor" name="ad586e62735f47e717a6ffa4405da6a6"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_app_paintable" ref="ad586e62735f47e717a6ffa4405da6a6" args="(bool app_paintable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_app_paintable           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>app_paintable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c9ba4cadd7f5a6a678609f0405f5e6d38c">Gtk::APP_PAINTABLE</a> flags on the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>app_paintable</em>&nbsp;</td><td><em>true</em> if <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c9ba4cadd7f5a6a678609f0405f5e6d38c">Gtk::APP_PAINTABLE</a> should be set.</td></tr>
  </table>
</dl>
Must be set on widgets whose window the application directly draws on, in order to keep GTK+ from overwriting the drawn stuff. 
</div>
</div><p>
<a class="anchor" name="46da3ae55128596cbd64744859fd35a5"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_double_buffered" ref="46da3ae55128596cbd64744859fd35a5" args="(bool double_buffered)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_double_buffered           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>double_buffered</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Widgets are double buffered by default; you can use this function to turn off the buffering. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>double_buffered</em>&nbsp;</td><td><em>true</em> to double-buffer a widget.</td></tr>
  </table>
</dl>
<em>Double buffered</em> simply means that <a class="el" href="classXfc_1_1Gdk_1_1Window.html#2de04b3845df711ee41d5a8de7b7b951">Gdk::Window::begin_paint()</a> and <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0d2820164c0fdcc29ba8e95625f74bc0">Gdk::Window::end_paint()</a> are called automatically around expose events sent to the widget. <a class="el" href="classXfc_1_1Gdk_1_1Window.html#2de04b3845df711ee41d5a8de7b7b951">Gdk::Window::begin_paint()</a> diverts all drawing to a widget's window to an offscreen buffer, and <a class="el" href="classXfc_1_1Gdk_1_1Window.html#0d2820164c0fdcc29ba8e95625f74bc0">Gdk::Window::end_paint()</a> draws the buffer to the screen. The result is that users see the window update in one smooth step, and don't see individual graphics primitives being rendered. In very simple terms, double buffered widgets don't flicker, so you would only use this function to turn off double buffering if you had special needs and really knew what you were doing. 
</div>
</div><p>
<a class="anchor" name="a9a3ab10ce909a7bf1cb480d83a575f6"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_redraw_on_allocate" ref="a9a3ab10ce909a7bf1cb480d83a575f6" args="(bool redraw_on_allocate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_redraw_on_allocate           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>redraw_on_allocate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When a widgets size allocation changes, sets whether the entire widget is queued for drawing or not. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>redraw_on_allocate</em>&nbsp;</td><td>Set <em>true</em> to redraw the entire widget when it's resized, and <em>false</em> to only redraw the new portion of the widget</td></tr>
  </table>
</dl>
By default, this setting is true and the entire widget is redrawn on every size change. If your widget leaves the upper left unchanged when made bigger, turning this setting on will improve performance. Note that for NO_WINDOW widgets setting this flag to false turns off all allocation on resizing: the widget will not even redraw if its position changes; this is to allow containers that don't draw anything to avoid excess invalidations. If you set this flag on a NO_WINDOW widget that does draw on the widget's GDK window, you are responsible for invalidating both the old and new allocation of the widget when the widget is moved and responsible for invalidating regions newly when the widget increases size. 
</div>
</div><p>
<a class="anchor" name="dbd679ef62d4f8b9634229a7da6c9da1"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_parent" ref="dbd679ef62d4f8b9634229a7da6c9da1" args="(Widget &amp;parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_parent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the container as the parent of widget, and takes care of some details such as updating the state and style of the child to reflect its new location. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>The parent container.</td></tr>
  </table>
</dl>
This method is useful only when implementing subclasses of <a class="el" href="classXfc_1_1Gtk_1_1Container.html">Container</a>. The opposite method is <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5382ddf601e00a2c0a89a88687e6113d">unparent()</a>. 
</div>
</div><p>
<a class="anchor" name="c9b5bd324796a58fbecaa070abe167ca"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_parent_window" ref="c9b5bd324796a58fbecaa070abe167ca" args="(Gdk::Window *parent_window)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_parent_window           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> *&nbsp;</td>
          <td class="paramname"> <em>parent_window</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a non default parent window for widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent_window</em>&nbsp;</td><td>The new parent window. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d0ec3fe0fd2f1ec6e206458d5d67ac37"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_child_visible" ref="d0ec3fe0fd2f1ec6e206458d5d67ac37" args="(bool is_visible)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_child_visible           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_visible</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether the widget should be mapped along with its parent when its parent is mapped and the widget has been shown with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#89dc83a4d424c700b9dc9430d18c9fc0">show()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_visible</em>&nbsp;</td><td>If <em>true</em>, the widget should be mapped along with its parent.</td></tr>
  </table>
</dl>
The child visibility can be set for a widget before it is added to a container with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dbd679ef62d4f8b9634229a7da6c9da1">set_parent()</a>, to avoid mapping children unnecessary before immediately unmapping them. However it will be reset to its default state of true when the widget is removed from a container.<p>
Note that changing the child visibility of a widget does not queue a resize on the widget. Most of the time, the size of a widget is computed from all visible children, whether or not they are mapped. If this is not the case, the container can queue a resize itself. This method is only useful for container implementations and never should be called by an application. 
</div>
</div><p>
<a class="anchor" name="86f0ae26c49ed54845b4d6ea52ac4bad"></a><!-- doxytag: member="Xfc::Gtk::Widget::child_focus" ref="86f0ae26c49ed54845b4d6ea52ac4bad" args="(DirectionType direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::child_focus           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#cb399182c672579f9bce45564fabd10f">DirectionType</a>&nbsp;</td>
          <td class="paramname"> <em>direction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the focus to the child widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>The direction of focus movement. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the focus ended up inside the widget.</dd></dl>
This method is used by custom widget implementations; if you're writing an application, you'd use <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2faac78256ebb7930dc1d0812f77f19f">grab_focus()</a> to move the focus to a particular widget, and <a class="el" href="classXfc_1_1Gtk_1_1Container.html#9e812981f2636c67ca7a6a99bcee0b5c">Gtk::Container::set_focus_chain()</a> to change the focus tab order. So you may want to investigate those methods instead.<p>
<em><a class="el" href="classXfc_1_1Gtk_1_1Widget.html#86f0ae26c49ed54845b4d6ea52ac4bad">child_focus()</a></em> is called by containers as the user moves around the window using keyboard shortcuts. <em>direction</em> indicates what kind of motion is taking place (up, down, left, right, tab forward, tab backward). <em><a class="el" href="classXfc_1_1Gtk_1_1Widget.html#86f0ae26c49ed54845b4d6ea52ac4bad">child_focus()</a></em> invokes the "focus" signal on the <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a>; widgets override the default handler for this signal in order to implement appropriate focus behavior. The "focus" default handler for a widget should return true if moving in <em>direction</em> left the focus on a focusable location inside that widget, and false if moving in <em>direction</em> moved the focus outside the widget. If returning true, widgets normally call <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2faac78256ebb7930dc1d0812f77f19f">grab_focus()</a> to place the focus accordingly; if returning false, they don't modify the current focus location. 
</div>
</div><p>
<a class="anchor" name="24e094379581001370a84c3e734b5086"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_size_request" ref="24e094379581001370a84c3e734b5086" args="(int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_size_request           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the minimum size of a widget; that is, the widget's size request will be width by height. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width the widget should request, or -1 to unset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height widget should request, or -1 to unset.</td></tr>
  </table>
</dl>
You can use this method to force a widget to be either larger or smaller than it normally would be. In most cases, set_default_size() is a better choice for toplevel windows than this method; setting the default size will still allow users to shrink the window. Setting the size request will force them to leave the window at least as large as the size request. When dealing with window sizes, <a class="el" href="classXfc_1_1Gtk_1_1Window.html#93e8900077f3aa8274248734705f619c">Gtk::Window::set_geometry_hints()</a> can be a useful method as well.<p>
Note the inherent danger of setting any fixed size - themes, translations into other languages, different fonts, and user action can all change the appropriate size for a given widget. So, it's basically impossible to hardcode a size that will always be correct.<p>
The size request of a widget is the smallest size a widget can accept while still functioning well and drawing itself correctly. However in some strange cases a widget may be allocated less than its requested size, and in many cases a widget may be allocated more space than it requested. If the size request in a given direction is -1 (unset), then the "natural" size request of the widget will be used instead. Widgets can't actually be allocated a size less than 1 by 1, but you can pass 0,0 to this function to mean "as small as possible." 
</div>
</div><p>
<a class="anchor" name="06f53f990c65616d0f680ecd32ae630a"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_events" ref="06f53f990c65616d0f680ecd32ae630a" args="(Gdk::EventMaskField events)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_events           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">Gdk::EventMaskField</a>&nbsp;</td>
          <td class="paramname"> <em>events</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the event mask (see <a class="el" href="namespaceXfc_1_1Gdk.html#f215b70aefcd2357d37bf457ce88c577">Gdk::EventMask</a>) for a widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>The event mask.</td></tr>
  </table>
</dl>
The event mask determines which events a widget will receive. Keep in mind that different widgets have different default event masks, and by changing the event mask you may disrupt a widget's functionality, so be careful. This method must be called while a widget is unrealized. Consider <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9f1a749538a1ab0ffb2361678901874e">add_events()</a> for widgets that are already realized, or if you want to preserve the existing event mask. This method can't be used with <a class="el" href="namespaceXfc_1_1Gtk.html#0f57110577060d56855cc13134ff63c953af0c2deac47de6edbc4db12f2e1570">Gtk::NO_WINDOW</a> widgets; to get events on those widgets, place them inside an <a class="el" href="classXfc_1_1Gtk_1_1EventBox.html">EventBox</a> and receive events on the event box. 
</div>
</div><p>
<a class="anchor" name="9f1a749538a1ab0ffb2361678901874e"></a><!-- doxytag: member="Xfc::Gtk::Widget::add_events" ref="9f1a749538a1ab0ffb2361678901874e" args="(Gdk::EventMaskField events)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::add_events           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">Gdk::EventMaskField</a>&nbsp;</td>
          <td class="paramname"> <em>events</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the events in the bitfield <em>events</em> to the event mask for the widget (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#06f53f990c65616d0f680ecd32ae630a">set_events()</a>). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>An event mask, see <a class="el" href="namespaceXfc_1_1Gdk.html#f215b70aefcd2357d37bf457ce88c577">Gdk::EventMask</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="491a8eb8d2c7b4cd7297d0896c9d3a60"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_extension_events" ref="491a8eb8d2c7b4cd7297d0896c9d3a60" args="(Gdk::ExtensionMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_extension_events           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#6a40c7183f0539c8c67394dc8a22a917">Gdk::ExtensionMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the extension events mask to <em>mode</em> (see <a class="el" href="namespaceXfc_1_1Gdk.html#6a40c7183f0539c8c67394dc8a22a917">Gdk::ExtensionMode</a> and Gdk::Input::set_extension_events()). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The extension events to receive. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="43c629f6b651c0dc209016d278cd75fc"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_colormap" ref="43c629f6b651c0dc209016d278cd75fc" args="(Gdk::Colormap &amp;colormap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_colormap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>colormap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the colormap for the widget to <em>colormap</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>colormap</em>&nbsp;</td><td>A colormap.</td></tr>
  </table>
</dl>
The widget must not have been previously realized. This probably should only be used from a constructor for the widget. 
</div>
</div><p>
<a class="anchor" name="df04285b15497506dd9ab063f084c1e8"></a><!-- doxytag: member="Xfc::Gtk::Widget::translate_coordinates" ref="df04285b15497506dd9ab063f084c1e8" args="(Widget &amp;src_widget, int src_x, int src_y, int *dest_x, int *dest_y) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::translate_coordinates           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_widget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dest_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dest_y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translate coordinates relative to src_widget's allocation to coordinates relative to this widget's allocation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src_widget</em>&nbsp;</td><td>The source widget. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_x</em>&nbsp;</td><td>The X position relative to src_widget. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_y</em>&nbsp;</td><td>The Y position relative to src_widget. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_x</em>&nbsp;</td><td>The location to store X position relative to this widget. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_y</em>&nbsp;</td><td>The location to store Y position relative to this widget. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>false</em> if either widget was not realized, or there was no common ancestor. In this case, nothing is stored in <em>dest_x</em> and <em>dest_y</em>. Otherwise <em>true</em>.</dd></dl>
In order to perform this operation, both widgets must be realized, and must share a common toplevel. 
</div>
</div><p>
<a class="anchor" name="53d57cdf79b45a08d3650ddc1e728c42"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_style" ref="53d57cdf79b45a08d3650ddc1e728c42" args="(Style &amp;style)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_style           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>style</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> for the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>style</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1Style.html">Gtk::Style</a>, or null to remove the effect of a previous <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#53d57cdf79b45a08d3650ddc1e728c42">set_style()</a> and go back to the default style.</td></tr>
  </table>
</dl>
You probably don't want to use this function; it interacts badly with themes, because themes work by replacing the <a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a>. Instead, use <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a>. 
</div>
</div><p>
<a class="anchor" name="bc3751e620e23469a09f74940afac23a"></a><!-- doxytag: member="Xfc::Gtk::Widget::ensure_style" ref="bc3751e620e23469a09f74940afac23a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::ensure_style           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ensures that the widget has a style. 
<p>
Not a very useful method; most of the time, if you want the style, the widget is realized, and realized widgets are guaranteed to have a style already. 
</div>
</div><p>
<a class="anchor" name="6ee0cf2a19285d405164ef94da93a2e9"></a><!-- doxytag: member="Xfc::Gtk::Widget::modify_style" ref="6ee0cf2a19285d405164ef94da93a2e9" args="(RcStyle &amp;style)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::modify_style           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1RcStyle.html">RcStyle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>style</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modifies style values on the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>style</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gtk_1_1RcStyle.html">RcStyle</a> holding the style modifications.</td></tr>
  </table>
</dl>
Modifications made using this method take precedence over style values set via an <a class="el" href="classXfc_1_1Gtk_1_1RC.html">RC</a> file, however, they will be overridden if a style is explicitely set on the widget using <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#53d57cdf79b45a08d3650ddc1e728c42">set_style()</a>. The <a class="el" href="classXfc_1_1Gtk_1_1RcStyle.html">RcStyle</a> structure is designed so each field can either be set or unset, so it is possible, using this method, to modify some style values and leave the others unchanged.<p>
Note that modifications made with this method are not cumulative with previous calls to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a> or with such functions as <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c3e7bce80c4253899382374742c40ec5">modify_fg()</a>. If you wish to retain previous values, you must first call <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c471db10f64edd2236a69d57b8420bbd">get_modifier_style()</a>, make your modifications to the returned style, then call <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a> with that style. On the other hand, if you first call <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a>, subsequent calls to such methods as <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c3e7bce80c4253899382374742c40ec5">modify_fg()</a> will have a cumulative effect with the initial modifications. 
</div>
</div><p>
<a class="anchor" name="c3e7bce80c4253899382374742c40ec5"></a><!-- doxytag: member="Xfc::Gtk::Widget::modify_fg" ref="c3e7bce80c4253899382374742c40ec5" args="(StateType state, const Gdk::Color *color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::modify_fg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Color.html">Gdk::Color</a> *&nbsp;</td>
          <td class="paramname"> <em>color</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the foreground color for the widget in a particular state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The state for which to set the foreground color. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>The color to assign (does not need to be allocated), or null to undo the effect of previous calls to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c3e7bce80c4253899382374742c40ec5">modify_fg()</a>.</td></tr>
  </table>
</dl>
All other style values are left untouched (se also <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a>). 
</div>
</div><p>
<a class="anchor" name="fb887de4c1f3424b9c5a9f245bd2910f"></a><!-- doxytag: member="Xfc::Gtk::Widget::modify_bg" ref="fb887de4c1f3424b9c5a9f245bd2910f" args="(StateType state, const Gdk::Color *color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::modify_bg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Color.html">Gdk::Color</a> *&nbsp;</td>
          <td class="paramname"> <em>color</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the background color for the widget in a particular state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The state for which to set the background color. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>The color to assign (does not need to be allocated), or null to undo the effect of previous calls to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fb887de4c1f3424b9c5a9f245bd2910f">modify_bg()</a>.</td></tr>
  </table>
</dl>
All other style values are left untouched (see also <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a>). 
</div>
</div><p>
<a class="anchor" name="0f9ca2d7a76b3beb80088e0962881b67"></a><!-- doxytag: member="Xfc::Gtk::Widget::modify_text" ref="0f9ca2d7a76b3beb80088e0962881b67" args="(StateType state, const Gdk::Color *color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::modify_text           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Color.html">Gdk::Color</a> *&nbsp;</td>
          <td class="paramname"> <em>color</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the text color for the widget in a particular state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The state for which to set the text color. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>The color to assign (does not need to be allocated), or null to undo the effect of previous calls to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0f9ca2d7a76b3beb80088e0962881b67">modify_text()</a>.</td></tr>
  </table>
</dl>
All other style values are left untouched. The text color is the foreground color used along with the base color (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#97a153f8171a24884a52727c6444b43b">modify_base()</a>) for widgets such as <a class="el" href="classXfc_1_1Gtk_1_1Entry.html">Entry</a> and <a class="el" href="classXfc_1_1Gtk_1_1TextView.html">TextView</a>. See also <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a>. 
</div>
</div><p>
<a class="anchor" name="97a153f8171a24884a52727c6444b43b"></a><!-- doxytag: member="Xfc::Gtk::Widget::modify_base" ref="97a153f8171a24884a52727c6444b43b" args="(StateType state, const Gdk::Color *color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::modify_base           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Color.html">Gdk::Color</a> *&nbsp;</td>
          <td class="paramname"> <em>color</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the base color for the widget in a particular state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The state for which to set the base color. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>The color to assign (does not need to be allocated), or null to undo the effect of previous calls to of <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#97a153f8171a24884a52727c6444b43b">modify_base()</a>.</td></tr>
  </table>
</dl>
All other style values are left untouched. The base color is the background color used along with the text color (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0f9ca2d7a76b3beb80088e0962881b67">modify_text()</a>) for widgets such as <a class="el" href="classXfc_1_1Gtk_1_1Entry.html">Entry</a> and <a class="el" href="classXfc_1_1Gtk_1_1TextView.html">TextView</a>. See also <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a>. 
</div>
</div><p>
<a class="anchor" name="fcc8b7875eed5d84d3e556371e22f502"></a><!-- doxytag: member="Xfc::Gtk::Widget::modify_font" ref="fcc8b7875eed5d84d3e556371e22f502" args="(const Pango::FontDescription *font_desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::modify_font           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Pango_1_1FontDescription.html">Pango::FontDescription</a> *&nbsp;</td>
          <td class="paramname"> <em>font_desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the font to use for the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>font_desc</em>&nbsp;</td><td>The font description to use, or null to undo the effect of previous calls to <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fcc8b7875eed5d84d3e556371e22f502">modify_font()</a>.</td></tr>
  </table>
</dl>
All other style values are left untouched. See also <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6ee0cf2a19285d405164ef94da93a2e9">modify_style()</a>. 
</div>
</div><p>
<a class="anchor" name="edade1fbad742313d285cede0135a174"></a><!-- doxytag: member="Xfc::Gtk::Widget::create_pango_context" ref="edade1fbad742313d285cede0135a174" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Pango_1_1Context.html">Pango::Context</a>&gt; Xfc::Gtk::Widget::create_pango_context           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new <a class="el" href="classXfc_1_1Pango_1_1Context.html">Pango::Context</a> with the appropriate colormap, font description, and base direction for drawing text for this widget (see also <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5ef20cc10a065baf8d2ecd5a92d8bf4e">get_pango_context()</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the new <a class="el" href="classXfc_1_1Pango_1_1Context.html">Pango::Context</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5e767648f758e7f11d691c542e468a7"></a><!-- doxytag: member="Xfc::Gtk::Widget::create_pango_layout" ref="b5e767648f758e7f11d691c542e468a7" args="(const String &amp;text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Pango_1_1Layout.html">Pango::Layout</a>&gt; Xfc::Gtk::Widget::create_pango_layout           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new <a class="el" href="classXfc_1_1Pango_1_1Layout.html">Pango::Layout</a> with the appropriate colormap, font description, and base direction for drawing text for this widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to set on the layout (can be a null <a class="el" href="classXfc_1_1String.html">String</a>). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the new <a class="el" href="classXfc_1_1Pango_1_1Layout.html">Pango::Layout</a>.</dd></dl>
If you keep a <a class="el" href="classXfc_1_1Pango_1_1Layout.html">Pango::Layout</a> created in this way around, in order to notify the layout of changes to the base direction or font for this widget, you must call <a class="el" href="classXfc_1_1Pango_1_1Layout.html#c1410ab29d67ab2903e2cdf6ab7d8ddd">Pango::Layout::context_changed()</a> in response to the <em>style_set</em> and <em>direction_set</em> signals for the widget. 
</div>
</div><p>
<a class="anchor" name="6e3c25d0404f97ab2364432ac76a28c9"></a><!-- doxytag: member="Xfc::Gtk::Widget::render_icon" ref="6e3c25d0404f97ab2364432ac76a28c9" args="(const StockId &amp;stock_id, IconSize size, const char *detail=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a>&gt; Xfc::Gtk::Widget::render_icon           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1StockId.html">StockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stock_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#7dcd2f2d59523925457282711a37dfd5">IconSize</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>detail</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A convenience method that uses the theme engine and <a class="el" href="classXfc_1_1Gtk_1_1RC.html">RC</a> file settings for the widget to look up stock_id and render it to a pixbuf. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stock_id</em>&nbsp;</td><td>A stock ID. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>A stock size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detail</em>&nbsp;</td><td>The render detail to pass to a theme engine. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the new pixbuf, or null if the stock ID wasn't known.</dd></dl>
<em>stock_id</em> should be a stock icon ID such as <a class="el" href="classXfc_1_1Gtk_1_1StockId.html#7087c9b6edda00cfaf1b9d76de340649">Gtk::StockId::OPEN</a> or <a class="el" href="classXfc_1_1Gtk_1_1StockId.html#c20c9ce83a85abb2534c7732b6c5e926">Gtk::StockId::OK</a>. <em>size</em> should be a size such as <a class="el" href="namespaceXfc_1_1Gtk.html#7dcd2f2d59523925457282711a37dfd5bbc4ba8a04f76f48a9ee41f34574ed1d">Gtk::ICON_SIZE_MENU</a>. <em>detail</em> should be a string that identifies the widget or code doing the rendering, so that theme engines can special-case rendering for that widget or code. The pixels in the returned <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> are shared with the rest of the application and should not be modified. 
</div>
</div><p>
<a class="anchor" name="8f5e1b1a86c708dd116f51adb8221ce9"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_composite_name" ref="8f5e1b1a86c708dd116f51adb8221ce9" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_composite_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a widgets composite name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to set.</td></tr>
  </table>
</dl>
The widget must be a composite child of its parent (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bad3faa1076e44c146329d81ffc9b675">push_composite_child()</a>). 
</div>
</div><p>
<a class="anchor" name="737ecd03de45e3e66f0d926840c6372c"></a><!-- doxytag: member="Xfc::Gtk::Widget::reset_rc_styles" ref="737ecd03de45e3e66f0d926840c6372c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::reset_rc_styles           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the styles of the widget and all descendents, so when they are looked up again, they get the correct values for the currently loaded <a class="el" href="classXfc_1_1Gtk_1_1RC.html">RC</a> file settings. 
<p>
This method is not useful for applications 
</div>
</div><p>
<a class="anchor" name="b988c1512ac41160cdb44b3d0d6b3769"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_direction" ref="b988c1512ac41160cdb44b3d0d6b3769" args="(TextDirection dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::set_direction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#a0e16bc97f4e6e915aab3365d7f8d6c4">TextDirection</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the reading direction on a particular widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>The new direction.</td></tr>
  </table>
</dl>
This direction controls the primary direction for widgets containing text, and also the direction in which the children of a container are packed. The ability to set the direction is present in order so that correct localization into languages with right-to-left reading directions can be done. Generally, applications will let the default reading direction present, except for containers where the containers are arranged in an order that is explicitely visual rather than logical (such as buttons for text justification). If the direction is set to <a class="el" href="namespaceXfc_1_1Gtk.html#a0e16bc97f4e6e915aab3365d7f8d6c41685404f7a8f75600c5c4182b9e4fb0c">Gtk::TEXT_DIR_NONE</a>, then the value set by <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2b8e3cb53fb1eb451b579d45763a83b2">set_default_direction()</a> will be used. 
</div>
</div><p>
<a class="anchor" name="4ac40c2f282820b775e250a8146a5959"></a><!-- doxytag: member="Xfc::Gtk::Widget::shape_combine_mask" ref="4ac40c2f282820b775e250a8146a5959" args="(const Gdk::Bitmap &amp;shape_mask, int offset_x, int offset_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::shape_combine_mask           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Gdk::Bitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shape_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset_y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a shape for this widget's GDK window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shape_mask</em>&nbsp;</td><td>The shape to be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_x</em>&nbsp;</td><td>The X position of shape mask with respect to window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_y</em>&nbsp;</td><td>The Y position of shape mask with respect to window.</td></tr>
  </table>
</dl>
This allows for transparent windows etc., see <a class="el" href="classXfc_1_1Gdk_1_1Window.html#df699f5e172fa8255f3a3b334ea9eb26">Gdk::Window::shape_combine_mask()</a> for more information. 
</div>
</div><p>
<a class="anchor" name="9edf3e0ec4ca371f3e40681c64dc522c"></a><!-- doxytag: member="Xfc::Gtk::Widget::list_mnemonic_labels" ref="9edf3e0ec4ca371f3e40681c64dc522c" args="(std::vector&lt; Widget * &gt; &amp;widgets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::list_mnemonic_labels           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>widgets</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a list of the widgets, normally labels, for which this widget is a the target of a mnemonic (see for example, <a class="el" href="classXfc_1_1Gtk_1_1Label.html#8a1293d4e52f45444847b91050ca5260">Gtk::Label::set_mnemonic_widget()</a>). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>widgets</em>&nbsp;</td><td>A reference to a vector of Widget* to hold the list of mnemonic labels. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the vector is not empty.</dd></dl>
The widgets in the vector are not individually referenced. If you want to iterate through the vector and perform actions that might destroy the widgets, you must call <a class="el" href="classXfc_1_1Gtk_1_1Object.html#60fabe4bda00b4ef724a14fb67be5c45">ref()</a> to reference a widget and <a class="el" href="classXfc_1_1G_1_1Object.html#513fc400272db0db24d32f9a280e64a5">unref()</a> to unreference it afterwards. 
</div>
</div><p>
<a class="anchor" name="33d9efa87c2dd234e80c62586af58da7"></a><!-- doxytag: member="Xfc::Gtk::Widget::add_mnemonic_label" ref="33d9efa87c2dd234e80c62586af58da7" args="(Widget &amp;label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::add_mnemonic_label           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>label</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a widget to the list of mnemonic labels for this widget (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9edf3e0ec4ca371f3e40681c64dc522c">Gtk::Widget::list_mnemonic_labels()</a>). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>label</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> that acts as a mnemonic label for this widget.</td></tr>
  </table>
</dl>
<b>Note:</b> The list of mnemonic labels for the widget is cleared when the widget is destroyed, so the caller must make sure to update it's internal state at this point as well, by using a connection to the <a class="el" href="classXfc_1_1Gtk_1_1Object.html#81d00898c9cc8ac644cfc9296d66c4ef">Gtk::Object::signal_destroy()</a> signal. 
</div>
</div><p>
<a class="anchor" name="aa7ab48be740ae80f71ce4e5cedace87"></a><!-- doxytag: member="Xfc::Gtk::Widget::remove_mnemonic_label" ref="aa7ab48be740ae80f71ce4e5cedace87" args="(Widget &amp;label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::remove_mnemonic_label           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>label</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a widget from the list of mnemonic labels for this widget (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9edf3e0ec4ca371f3e40681c64dc522c">Gtk::Widget::list_mnemonic_labels()</a>). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>label</em>&nbsp;</td><td><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> that was previously set as a mnemonic label for this widget.</td></tr>
  </table>
</dl>
The widget <em>label</em> must have previously been added to the list with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#33d9efa87c2dd234e80c62586af58da7">add_mnemonic_label()</a>. 
</div>
</div><p>
<a class="anchor" name="994aa7b469117de80741d4c9cbdf3895"></a><!-- doxytag: member="Xfc::Gtk::Widget::push_colormap" ref="994aa7b469117de80741d4c9cbdf3895" args="(Gdk::Colormap &amp;cmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Gtk::Widget::push_colormap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cmap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pushes <em>cmap</em> onto a global stack of colormaps; the topmost colormap on the stack will be used to create all widgets. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cmap</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a></td></tr>
  </table>
</dl>
Remove <em>cmap</em> with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7c5c39318f4d717301043f9e6802dddd">pop_colormap()</a>. There's little reason to use this method. 
</div>
</div><p>
<a class="anchor" name="bad3faa1076e44c146329d81ffc9b675"></a><!-- doxytag: member="Xfc::Gtk::Widget::push_composite_child" ref="bad3faa1076e44c146329d81ffc9b675" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Gtk::Widget::push_composite_child           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A composite child is a child that's an implementation detail of the container it's inside and should not be visible to people using the container. 
<p>
Composite children aren't treated differently by GTK but e.g. GUI builders might want to treat them in a different way. 
</div>
</div><p>
<a class="anchor" name="e010d5543fe65dc5b8d988849541d5c6"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_default_colormap" ref="e010d5543fe65dc5b8d988849541d5c6" args="(Gdk::Colormap *colormap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Gtk::Widget::set_default_colormap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a> *&nbsp;</td>
          <td class="paramname"> <em>colormap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the default colormap to use when creating widgets. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>colormap</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a>.</td></tr>
  </table>
</dl>
<a class="el" href="classXfc_1_1Gtk_1_1Widget.html#994aa7b469117de80741d4c9cbdf3895">push_colormap()</a> is a better method to use if you only want to affect a few widgets, rather than all widgets. 
</div>
</div><p>
<a class="anchor" name="2b8e3cb53fb1eb451b579d45763a83b2"></a><!-- doxytag: member="Xfc::Gtk::Widget::set_default_direction" ref="2b8e3cb53fb1eb451b579d45763a83b2" args="(TextDirection dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Gtk::Widget::set_default_direction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#a0e16bc97f4e6e915aab3365d7f8d6c4">TextDirection</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the default reading direction for widgets where the direction has not been explicitly set by <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b988c1512ac41160cdb44b3d0d6b3769">set_direction()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>The new default direction. This cannot be <a class="el" href="namespaceXfc_1_1Gtk.html#a0e16bc97f4e6e915aab3365d7f8d6c41685404f7a8f75600c5c4182b9e4fb0c">Gtk::TEXT_DIR_NONE</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7ba1f608d05fdb4aa6fe635c36d461df"></a><!-- doxytag: member="Xfc::Gtk::Widget::keyboard_grab" ref="7ba1f608d05fdb4aa6fe635c36d461df" args="(bool owner_events=false, unsigned int time=GDK_CURRENT_TIME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1Gdk.html#a122cdf630b777e48fce8da9f57a01b6">Gdk::GrabStatus</a> Xfc::Gtk::Widget::keyboard_grab           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owner_events</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>time</em> = <code>GDK_CURRENT_TIME</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grabs the keyboard so that all events are passed to this widget until the keyboard is ungrabbed with <a class="el" href="namespaceXfc_1_1Gdk.html#18d3b377328e00747fe591469bdc91f6">Gdk::keyboard_ungrab()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owner_events</em>&nbsp;</td><td>If <em>false</em> then all keyboard events are reported with respect the widget. If <em>true</em> then keyboard events for this application are reported as normal, but keyboard events outside this application are reported with respect to the widget. Both key press and key release events are always reported, independant of the event mask set by the application. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>A timestamp from a <a class="el" href="classXfc_1_1Gdk_1_1Event.html">Gdk::Event</a>, or GDK_CURRENT_TIME if no timestamp is available. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="namespaceXfc_1_1Gdk.html#a122cdf630b777e48fce8da9f57a01b6a0d3802ed26a8f9c7bf4d35f1ae44e25">Gdk::GRAB_SUCCESS</a> if the grab was successful.</dd></dl>
This overrides any previous keyboard grab by this client. The widget's <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> will own the grab (the grab window). 
</div>
</div><p>
<a class="anchor" name="b86b234b154111b58ffa69fdb0e65a41"></a><!-- doxytag: member="Xfc::Gtk::Widget::pointer_grab" ref="b86b234b154111b58ffa69fdb0e65a41" args="(Gdk::EventMaskField event_mask, Widget *confine_to=0, Gdk::Cursor *cursor=0, bool owner_events=false, unsigned int time=GDK_CURRENT_TIME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1Gdk.html#a122cdf630b777e48fce8da9f57a01b6">Gdk::GrabStatus</a> Xfc::Gtk::Widget::pointer_grab           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#f5db0fa70a2a7adc723b39b0b80e31a0">Gdk::EventMaskField</a>&nbsp;</td>
          <td class="paramname"> <em>event_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> *&nbsp;</td>
          <td class="paramname"> <em>confine_to</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Cursor.html">Gdk::Cursor</a> *&nbsp;</td>
          <td class="paramname"> <em>cursor</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owner_events</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>time</em> = <code>GDK_CURRENT_TIME</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grabs the pointer (usually a mouse) so that all events are passed to this widget until the pointer is ungrabbed with <a class="el" href="namespaceXfc_1_1Gdk.html#c01264f9bd5744449473c344b96ae9b8">Gdk::pointer_ungrab()</a>, or the grab widget becomes unviewable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event_mask</em>&nbsp;</td><td>Specifies the event mask, which is used in accordance with owner_events. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>confine_to</em>&nbsp;</td><td>If non-null, the pointer will be confined to this widget during the grab. If the pointer is outside confine_to, it will automatically be moved to the closest edge of confine_to and enter and leave events will be generated as necessary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cursor</em>&nbsp;</td><td>The cursor to display while the grab is active. If this is null then the normal cursors are used for the widget and its descendants, and the cursor for the widget is used for all other windows. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owner_events</em>&nbsp;</td><td>If <em>false</em> then all pointer events are reported with respect to the widget and are only reported if selected by event_mask. If <em>true</em> then pointer events for this application are reported as normal, but pointer events outside this application are reported with respect to the widget and only if selected by event_mask. In either mode, unreported events are discarded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>The timestamp of the event which led to this pointer grab. This usually comes from a <a class="el" href="classXfc_1_1Gdk_1_1EventButton.html">Gdk::EventButton</a>, though GDK_CURRENT_TIME can be used if the time isn't known. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="namespaceXfc_1_1Gdk.html#a122cdf630b777e48fce8da9f57a01b6a0d3802ed26a8f9c7bf4d35f1ae44e25">Gdk::GRAB_SUCCESS</a> if the grab was successful.</dd></dl>
This overrides any previous pointer grab by this client. The widget's <a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> will own the grab (the grab window). <a class="el" href="classXfc_1_1Pointer.html">Pointer</a> grabs are used for operations which need complete control over mouse events, even if the mouse leaves the application. For example in GTK+ it is used for Drag and Drop, for dragging the handle in the <a class="el" href="classXfc_1_1Gtk_1_1HPaned.html">HPaned</a> and <a class="el" href="classXfc_1_1Gtk_1_1VPaned.html">VPaned</a> widgets. Note that if the event mask of an X window has selected both button press and button release events, then a button press event will cause an automatic pointer grab until the button is released. X does this automatically since most applications expect to receive button press and release events in pairs. It is equivalent to a pointer grab on the window with owner_events set to true. 
</div>
</div><p>
<a class="anchor" name="891aa866e1b85c440b06a905f3265682"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_owner_get" ref="891aa866e1b85c440b06a905f3265682" args="(Gdk::Atom selection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::selection_owner_get           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>selection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the widget owns <em>selection</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection</em>&nbsp;</td><td>An interned atom representing the selection to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if this widget owns <em>selection</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a510a9bd15f87c3b7d8ce5db22c924d"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_owner_set" ref="1a510a9bd15f87c3b7d8ce5db22c924d" args="(Gdk::Atom selection, unsigned int time, const Gdk::Display *display=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::selection_owner_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a> *&nbsp;</td>
          <td class="paramname"> <em>display</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Claim ownership of a given selection for a particular widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection</em>&nbsp;</td><td>An interned atom representing the selection to claim. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>A timestamp with which to claim the selection, or GDK_CURRENT_TIME. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>display</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a> where the selection is set, or null for the default display. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the operation succeeded. </dd></dl>

</div>
</div><p>
<a class="anchor" name="95463a6bd5e41394320dbc682d22591f"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_add_target" ref="95463a6bd5e41394320dbc682d22591f" args="(Gdk::Atom selection, Gdk::Atom target, unsigned int info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::selection_add_target           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the specified target to the list of supported targets for the widget and selection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection</em>&nbsp;</td><td>The selection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The target to add. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>An unsigned integer which will be passed back to the application. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="629dd90b8a3e6e40557bcc0204011b31"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_add_target" ref="629dd90b8a3e6e40557bcc0204011b31" args="(Gdk::Atom selection, const TargetEntry &amp;entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::selection_add_target           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the specified target to the list of supported targets for the widget and selection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection</em>&nbsp;</td><td>The selection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>The target entry to add. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="297733c8ff0ca4fb52839ffa491cb29f"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_add_targets" ref="297733c8ff0ca4fb52839ffa491cb29f" args="(Gdk::Atom selection, const std::vector&lt; TargetEntry &gt; &amp;targets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::selection_add_targets           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>targets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the targets specified in <em>targets</em> to the list of supported targets for the widget and selection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection</em>&nbsp;</td><td>The selection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targets</em>&nbsp;</td><td>A reference to a vector of <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> that holds the targets to add. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9317959f9a382d746ce3f2652c2615f6"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_clear_targets" ref="9317959f9a382d746ce3f2652c2615f6" args="(Gdk::Atom selection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::selection_clear_targets           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>selection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove all targets registered for the given selection for the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection</em>&nbsp;</td><td>An atom representing a selection. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a99f2bf2b3dd0adb1c5ba84f112fcd85"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_convert" ref="a99f2bf2b3dd0adb1c5ba84f112fcd85" args="(Gdk::Atom selection, Gdk::Atom target, unsigned int time=GDK_CURRENT_TIME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::selection_convert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>time</em> = <code>GDK_CURRENT_TIME</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Requests the contents of a selection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection</em>&nbsp;</td><td>Which selection to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Form of information desired (e.g., STRING). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>Time of request (usually of triggering event), or you could use GDK_CURRENT_TIME. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the request succeeded. <em>false</em> if we could not process the request (e.g. there was already a request in process for this widget).</dd></dl>
When received, a <em>selection_received</em> signal will be generated. 
</div>
</div><p>
<a class="anchor" name="adaed493024e5dc494012b6cae63a751"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_remove_all" ref="adaed493024e5dc494012b6cae63a751" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::selection_remove_all           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all handlers and unsets ownership of all selections for the widget. 
<p>
Called when the widget is being destroyed. This method will not generally be called by applications. 
</div>
</div><p>
<a class="anchor" name="6511ed909485e1094aeb98fe66361eda"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_owner_unset" ref="6511ed909485e1094aeb98fe66361eda" args="(Gdk::Atom selection, unsigned int time, const Gdk::Display *display=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Xfc::Gtk::Widget::selection_owner_unset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a> *&nbsp;</td>
          <td class="paramname"> <em>display</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases ownership of a given selection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection</em>&nbsp;</td><td>An interned atom representing the selection to release. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>A timestamp with which to claim the selection, or GDK_CURRENT_TIME. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>display</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a> where the selection is set, or null for the default display. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the operation succeeded. </dd></dl>

</div>
</div><p>
<a class="anchor" name="55ec947a7bf19e2a54804560dd972d56"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_get_data" ref="55ec947a7bf19e2a54804560dd972d56" args="(DragContext &amp;context, Gdk::Atom target, unsigned int time=GDK_CURRENT_TIME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_get_data           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1DragContext.html">DragContext</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>time</em> = <code>GDK_CURRENT_TIME</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the data associated with a drag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>The drag context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The target (form of the data) to retrieve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>A timestamp for retrieving the data.</td></tr>
  </table>
</dl>
When the data is received or the retrieval fails, GTK+ will emit a <em>drag_data_received</em> signal. Failure of the retrieval is indicated by <a class="el" href="classXfc_1_1Gtk_1_1SelectionData.html#72773bef0ed6b01ebbf0cf0a317de44b">Gtk::SelectionData::is_valid()</a> returning <em>false</em>. However, when <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#55ec947a7bf19e2a54804560dd972d56">drag_get_data()</a> is called implicitely because the Gtk::DRAG_DEFAULT_DROP was set, then the widget will not receive notification of failed drops and <a class="el" href="classXfc_1_1Gtk_1_1SelectionData.html#72773bef0ed6b01ebbf0cf0a317de44b">Gtk::SelectionData::is_valid()</a> will be undefined. <em>time</em> will generally be the time received in a <em>drag_data_motion</em> or <em>drag_data_drop</em> signal. 
</div>
</div><p>
<a class="anchor" name="0c9f1821383f18786feeca063d0df314"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_highlight" ref="0c9f1821383f18786feeca063d0df314" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_highlight           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draws a highlight around the widget. 
<p>
This will attach handlers to <em>expose_event</em> and draw, so the highlight will continue to be displayed until <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fedcbabc8fc4c676ca84d67a27a49b26">drag_unhighlight()</a> is called. 
</div>
</div><p>
<a class="anchor" name="0db2fd7ddd3f007189134c474f582e54"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_dest_set" ref="0db2fd7ddd3f007189134c474f582e54" args="(DestDefaultsField flags, const TargetEntry &amp;target, Gdk::DragActionField actions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_dest_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#9ec7f9211b2bc5afd55804c223b85ac4">DestDefaultsField</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#34899cc9ad073dfff1a1cecf41046825">Gdk::DragActionField</a>&nbsp;</td>
          <td class="paramname"> <em>actions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the widget as a potential drop destination. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The flags that specify what actions GTK+ should take on behalf of a widget for drops onto that widget. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> indicating the drop type that this widget will accept. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actions</em>&nbsp;</td><td>A bitmask of possible actions for a drop onto this widget.</td></tr>
  </table>
</dl>
The targets and actions fields only are used if DEST_DEFAULT_MOTION or DEST_DEFAULT_DROP are given. 
</div>
</div><p>
<a class="anchor" name="e9b25e8a5a60f3c2da984db3ee2c5f84"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_dest_set" ref="e9b25e8a5a60f3c2da984db3ee2c5f84" args="(DestDefaultsField flags, const std::vector&lt; TargetEntry &gt; &amp;targets, Gdk::DragActionField actions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_dest_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#9ec7f9211b2bc5afd55804c223b85ac4">DestDefaultsField</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#34899cc9ad073dfff1a1cecf41046825">Gdk::DragActionField</a>&nbsp;</td>
          <td class="paramname"> <em>actions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the widget as a potential drop destination. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The flags that specify what actions GTK+ should take on behalf of a widget for drops onto that widget. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targets</em>&nbsp;</td><td>A vector of <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> indicating the drop types that this widget will accept. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actions</em>&nbsp;</td><td>A bitmask of possible actions for a drop onto this widget.</td></tr>
  </table>
</dl>
The targets and actions fields only are used if DEST_DEFAULT_MOTION or DEST_DEFAULT_DROP are given. 
</div>
</div><p>
<a class="anchor" name="8b32a49c483df1129628964bbb7c1f23"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_dest_set_proxy" ref="8b32a49c483df1129628964bbb7c1f23" args="(Gdk::Window *proxy_window, Gdk::DragProtocol protocol, bool use_coordinates)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_dest_set_proxy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Window.html">Gdk::Window</a> *&nbsp;</td>
          <td class="paramname"> <em>proxy_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#87518899c90c08b4b0e7e3e89d53a094">Gdk::DragProtocol</a>&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_coordinates</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the widget as a proxy for drops to another window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy_window</em>&nbsp;</td><td>The window to which to forward drag events </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>The drag protocol which the proxy_window accepts (You can use gdk_drag_get_protocol() to determine this). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_coordinates</em>&nbsp;</td><td>If <em>true</em>, send the same coordinates to the destination, because it is an embedded subwindow. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="259bc1b156948fd1aa58212f14ebb6c2"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_dest_unset" ref="259bc1b156948fd1aa58212f14ebb6c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_dest_unset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears information about a drop destination set with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0db2fd7ddd3f007189134c474f582e54">drag_dest_set()</a>. 
<p>
The widget will no longer receive notification of drags. 
</div>
</div><p>
<a class="anchor" name="7a2ab44ab0e4782fd3ef1c1786507bad"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_dest_find_target" ref="7a2ab44ab0e4782fd3ef1c1786507bad" args="(const DragContext &amp;context, const TargetList *target_list=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1Gdk.html#e2515d2de4ddea4de224261bb642c204">Gdk::Atom</a> Xfc::Gtk::Widget::drag_dest_find_target           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1DragContext.html">DragContext</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a> *&nbsp;</td>
          <td class="paramname"> <em>target_list</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks for a match between context.targets() and the target_list, returning the first matching target, otherwise returning GDK_NONE. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>A drag context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target_list</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a> of droppable targets, or null to use <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#30be3016d3f93956e3f3ae94c71bf2ff">drag_dest_get_target_list()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The first target that the source offers and the dest can accept, or GDK_NONE.</dd></dl>
The target_list should usually be the return value from <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#30be3016d3f93956e3f3ae94c71bf2ff">drag_dest_get_target_list()</a>, but some widgets may have different valid targets for different parts of the widget; in that case, they will have to implement a drag_motion handler that passes the correct target list to this function. 
</div>
</div><p>
<a class="anchor" name="30be3016d3f93956e3f3ae94c71bf2ff"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_dest_get_target_list" ref="30be3016d3f93956e3f3ae94c71bf2ff" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a>* Xfc::Gtk::Widget::drag_dest_get_target_list           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the list of targets this widget can accept from drag-and-drop. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a>, or null if none. </dd></dl>

</div>
</div><p>
<a class="anchor" name="23e46a182839ab5942567e045bd948ca"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_dest_set_target_list" ref="23e46a182839ab5942567e045bd948ca" args="(TargetList *target_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_dest_set_target_list           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a> *&nbsp;</td>
          <td class="paramname"> <em>target_list</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the target types that this widget can accept from drag-and-drop. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target_list</em>&nbsp;</td><td>A list of droppable targets, or null for none.</td></tr>
  </table>
</dl>
The widget must first be made into a drag destination with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0db2fd7ddd3f007189134c474f582e54">drag_dest_set()</a>. 
</div>
</div><p>
<a class="anchor" name="455b364e84056e15afc6ad982186018c"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_dest_add_text_targets" ref="455b364e84056e15afc6ad982186018c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_dest_add_text_targets           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add the text targets supported by Gtk::Selection to the target list of the drag destination. 
<p>
The targets are added with info = 0. If you need another value, use <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html#6d2ecef1757b6c7942a3c99aee44baf4">Gtk::TargetList::add_text_targets()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#23e46a182839ab5942567e045bd948ca">drag_dest_set_target_list()</a>. 
</div>
</div><p>
<a class="anchor" name="18427b01393c0ef0207d2af8253f07ab"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_dest_add_image_targets" ref="18427b01393c0ef0207d2af8253f07ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_dest_add_image_targets           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add the image targets supported by Gtk::Selection to the target list of the drag destination. 
<p>
The targets are added with info = 0. If you need another value, use <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html#8659efc8c22479574879c7db55b4aac5">Gtk::TargetList::add_image_targets()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#23e46a182839ab5942567e045bd948ca">drag_dest_set_target_list()</a>. 
</div>
</div><p>
<a class="anchor" name="4be15c9196a0ce5146ff281fcb64bfa3"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_dest_add_uri_targets" ref="4be15c9196a0ce5146ff281fcb64bfa3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_dest_add_uri_targets           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add the URI targets supported by Gtk::Selection to the target list of the drag destination. 
<p>
The targets are added with info = 0. If you need another value, use <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html#5d2628b83fabbeef121c9fe6001db2ec">Gtk::TargetList::add_uri_targets()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#23e46a182839ab5942567e045bd948ca">drag_dest_set_target_list()</a>. 
</div>
</div><p>
<a class="anchor" name="9ebdd9b7b9290c6deaf27a16b59eaf0d"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_begin" ref="9ebdd9b7b9290c6deaf27a16b59eaf0d" args="(const TargetList &amp;targets, Gdk::DragActionField actions, int button, const Gdk::Event &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1DragContext.html">DragContext</a>* Xfc::Gtk::Widget::drag_source_begin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#34899cc9ad073dfff1a1cecf41046825">Gdk::DragActionField</a>&nbsp;</td>
          <td class="paramname"> <em>actions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Event.html">Gdk::Event</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initiates a drag on the source side. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>targets</em>&nbsp;</td><td>The targets (data formats) in which the source can provide the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actions</em>&nbsp;</td><td>A bitmask of the allowed drag actions for this drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>button</em>&nbsp;</td><td>The button the user clicked to start the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The event that triggered the start of the drag. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The context for this drag.</dd></dl>
The method only needs to be used when the application is starting drags itself, and is not needed when <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#83b713b73fb29ce222e0bda43791feef">drag_source_set()</a> is used. 
</div>
</div><p>
<a class="anchor" name="83b713b73fb29ce222e0bda43791feef"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_set" ref="83b713b73fb29ce222e0bda43791feef" args="(Gdk::ModifierTypeField start_button_mask, const TargetEntry &amp;target, Gdk::DragActionField actions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_source_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">Gdk::ModifierTypeField</a>&nbsp;</td>
          <td class="paramname"> <em>start_button_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#34899cc9ad073dfff1a1cecf41046825">Gdk::DragActionField</a>&nbsp;</td>
          <td class="paramname"> <em>actions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up the widget so that GTK+ will start a drag operation when the user clicks and drags on the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_button_mask</em>&nbsp;</td><td>The bitmask of buttons that can start the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> for the target the drag will support. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actions</em>&nbsp;</td><td>The bitmask of possible actions for a drag from this widget. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="408d35d4a635fe0002657b4ddffbb570"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_set" ref="408d35d4a635fe0002657b4ddffbb570" args="(Gdk::ModifierTypeField start_button_mask, const std::vector&lt; TargetEntry &gt; &amp;targets, Gdk::DragActionField actions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_source_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">Gdk::ModifierTypeField</a>&nbsp;</td>
          <td class="paramname"> <em>start_button_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#34899cc9ad073dfff1a1cecf41046825">Gdk::DragActionField</a>&nbsp;</td>
          <td class="paramname"> <em>actions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up the widget so that GTK+ will start a drag operation when the user clicks and drags on the widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_button_mask</em>&nbsp;</td><td>The bitmask of buttons that can start the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targets</em>&nbsp;</td><td>A vector of <a class="el" href="classXfc_1_1Gtk_1_1TargetEntry.html">TargetEntry</a> for the targets the drag will support. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actions</em>&nbsp;</td><td>The bitmask of possible actions for a drag from this widget. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f6c28a8d92ee00a16cf17d1b106e75f2"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_get_target_list" ref="f6c28a8d92ee00a16cf17d1b106e75f2" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a>* Xfc::Gtk::Widget::drag_source_get_target_list           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the list of targets this widget can provide for drag-and-drop. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a>, or null for none. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bcb24f0893df9d780ab14fafdfc54617"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_set_target_list" ref="bcb24f0893df9d780ab14fafdfc54617" args="(TargetList *target_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_source_set_target_list           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1TargetList.html">TargetList</a> *&nbsp;</td>
          <td class="paramname"> <em>target_list</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes the target types that this widget offers for drag-and-drop. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target_list</em>&nbsp;</td><td>The list of draggable targets, or null for none .</td></tr>
  </table>
</dl>
The widget must first be made into a drag source with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#83b713b73fb29ce222e0bda43791feef">drag_source_set()</a>. 
</div>
</div><p>
<a class="anchor" name="e0c660114410254ac2875720d6dccdaf"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_add_text_targets" ref="e0c660114410254ac2875720d6dccdaf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_source_add_text_targets           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add the text targets supported by Gtk::Selection to the target list of the drag source. 
<p>
The targets are added with info = 0. If you need another value, use <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html#6d2ecef1757b6c7942a3c99aee44baf4">Gtk::TargetList::add_text_targets()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bcb24f0893df9d780ab14fafdfc54617">drag_source_set_target_list()</a>. 
</div>
</div><p>
<a class="anchor" name="10e06ab83fb839441d784748235407c7"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_add_image_targets" ref="10e06ab83fb839441d784748235407c7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_source_add_image_targets           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add the image targets supported by Gtk::Selection to the target list of the drag source. 
<p>
The targets are added with info = 0. If you need another value, use <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html#8659efc8c22479574879c7db55b4aac5">Gtk::TargetList::add_image_targets()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bcb24f0893df9d780ab14fafdfc54617">drag_source_set_target_list()</a>. 
</div>
</div><p>
<a class="anchor" name="e8d1c2cfb9b3cf85427b28c1c82da80e"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_add_uri_targets" ref="e8d1c2cfb9b3cf85427b28c1c82da80e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_source_add_uri_targets           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add the URI targets supported by Gtk::Selection to the target list of the drag source. 
<p>
The targets are added with info = 0. If you need another value, use <a class="el" href="classXfc_1_1Gtk_1_1TargetList.html#5d2628b83fabbeef121c9fe6001db2ec">Gtk::TargetList::add_uri_targets()</a> and <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bcb24f0893df9d780ab14fafdfc54617">drag_source_set_target_list()</a>. 
</div>
</div><p>
<a class="anchor" name="4677eb2ca573372914e54d7c092677e6"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_set_icon" ref="4677eb2ca573372914e54d7c092677e6" args="(Gdk::Colormap *colormap, Gdk::Pixmap *pixmap, Gdk::Bitmap *mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_source_set_icon           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a> *&nbsp;</td>
          <td class="paramname"> <em>colormap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Pixmap.html">Gdk::Pixmap</a> *&nbsp;</td>
          <td class="paramname"> <em>pixmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Bitmap.html">Gdk::Bitmap</a> *&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the icon that will be used for drags from the widget from a pixmap and mask. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>colormap</em>&nbsp;</td><td>The colormap of the icon. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixmap</em>&nbsp;</td><td>The image data for the icon. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The transparency mask for an image.</td></tr>
  </table>
</dl>
GTK+ retains references for the arguments, and will release them when they are no longer needed. Use <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#77a9552dd400cce6f32afdd54872c754">drag_source_set_icon_pixbuf()</a> instead. 
</div>
</div><p>
<a class="anchor" name="77a9552dd400cce6f32afdd54872c754"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_set_icon_pixbuf" ref="77a9552dd400cce6f32afdd54872c754" args="(Gdk::Pixbuf &amp;pixbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_source_set_icon_pixbuf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pixbuf</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the icon that will be used for drags from the widget from a <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixbuf</em>&nbsp;</td><td>The <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> for the drag icon.</td></tr>
  </table>
</dl>
GTK+ retains references for pixbuf, and will release it when it is no longer needed. 
</div>
</div><p>
<a class="anchor" name="511294fc062823570e5ca161821f2f9a"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_source_set_icon_stock" ref="511294fc062823570e5ca161821f2f9a" args="(const StockId &amp;stock_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Widget::drag_source_set_icon_stock           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gtk_1_1StockId.html">StockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stock_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the icon that will be used for drags from the widget to a stock icon. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stock_id</em>&nbsp;</td><td>The stock ID of the icon to use. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4f0ef4f0527cda399e34515d7e64bd5c"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_check_threshold" ref="4f0ef4f0527cda399e34515d7e64bd5c" args="(int start_x, int start_y, int current_x, int current_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Widget::drag_check_threshold           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>current_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>current_y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks to see if a mouse drag starting at (start_x, start_y) and ending at (current_x, current_y) has passed the GTK+ drag threshhold, and thus should trigger the beginning of a drag-and-drop operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_x</em>&nbsp;</td><td>The X coordinate of start of drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_y</em>&nbsp;</td><td>The Y coordinate of start of drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>current_x</em>&nbsp;</td><td>The current X coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>current_y</em>&nbsp;</td><td>The current Y coordinate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the drag threshold has been passed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8782d715f5659ce928cb77471655d25d"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_hierarchy_changed" ref="8782d715f5659ce928cb77471655d25d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">HierarchyChangedSignalProxy</a> Xfc::Gtk::Widget::signal_hierarchy_changed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the hierarchy_changed_signal; emitted when there is a change in the hierarchy to which the widget belongs. 
<p>
More precisely, when its toplevel ancestor changes. 
</div>
</div><p>
<a class="anchor" name="ed1fc79786f01158aad15d3f158543ac"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_child_notify" ref="ed1fc79786f01158aad15d3f158543ac" args="(const String &amp;property_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">ChildNotifySignalProxy</a> Xfc::Gtk::Widget::signal_child_notify           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>property_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the child_notify_signal; emitted for each child property that changes on a widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property_name</em>&nbsp;</td><td>The property name to be notified of changes to.</td></tr>
  </table>
</dl>
If <em>property_name</em> is provided it is appended to the signal name so that the signal connected to becomes "child_notify::property_name". What this does is ensure that your child notification slot is only called if <em>property_name</em> matches the property name of the "child_notify" signal being emitted. 
</div>
</div><p>
<a class="anchor" name="24506eee68b25c3e547567d0b25870bc"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_accel_closures_changed" ref="24506eee68b25c3e547567d0b25870bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">AccelClosuresChangedSignalProxy</a> Xfc::Gtk::Widget::signal_accel_closures_changed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the accel_closures_changed_signal; emitted whenever the closures used by the widget for accelerator group connections are changed. 
<p>
The closures can be used to monitor accelerator changes on widget. 
</div>
</div><p>
<a class="anchor" name="f674928b0bba76b663b73a74c11c4f05"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_drag_begin" ref="f674928b0bba76b663b73a74c11c4f05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragBeginSignalProxy</a> Xfc::Gtk::Widget::signal_drag_begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the drag_begin_signal; emitted on the drag source when a drag is started. 
<p>
A typical reason to connect to this signal is to set up a custom drag icon with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4677eb2ca573372914e54d7c092677e6">drag_source_set_icon()</a>. 
</div>
</div><p>
<a class="anchor" name="422589e89a6e3fac29aa85106520ee43"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_drag_end" ref="422589e89a6e3fac29aa85106520ee43" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragEndSignalProxy</a> Xfc::Gtk::Widget::signal_drag_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the drag_end_signal; emitted on the drag source when a drag is finished. 
<p>
A typical reason to connect to this signal is to undo things done in <em>drag_begin</em>. 
</div>
</div><p>
<a class="anchor" name="eaa9d9fe2067490340754642e0b2fc57"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_drag_data_get" ref="eaa9d9fe2067490340754642e0b2fc57" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragDataGetSignalProxy</a> Xfc::Gtk::Widget::signal_drag_data_get           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the drag_data_get_signal; emitted on the drag source when the drop site requests the data of the first target supported. 
<p>
It is the responsibility of the signal handler to fill <a class="el" href="classXfc_1_1Gtk_1_1SelectionData.html">Gtk::SelectionData</a> with the data in the format which is indicated by <em>info</em> (third) argument (see <a class="el" href="classXfc_1_1Gtk_1_1SelectionData.html#aa77b331f27f066b0e5dc3cbff87b369">Gtk::SelectionData::set()</a> and Gtk::SelectionData::set_text()). 
</div>
</div><p>
<a class="anchor" name="e44064466ce0490a3de74dbd4fc70b5b"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_drag_data_delete" ref="e44064466ce0490a3de74dbd4fc70b5b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragDataDeleteSignalProxy</a> Xfc::Gtk::Widget::signal_drag_data_delete           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the drag_data_delete_signal; emitted on the drag source when a drag with the action <a class="el" href="namespaceXfc_1_1Gdk.html#cdc94d623b0fc1294b910d9fdbbf8086e8007ba2985ccbc3b43ef697df40f312">Gdk::ACTION_MOVE</a> is successfully completed. 
<p>
It indicates that the data can be deleted. 
</div>
</div><p>
<a class="anchor" name="6736edea849737ae7f96065097752e17"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_drag_leave" ref="6736edea849737ae7f96065097752e17" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragLeaveSignalProxy</a> Xfc::Gtk::Widget::signal_drag_leave           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the drag_leave_signal; emitted on the drop site when the cursor leaves the widget. 
<p>
A typical reason to connect to this signal is to undo things done in <em>drag_motion</em>, e.g. undo highlighting with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fedcbabc8fc4c676ca84d67a27a49b26">drag_unhighlight()</a>. 
</div>
</div><p>
<a class="anchor" name="ec4e37a70a1d71665a170506e0a22968"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_drag_motion" ref="ec4e37a70a1d71665a170506e0a22968" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragMotionSignalProxy</a> Xfc::Gtk::Widget::signal_drag_motion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the drag_motion_signal; emitted on the drop site when the user moves the cursor over the widget during a drag. 
<p>
The signal handler must determine whether the cursor position is in a drop zone or not. If it is not in a drop zone, it returns <em>false</em> and no further processing is necessary. Otherwise, the handler returns <em>true</em>. In this case, the handler is responsible for providing the necessary information for displaying feedback to the user, by calling <a class="el" href="classXfc_1_1Gdk_1_1DragContext.html#b49a6f8e70c65a47cd568cf68909ba8b">Gdk::DragContext::drag_status()</a>. If the decision whether the drop will be accepted or rejected can't be made based solely on the cursor position and the type of the data, the handler may inspect the dragged data by calling <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#55ec947a7bf19e2a54804560dd972d56">drag_get_data()</a> and defer the <a class="el" href="classXfc_1_1Gdk_1_1DragContext.html#b49a6f8e70c65a47cd568cf68909ba8b">Gdk::DragContext::drag_status()</a> call to the <em>drag_data_received</em> signal handler.<p>
Note that there is no <em>drag_enter</em> signal. The drag receiver has to keep track of whether he has received any <em>drag_motion</em> signals since the last <em>drag_leave</em> and if not, treat the <em>drag_motion</em> signal as an "enter" signal. Upon an "enter", the handler will typically highlight the drop site with <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0c9f1821383f18786feeca063d0df314">drag_highlight()</a>. 
</div>
</div><p>
<a class="anchor" name="d75dc38d611ba871eddde651d6148dd0"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_drag_drop" ref="d75dc38d611ba871eddde651d6148dd0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragDropSignalProxy</a> Xfc::Gtk::Widget::signal_drag_drop           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the drag_drop_signal; emitted on the drop site when the user drops the data onto the widget. 
<p>
The signal handler must determine whether the cursor position is in a drop zone or not. If it is not in a drop zone, it returns <em>false</em> and no further processing is necessary. Otherwise, the handler returns <em>true</em>. In this case, the handler must ensure that <a class="el" href="classXfc_1_1Gtk_1_1DragContext.html#a65b54004e7fd4794af493d0a305f694">Gtk::DragContext::finish()</a> is called to let the source know that the drop is done. The call to <a class="el" href="classXfc_1_1Gtk_1_1DragContext.html#a65b54004e7fd4794af493d0a305f694">Gtk::DragContext::finish()</a> can be done either directly or in a <em>drag_data_received</em> handler which gets triggered by calling <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#55ec947a7bf19e2a54804560dd972d56">drag_get_data()</a> to receive the data for one or more of the supported targets. 
</div>
</div><p>
<a class="anchor" name="290df63fa2eceaa768f3489c290ca6b5"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_drag_data_received" ref="290df63fa2eceaa768f3489c290ca6b5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">DragDataReceivedSignalProxy</a> Xfc::Gtk::Widget::signal_drag_data_received           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the drag_data_received_signal; emitted on the drop site when the dragged data has been received. 
<p>
If the data was received in order to determine whether the drop will be accepted, the handler is expected to call <a class="el" href="classXfc_1_1Gdk_1_1DragContext.html#b49a6f8e70c65a47cd568cf68909ba8b">Gdk::DragContext::drag_status()</a> and <em>not</em> finish the drag. If the data was received in response to a <em>drag_drop</em> signal (and this is the last target to be received), the handler for this signal is expected to process the received data and then call <a class="el" href="classXfc_1_1Gtk_1_1DragContext.html#a65b54004e7fd4794af493d0a305f694">Gtk::DragContext::finish()</a>, setting the <em>success</em> parameter depending on whether the data was processed successfully.<p>
The handler may inspect and modify the drag action chosen by the drop site by calling Gdk::DragContext()action() and Gdk::DragContext()set_action() before calling <a class="el" href="classXfc_1_1Gtk_1_1DragContext.html#a65b54004e7fd4794af493d0a305f694">Gtk::DragContext::finish()</a>. 
</div>
</div><p>
<a class="anchor" name="82454f65f975154fb0eba5bda1c67bf8"></a><!-- doxytag: member="Xfc::Gtk::Widget::signal_event_after" ref="82454f65f975154fb0eba5bda1c67bf8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">EventAfterSignalProxy</a> Xfc::Gtk::Widget::signal_event_after           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the event_after_signal; emitted after any GDK event occurs. 
<p>
This signal is used to observe events but not act on them. Hence the void return value. This signal exists because slots connected to events as 'after' handlers get called after the default handler, but if the signal was handled they wont get called. Connect to this signal if you just want to monitor GDK events. 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="6f29c6dba8b19ed7d538c756f9de8596"></a><!-- doxytag: member="Xfc::Gtk::Widget::show_signal" ref="6f29c6dba8b19ed7d538c756f9de8596" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ShowSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6f29c6dba8b19ed7d538c756f9de8596">Xfc::Gtk::Widget::show_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#17bfc7dce72663c026e19b602eeb3250">signal_show()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="88ad1552b5c4781a4c6a02f1fdb8190f"></a><!-- doxytag: member="Xfc::Gtk::Widget::hide_signal" ref="88ad1552b5c4781a4c6a02f1fdb8190f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">HideSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#88ad1552b5c4781a4c6a02f1fdb8190f">Xfc::Gtk::Widget::hide_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hide signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5e0419fe1123d2f657622a16f2c68655">signal_hide()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="6fda631b20d7d2aa0785fd9f8df950f0"></a><!-- doxytag: member="Xfc::Gtk::Widget::map_signal" ref="6fda631b20d7d2aa0785fd9f8df950f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">MapSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6fda631b20d7d2aa0785fd9f8df950f0">Xfc::Gtk::Widget::map_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Map signal (see signal_Map()). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="3254863ec7cddf5b9e2d8138500f1e28"></a><!-- doxytag: member="Xfc::Gtk::Widget::unmap_signal" ref="3254863ec7cddf5b9e2d8138500f1e28" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">UnmapSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#3254863ec7cddf5b9e2d8138500f1e28">Xfc::Gtk::Widget::unmap_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unmap signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#22e73a422f40d2b1660f90e7687e91a6">signal_unmap()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="4afcd174ead1473d028c5d0be7f6397c"></a><!-- doxytag: member="Xfc::Gtk::Widget::realize_signal" ref="4afcd174ead1473d028c5d0be7f6397c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">RealizeSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#4afcd174ead1473d028c5d0be7f6397c">Xfc::Gtk::Widget::realize_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Realize signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8d659e300502b77e3c7b574715995152">signal_realize()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="c0cb44f462e66e1dffb6fd80f57625ce"></a><!-- doxytag: member="Xfc::Gtk::Widget::unrealize_signal" ref="c0cb44f462e66e1dffb6fd80f57625ce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">UnrealizeSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c0cb44f462e66e1dffb6fd80f57625ce">Xfc::Gtk::Widget::unrealize_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unrealize signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f4fdcba7d93e60aeaf2b758cfd47bd6b">signal_unrealize()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="bc57450a1276b628b7393cd4a0381def"></a><!-- doxytag: member="Xfc::Gtk::Widget::size_request_signal" ref="bc57450a1276b628b7393cd4a0381def" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">SizeRequestSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bc57450a1276b628b7393cd4a0381def">Xfc::Gtk::Widget::size_request_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size request signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#0e76cfeed6840141b05345daf11b6f62">signal_size_request()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(Requisition *requisition);
&lt; <span class="comment">// requisition: The Requisition to be filled in.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="dd0e58f8a734f59df665ee8d66a8a2d5"></a><!-- doxytag: member="Xfc::Gtk::Widget::size_allocate_signal" ref="dd0e58f8a734f59df665ee8d66a8a2d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">SizeAllocateSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dd0e58f8a734f59df665ee8d66a8a2d5">Xfc::Gtk::Widget::size_allocate_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size allocate signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#51b3efb74adc317fe9f70c885f9e61d9">signal_size_allocate()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<span class="keyword">const</span> Allocation&amp; allocation);
&lt; <span class="comment">// allocation: The position and size allocated to the widget.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="81b8c1e825681f3d572e3248b5d04ccb"></a><!-- doxytag: member="Xfc::Gtk::Widget::state_changed_signal" ref="81b8c1e825681f3d572e3248b5d04ccb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">StateChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#81b8c1e825681f3d572e3248b5d04ccb">Xfc::Gtk::Widget::state_changed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
State changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#176778d4af5613922959db3cf8c8e464">signal_state_changed()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<a class="code" href="namespaceXfc_1_1Gtk.html#4dc04eb5d6b0e7a2516a3b0199b4e56d">StateType</a> previous_state);
&lt; <span class="comment">// previous_state: The previous StateType.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="177afd65eb2a95669e229dad495da33d"></a><!-- doxytag: member="Xfc::Gtk::Widget::parent_set_signal" ref="177afd65eb2a95669e229dad495da33d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ParentSetSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#177afd65eb2a95669e229dad495da33d">Xfc::Gtk::Widget::parent_set_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parent set signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6a39e540da54e4f10b6748c4d463e818">signal_parent_set()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function((<a class="code" href="classXfc_1_1Gtk_1_1Widget.html#795fe42510abe2c532bfee98211b6005">Widget</a> *previous_parent);
&lt; <span class="comment">// previous_parent: The previous parent of the widget, or null.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="1417a39363c1ad1fc3b9c3998a7ff056"></a><!-- doxytag: member="Xfc::Gtk::Widget::hierarchy_changed_signal" ref="1417a39363c1ad1fc3b9c3998a7ff056" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">HierarchyChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1417a39363c1ad1fc3b9c3998a7ff056">Xfc::Gtk::Widget::hierarchy_changed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hierarchy changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8782d715f5659ce928cb77471655d25d">signal_hierarchy_changed()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<a class="code" href="classXfc_1_1Gtk_1_1Widget.html#795fe42510abe2c532bfee98211b6005">Widget</a> *previous_toplevel);
&lt; <span class="comment">// previous_toplevel: The previous toplevel widget.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="1e5c6d696d20004c06894e9e44bff571"></a><!-- doxytag: member="Xfc::Gtk::Widget::style_set_signal" ref="1e5c6d696d20004c06894e9e44bff571" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">StyleSetSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#1e5c6d696d20004c06894e9e44bff571">Xfc::Gtk::Widget::style_set_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classXfc_1_1Gtk_1_1Style.html">Style</a> set signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2bfd96313f6c2ff17bf929a472e4c953">signal_style_set()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<a class="code" href="namespaceXfc_1_1Pango.html#737eb282276ed9e900ecb39f45c3eaa2">Style</a>* previous_style);
&lt; <span class="comment">// previous_style: The previous Style, or null.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="548ed98d46be28498725aa4288273456"></a><!-- doxytag: member="Xfc::Gtk::Widget::direction_changed_signal" ref="548ed98d46be28498725aa4288273456" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DirectionChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#548ed98d46be28498725aa4288273456">Xfc::Gtk::Widget::direction_changed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Direction changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#84b7eac2845461af36647331d6c1a916">signal_direction_changed()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<a class="code" href="namespaceXfc_1_1Gtk.html#a0e16bc97f4e6e915aab3365d7f8d6c4">TextDirection</a>  previous_direction);
&lt; <span class="comment">// previous_direction: The previous direction.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="c6d4ac6535351113e64a21da840a1c8e"></a><!-- doxytag: member="Xfc::Gtk::Widget::grab_notify_signal" ref="c6d4ac6535351113e64a21da840a1c8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">GrabNotifySignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c6d4ac6535351113e64a21da840a1c8e">Xfc::Gtk::Widget::grab_notify_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grab notify signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b4a24972d1e208a45662ab9ec2f78601">signal_grab_notify()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<span class="keywordtype">bool</span> was_grabbed);
&lt; <span class="comment">// was_grabbed: true if the widget is the current grabbed widget, false</span>
&lt; <span class="comment">//              if it was but is no longer the current grabbed widget.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="ce6ef6a7cd9c70e3b335e157c8738d05"></a><!-- doxytag: member="Xfc::Gtk::Widget::child_notify_signal" ref="ce6ef6a7cd9c70e3b335e157c8738d05" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ChildNotifySignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ce6ef6a7cd9c70e3b335e157c8738d05">Xfc::Gtk::Widget::child_notify_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Child notify signal (see signal_child_notify()). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(GParamSpec *pspec);
&lt; <span class="comment">// pspec: A GParamSpec object that holds the meta data specifying the new property.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="2554b1654f387651af404f2a4d120236"></a><!-- doxytag: member="Xfc::Gtk::Widget::mnemonic_activate_signal" ref="2554b1654f387651af404f2a4d120236" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">MnemonicActivateSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2554b1654f387651af404f2a4d120236">Xfc::Gtk::Widget::mnemonic_activate_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mnemonic activate signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a317d321cc1d783a695b3732cdf24cac">signal_mnemonic_activate()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keywordtype">bool</span> group_cycling);
&lt; <span class="comment">// group_cycling:</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="8f0cc552475e98ebf01671cbdd52f155"></a><!-- doxytag: member="Xfc::Gtk::Widget::grab_focus_signal" ref="8f0cc552475e98ebf01671cbdd52f155" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">GrabFocusSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#8f0cc552475e98ebf01671cbdd52f155">Xfc::Gtk::Widget::grab_focus_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grab focus signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#97d7b5c2f7406b4ffb2774e3c60217b1">signal_grab_focus()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="37d2a04e192616035e29f38899b8da40"></a><!-- doxytag: member="Xfc::Gtk::Widget::focus_signal" ref="37d2a04e192616035e29f38899b8da40" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">FocusSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#37d2a04e192616035e29f38899b8da40">Xfc::Gtk::Widget::focus_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Focus signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#af8b5100dae6718f1185ce4bd3ed42fd">signal_focus()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<a class="code" href="namespaceXfc_1_1Gtk.html#cb399182c672579f9bce45564fabd10f">DirectionType</a> direction);
&lt; <span class="comment">// direction: The direction of focus movement.</span>
&lt; <span class="comment">// return: true if the focus ended up inside the child widget.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="9252b7c75fe5cfeb01c5276760139290"></a><!-- doxytag: member="Xfc::Gtk::Widget::accel_closures_changed_signal" ref="9252b7c75fe5cfeb01c5276760139290" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">AccelClosuresChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9252b7c75fe5cfeb01c5276760139290">Xfc::Gtk::Widget::accel_closures_changed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accel closures changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#24506eee68b25c3e547567d0b25870bc">signal_accel_closures_changed()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="e13d1d516306242e5e57fc42696d6c83"></a><!-- doxytag: member="Xfc::Gtk::Widget::screen_changed_signal" ref="e13d1d516306242e5e57fc42696d6c83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ScreenChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e13d1d516306242e5e57fc42696d6c83">Xfc::Gtk::Widget::screen_changed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Screen changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dda4ec70b68830e4615e62acebd55768">signal_screen_changed()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(Gdk::Screen *previous_screen);
&lt; <span class="comment">// previous_screen: The previous Gdk:Screen.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="cdf68baf8311ab9e0bf49edcc789592f"></a><!-- doxytag: member="Xfc::Gtk::Widget::can_activate_accel_signal" ref="cdf68baf8311ab9e0bf49edcc789592f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">CanActivateAccelSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#cdf68baf8311ab9e0bf49edcc789592f">Xfc::Gtk::Widget::can_activate_accel_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Can activate accel signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#adee8af211cce0b2d50a22192bdfbb0b">signal_can_activate_accel()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> signal_id);
&lt; <span class="comment">// signal_id: The id of a signal installed on the widget.</span>
&lt; <span class="comment">// return: true if the accelerator can be activated.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="122965a21d3133a2104520f9d6823780"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_get_signal" ref="122965a21d3133a2104520f9d6823780" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">SelectionGetSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#122965a21d3133a2104520f9d6823780">Xfc::Gtk::Widget::selection_get_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selection get signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#dc96a76c3c51e340bcb46c8a94bb5d6c">signal_selection_get()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(SelectionData&amp; selection_data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> info, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time);
&lt; <span class="comment">// selection_data: The SelectionData object to be filled in.</span>
&lt; <span class="comment">// info: The info integer that was set when the target was registered (see TargetEntry).</span>
&lt; <span class="comment">// time: The time of the conversion request as set by the requestor with selectionn_convert().</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="9ec6d213e5536261aba62cf6fb27a2dc"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_received_signal" ref="9ec6d213e5536261aba62cf6fb27a2dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">SelectionReceivedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#9ec6d213e5536261aba62cf6fb27a2dc">Xfc::Gtk::Widget::selection_received_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selection received signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#58e569723fdbb064e9b52d75a8bf3b40">signal_selection_received()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<span class="keyword">const</span> SelectionData&amp; selection_data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time);
&lt; <span class="comment">// selection_data: The requested selection data.</span>
&lt; <span class="comment">// time: The time of the conversion request.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="d57e146d14d494c238823747a4d4667d"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_begin_signal" ref="d57e146d14d494c238823747a4d4667d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragBeginSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d57e146d14d494c238823747a4d4667d">Xfc::Gtk::Widget::drag_begin_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drag begin signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f674928b0bba76b663b73a74c11c4f05">signal_drag_begin()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(DragContext&amp; context);
&lt; <span class="comment">// context: A reference to a Gtk::DragContext (only used by GTK+).</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="ef47733a5035ea40a3dd6363c1ba04a5"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_end_signal" ref="ef47733a5035ea40a3dd6363c1ba04a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragEndSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ef47733a5035ea40a3dd6363c1ba04a5">Xfc::Gtk::Widget::drag_end_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drag end signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#422589e89a6e3fac29aa85106520ee43">signal_drag_end()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(DragContext&amp; context);
&lt; <span class="comment">// context: A reference to a Gtk::DragContext (only used by GTK+).</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="7cea22c9c449f183d4775d0ccfde82b0"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_data_get_signal" ref="7cea22c9c449f183d4775d0ccfde82b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragDataGetSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#7cea22c9c449f183d4775d0ccfde82b0">Xfc::Gtk::Widget::drag_data_get_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drag data get signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#eaa9d9fe2067490340754642e0b2fc57">signal_drag_data_get()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(DragContext&amp; context, SelectionData&amp; data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> info, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time);
&lt; <span class="comment">// context: A reference to a Gtk::DragContext (only used by GTK+).</span>
&lt; <span class="comment">// data: The SelectionData that needs to be filled in to provide the requested data.</span>
&lt; <span class="comment">// info: The info integer that was set when the target was registered (see TargertEntry).</span>
&lt; <span class="comment">// time: The time of the conversion request.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="49ed703724ccf0faa93bdf92d8d7c11e"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_data_delete_signal" ref="49ed703724ccf0faa93bdf92d8d7c11e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragDataDeleteSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#49ed703724ccf0faa93bdf92d8d7c11e">Xfc::Gtk::Widget::drag_data_delete_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drag data delete signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e44064466ce0490a3de74dbd4fc70b5b">signal_drag_data_delete()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(DragContext&amp; context);
&lt; <span class="comment">// context: A reference to a Gtk::DragContext (only used by GTK+).</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="17930903ab58c6599fcbcf3636f105fa"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_leave_signal" ref="17930903ab58c6599fcbcf3636f105fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragLeaveSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#17930903ab58c6599fcbcf3636f105fa">Xfc::Gtk::Widget::drag_leave_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drag leave signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6736edea849737ae7f96065097752e17">signal_drag_leave()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(DragContext&amp; context, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time);
&lt; <span class="comment">// context: A reference to the Gtk::DragContext for the current drag-and-drop event.</span>
&lt; <span class="comment">// time: The timestamp of the motion event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="fb7c6cbccea83645a10d40640637c816"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_motion_signal" ref="fb7c6cbccea83645a10d40640637c816" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragMotionSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fb7c6cbccea83645a10d40640637c816">Xfc::Gtk::Widget::drag_motion_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drag motion signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ec4e37a70a1d71665a170506e0a22968">signal_drag_motion()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(DragContext&amp; context, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time);
&lt; <span class="comment">// context: A reference to the Gtk::DragContext for the current drag-and-drop event.</span>
&lt; <span class="comment">// x: The X position of the mouse pointer relative to the widget.</span>
&lt; <span class="comment">// y: The Y position of the mouse pointer relative to the widget.</span>
&lt; <span class="comment">// time: The time when the event occurred.</span>
&lt; <span class="comment">// return: true if the widget is a valid drag-and-drop destination.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="b08ee7cf7fce79771dca93202f7cbcb6"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_drop_signal" ref="b08ee7cf7fce79771dca93202f7cbcb6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragDropSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b08ee7cf7fce79771dca93202f7cbcb6">Xfc::Gtk::Widget::drag_drop_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drag drop signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d75dc38d611ba871eddde651d6148dd0">signal_drag_drop()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(DragContext&amp; context, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time);
&lt; <span class="comment">// context: A reference to the Gtk::DragContext for the current drag-and-drop event.</span>
&lt; <span class="comment">// x: The X position of the mouse pointer relative to the widget.</span>
&lt; <span class="comment">// y: The Y position of the mouse pointer relative to the widget.</span>
&lt; <span class="comment">// time: The time when the event occurred.</span>
&lt; <span class="comment">// return: true if the widget is a valid drag-and-drop destination.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="33957a279a6f714caedafacaece5a271"></a><!-- doxytag: member="Xfc::Gtk::Widget::drag_data_received_signal" ref="33957a279a6f714caedafacaece5a271" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DragDataReceivedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#33957a279a6f714caedafacaece5a271">Xfc::Gtk::Widget::drag_data_received_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drag data received signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#290df63fa2eceaa768f3489c290ca6b5">signal_drag_data_received()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(DragContext&amp; context, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keyword">const</span> SelectionData&amp; data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> info, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time);
&lt; <span class="comment">// context: A reference to a Gtk::DragContext.</span>
&lt; <span class="comment">// x: The X position of the mouse pointer relative to the widget. </span>
&lt; <span class="comment">// y: The Y position of the mouse pointer relative to the widget. </span>
&lt; <span class="comment">// data: The SelectionData that contains all the information about the data received.</span>
&lt; <span class="comment">// info: The info integer that was set when the target was registered (see TargertEntry).</span>
&lt; <span class="comment">// time: The time of the conversion request.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="945661eec99a08746a55151307cd3179"></a><!-- doxytag: member="Xfc::Gtk::Widget::event_signal" ref="945661eec99a08746a55151307cd3179" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">EventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#945661eec99a08746a55151307cd3179">Xfc::Gtk::Widget::event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#94b859cf217745a51e8bf2d5344deeed">signal_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::Event&amp; event);
&lt; <span class="comment">// event: The Gdk::Event.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="86046864ecf8d1374a4d5b8e51453022"></a><!-- doxytag: member="Xfc::Gtk::Widget::event_after_signal" ref="86046864ecf8d1374a4d5b8e51453022" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">EventAfterSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#86046864ecf8d1374a4d5b8e51453022">Xfc::Gtk::Widget::event_after_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event after signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#82454f65f975154fb0eba5bda1c67bf8">signal_event_after()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<span class="keyword">const</span> Gdk::Event&amp; event);
&lt; <span class="comment">// event: The Gdk::Event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="f0d5a35af13f4d50f138be9411219523"></a><!-- doxytag: member="Xfc::Gtk::Widget::button_press_event_signal" ref="f0d5a35af13f4d50f138be9411219523" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ButtonPressEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f0d5a35af13f4d50f138be9411219523">Xfc::Gtk::Widget::button_press_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classXfc_1_1Gtk_1_1Button.html">Button</a> press event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#29fe506a596b4dd2ba9587f36856c295">signal_button_press_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventButton&amp; event);
&lt; <span class="comment">// event: The Gdk::EventButton.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="a5b3b1cd485d38403697d1f4c27c32cf"></a><!-- doxytag: member="Xfc::Gtk::Widget::button_release_event_signal" ref="a5b3b1cd485d38403697d1f4c27c32cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ButtonReleaseEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a5b3b1cd485d38403697d1f4c27c32cf">Xfc::Gtk::Widget::button_release_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classXfc_1_1Gtk_1_1Button.html">Button</a> release event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e64acae5ede5633c48a71db725073ae4">signal_button_release_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventButton&amp; event);
&lt; <span class="comment">// event: The Gdk::EventButton.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="c2e45a31f5691888e708429ea4eadc99"></a><!-- doxytag: member="Xfc::Gtk::Widget::scroll_event_signal" ref="c2e45a31f5691888e708429ea4eadc99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ScrollEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c2e45a31f5691888e708429ea4eadc99">Xfc::Gtk::Widget::scroll_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scroll event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#53ad3abad2d53e759f2b4d094a848faf">signal_scroll_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventScroll&amp; event);
&lt; <span class="comment">// event: The Gdk::EventScroll.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="155da826283bd1a8f9f6eb7c2ef4b8af"></a><!-- doxytag: member="Xfc::Gtk::Widget::motion_notify_event_signal" ref="155da826283bd1a8f9f6eb7c2ef4b8af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">MotionNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#155da826283bd1a8f9f6eb7c2ef4b8af">Xfc::Gtk::Widget::motion_notify_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Motion notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#615730e9863688c17e3b59bd8fe555e6">signal_motion_notify_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventMotion&amp; event);
&lt; <span class="comment">// event: The Gdk::EventMotion.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="3e53cb2132ea42e28113b4467b9b804e"></a><!-- doxytag: member="Xfc::Gtk::Widget::delete_event_signal" ref="3e53cb2132ea42e28113b4467b9b804e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DeleteEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#3e53cb2132ea42e28113b4467b9b804e">Xfc::Gtk::Widget::delete_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d9f60271ae6ab5a596cd5603e37054ca">signal_delete_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventAny&amp; event);
&lt; <span class="comment">// event: The Gdk::Event.</span>
&lt; <span class="comment">// return: false to allow the application window to close.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="e3cd13a015fd917162aa302327906f2b"></a><!-- doxytag: member="Xfc::Gtk::Widget::destroy_event_signal" ref="e3cd13a015fd917162aa302327906f2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">DestroyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e3cd13a015fd917162aa302327906f2b">Xfc::Gtk::Widget::destroy_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#96511ba76557b4fb334cedaae683af0e">signal_destroy_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventAny&amp; event);
&lt; <span class="comment">// event: The Gdk::EventAny.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="fcdf427515d7dac9d214fc76243c1094"></a><!-- doxytag: member="Xfc::Gtk::Widget::expose_event_signal" ref="fcdf427515d7dac9d214fc76243c1094" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ExposeEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#fcdf427515d7dac9d214fc76243c1094">Xfc::Gtk::Widget::expose_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Expose event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#49c2b89395ef7816abcc45b6e5d3b4a0">signal_expose_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventExpose&amp; event);
&lt; <span class="comment">// event: The Gdk::EventExpose.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="d0f1c73c5ea5a418aaa0be6f383aeb36"></a><!-- doxytag: member="Xfc::Gtk::Widget::key_press_event_signal" ref="d0f1c73c5ea5a418aaa0be6f383aeb36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">KeyPressEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d0f1c73c5ea5a418aaa0be6f383aeb36">Xfc::Gtk::Widget::key_press_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Key press event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a4f274e1336592abc88c5b88cc011250">signal_key_press_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventKey&amp; event);
&lt; <span class="comment">// event: The Gdk::EventKey.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="c929e677fd2b77931e30cf92da78220a"></a><!-- doxytag: member="Xfc::Gtk::Widget::key_release_event_signal" ref="c929e677fd2b77931e30cf92da78220a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">KeyReleaseEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c929e677fd2b77931e30cf92da78220a">Xfc::Gtk::Widget::key_release_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Key release event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#d1701b246d69c2f7be75ce1989c3c6ba">signal_key_release_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventKey&amp; event);
&lt; <span class="comment">// event: The Gdk::EventKey.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="038fdae9c71dc9a4268a90204bff4edf"></a><!-- doxytag: member="Xfc::Gtk::Widget::enter_notify_event_signal" ref="038fdae9c71dc9a4268a90204bff4edf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">EnterNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#038fdae9c71dc9a4268a90204bff4edf">Xfc::Gtk::Widget::enter_notify_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enter notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f002eee0271857b758fa83402eaa8e88">signal_enter_notify_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventCrossing&amp; event);
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="f2c4dfa1cbd086eea346eb17f0cd878c"></a><!-- doxytag: member="Xfc::Gtk::Widget::leave_notify_event_signal" ref="f2c4dfa1cbd086eea346eb17f0cd878c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">LeaveNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f2c4dfa1cbd086eea346eb17f0cd878c">Xfc::Gtk::Widget::leave_notify_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Leave notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2cfa16cdff20f7922480ef1c690e72a7">signal_leave_notify_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventCrossing&amp; event);
&lt; <span class="comment">// event: The Gdk::EventCrossing.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="55dc27b89136915626f0e9b1793c4acc"></a><!-- doxytag: member="Xfc::Gtk::Widget::configure_event_signal" ref="55dc27b89136915626f0e9b1793c4acc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ConfigureEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#55dc27b89136915626f0e9b1793c4acc">Xfc::Gtk::Widget::configure_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configure event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#44489a74e958dabe17016828b55cea3f">signal_configure_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventConfigure&amp; event);
&lt; <span class="comment">// event: The Gdk::EventConfigure.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="c12ebb0b6b58e8575ceb14f1eb1db78a"></a><!-- doxytag: member="Xfc::Gtk::Widget::focus_in_event_signal" ref="c12ebb0b6b58e8575ceb14f1eb1db78a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">FocusInEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#c12ebb0b6b58e8575ceb14f1eb1db78a">Xfc::Gtk::Widget::focus_in_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Focus in event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#a4f0f1a9bf07c14b919327ca6fb0b915">signal_focus_in_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventFocus&amp; event);
&lt; <span class="comment">// event: The Gdk::EventFocus.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="6b27bf4402005431100ca4e33a5b7b8a"></a><!-- doxytag: member="Xfc::Gtk::Widget::focus_out_event_signal" ref="6b27bf4402005431100ca4e33a5b7b8a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">FocusOutEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#6b27bf4402005431100ca4e33a5b7b8a">Xfc::Gtk::Widget::focus_out_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Focus out event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#b8da2eb022bd51e7bdb2a3e56136751c">signal_focus_out_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventFocus&amp; event);
&lt; <span class="comment">// event: The Gdk::EventFocus.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="202bf743f5670b6bb93e66d9a388b734"></a><!-- doxytag: member="Xfc::Gtk::Widget::map_event_signal" ref="202bf743f5670b6bb93e66d9a388b734" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">MapEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#202bf743f5670b6bb93e66d9a388b734">Xfc::Gtk::Widget::map_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Map event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2c3d1f74275ef213a4e29924bb908257">signal_map_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventAny&amp; event);
&lt; <span class="comment">// event: The Gdk::EventAny.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="ba6066189411962d92d607206602b56c"></a><!-- doxytag: member="Xfc::Gtk::Widget::unmap_event_signal" ref="ba6066189411962d92d607206602b56c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">UnmapEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#ba6066189411962d92d607206602b56c">Xfc::Gtk::Widget::unmap_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unmap event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#297ca5a50d37ee22a446b7154949b35e">signal_unmap_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventAny&amp; event);
&lt; <span class="comment">// event: The Gdk::EventAny.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="eace3f2fe9b1a7c7091530c02d0fd3f9"></a><!-- doxytag: member="Xfc::Gtk::Widget::property_notify_event_signal" ref="eace3f2fe9b1a7c7091530c02d0fd3f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">PropertyNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#eace3f2fe9b1a7c7091530c02d0fd3f9">Xfc::Gtk::Widget::property_notify_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Property notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#de929461102ab0c0d90ce22a640d998b">signal_property_notify_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventProperty&amp; event);
&lt; <span class="comment">// event: The Gdk::EventProperty.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="2363cf2758916625e5d6736dd471c21a"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_clear_event_signal" ref="2363cf2758916625e5d6736dd471c21a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">SelectionClearEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2363cf2758916625e5d6736dd471c21a">Xfc::Gtk::Widget::selection_clear_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selection clear event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#5a13503cffa1a17ac3eaf466ac4b2e81">signal_selection_clear_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventSelection&amp; event);
&lt; <span class="comment">// event: The Gdk::EventSelection.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="bbbdeb9079eb679b8315a83d81420dbe"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_request_event_signal" ref="bbbdeb9079eb679b8315a83d81420dbe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">SelectionRequestEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#bbbdeb9079eb679b8315a83d81420dbe">Xfc::Gtk::Widget::selection_request_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selection request event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#297deef498809d3cf1616e5c8d37d09f">signal_selection_request_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventSelection&amp; event);
&lt; <span class="comment">// event: The Gdk::EventSelection.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="217e18844168ab9954fa32fb504b913b"></a><!-- doxytag: member="Xfc::Gtk::Widget::selection_notify_event_signal" ref="217e18844168ab9954fa32fb504b913b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">SelectionNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#217e18844168ab9954fa32fb504b913b">Xfc::Gtk::Widget::selection_notify_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selection notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#adc0ce8251024ba8b9eefefae6438692">signal_selection_notify_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventSelection&amp; event);
&lt; <span class="comment">// event: The Gdk::EventSelection.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="68cdd670bf8bc3a6f6d15433211e0006"></a><!-- doxytag: member="Xfc::Gtk::Widget::proximity_in_event_signal" ref="68cdd670bf8bc3a6f6d15433211e0006" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ProximityInEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#68cdd670bf8bc3a6f6d15433211e0006">Xfc::Gtk::Widget::proximity_in_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Proximity in event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#653316981d2bef7c693facee31dab25b">signal_proximity_in_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventProximity&amp; event);
&lt; <span class="comment">// event: The Gdk::EventProximity.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="2aa9b7209624d56c2e46d14de8d3a049"></a><!-- doxytag: member="Xfc::Gtk::Widget::proximity_out_event_signal" ref="2aa9b7209624d56c2e46d14de8d3a049" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ProximityOutEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2aa9b7209624d56c2e46d14de8d3a049">Xfc::Gtk::Widget::proximity_out_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Proximity out event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2377cf4e2c86969da0e6ea639065fe76">signal_proximity_out_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventProximity&amp; event);
&lt; <span class="comment">// event: The Gdk::EventProximity.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="f2753621e9384574533e7d7b608384a9"></a><!-- doxytag: member="Xfc::Gtk::Widget::visibility_notify_event_signal" ref="f2753621e9384574533e7d7b608384a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">VisibilityNotifyEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#f2753621e9384574533e7d7b608384a9">Xfc::Gtk::Widget::visibility_notify_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Visibility notify event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#58a89e3fc1f71bf2bd18258bec52911d">signal_visibility_notify_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventVisibility&amp; event);
&lt; <span class="comment">// event: The Gdk::EventVisibility.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="071e21f9562347ba7fb7a98496919913"></a><!-- doxytag: member="Xfc::Gtk::Widget::client_event_signal" ref="071e21f9562347ba7fb7a98496919913" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">ClientEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#071e21f9562347ba7fb7a98496919913">Xfc::Gtk::Widget::client_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Client event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#03337f141db2566c5a5101cccfdb3180">signal_client_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventClient&amp; event);
&lt; <span class="comment">// event: The Gdk::EventClient.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="62be093016425319adda2eb63da87834"></a><!-- doxytag: member="Xfc::Gtk::Widget::no_expose_event_signal" ref="62be093016425319adda2eb63da87834" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">NoExposeEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#62be093016425319adda2eb63da87834">Xfc::Gtk::Widget::no_expose_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
No expose event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#64e7ca5a1e689b739baa1c33ddfafcd8">signal_no_expose_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventAny&amp; event);
&lt; <span class="comment">// event: The Gdk::EventAny.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="3c073f33f3bd3c935bbd60b7189ad060"></a><!-- doxytag: member="Xfc::Gtk::Widget::window_state_event_signal" ref="3c073f33f3bd3c935bbd60b7189ad060" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">WindowStateEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#3c073f33f3bd3c935bbd60b7189ad060">Xfc::Gtk::Widget::window_state_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> state event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#de207a8ba498a6583a4ea4f0f478784d">signal_window_state_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::EventWindowState&amp; event);
&lt; <span class="comment">// event: The Gdk::EventWindowState.</span>
&lt; <span class="comment">// return: true to stop invoking other handlers, false to propagate the event.</span>
&lt;
</pre></div> 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="widget_8hh.html">widget.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
