<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1Gtk.html">Gtk</a>::<a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a></div>
<h1>Xfc::Gtk::Window Class Reference</h1><!-- doxytag: class="Xfc::Gtk::Window" --><!-- doxytag: inherits="Xfc::Gtk::Bin" -->A GtkWindow C++ wrapper class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/gtk/window.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::Gtk::Window:
<p><center><img src="classXfc_1_1Gtk_1_1Window.png" usemap="#Xfc::Gtk::Window_map" border="0" alt=""></center>
<map name="Xfc::Gtk::Window_map">
<area href="classXfc_1_1Gtk_1_1Bin.html" alt="Xfc::Gtk::Bin" shape="rect" coords="552,336,763,360">
<area href="classXfc_1_1Gtk_1_1Container.html" alt="Xfc::Gtk::Container" shape="rect" coords="552,280,763,304">
<area href="classXfc_1_1Gtk_1_1Widget.html" alt="Xfc::Gtk::Widget" shape="rect" coords="552,224,763,248">
<area href="classXfc_1_1Gtk_1_1Object.html" alt="Xfc::Gtk::Object" shape="rect" coords="442,168,653,192">
<area href="classXfc_1_1Atk_1_1Implementor.html" alt="Xfc::Atk::Implementor" shape="rect" coords="663,168,874,192">
<area href="classXfc_1_1G_1_1Object.html" alt="Xfc::G::Object" shape="rect" coords="442,112,653,136">
<area href="classXfc_1_1G_1_1TypeInterface.html" alt="Xfc::G::TypeInterface" shape="rect" coords="663,112,874,136">
<area href="classXfc_1_1G_1_1TypeInstance.html" alt="Xfc::G::TypeInstance" shape="rect" coords="442,56,653,80">
<area href="classXfc_1_1G_1_1TypeInstance.html" alt="Xfc::G::TypeInstance" shape="rect" coords="663,56,874,80">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="442,0,653,24">
<area href="classXfc_1_1Trackable.html" alt="Xfc::Trackable" shape="rect" coords="663,0,874,24">
<area href="classXfc_1_1Gtk_1_1Dialog.html" alt="Xfc::Gtk::Dialog" shape="rect" coords="442,448,653,472">
<area href="classXfc_1_1Gtk_1_1Plug.html" alt="Xfc::Gtk::Plug" shape="rect" coords="663,448,874,472">
<area href="classXfc_1_1Gtk_1_1AboutDialog.html" alt="Xfc::Gtk::AboutDialog" shape="rect" coords="0,504,211,528">
<area href="classXfc_1_1Gtk_1_1ColorSelectionDialog.html" alt="Xfc::Gtk::ColorSelectionDialog" shape="rect" coords="221,504,432,528">
<area href="classXfc_1_1Gtk_1_1FileChooserDialog.html" alt="Xfc::Gtk::FileChooserDialog" shape="rect" coords="442,504,653,528">
<area href="classXfc_1_1Gtk_1_1FontSelectionDialog.html" alt="Xfc::Gtk::FontSelectionDialog" shape="rect" coords="663,504,874,528">
<area href="classXfc_1_1Gtk_1_1MessageDialog.html" alt="Xfc::Gtk::MessageDialog" shape="rect" coords="884,504,1095,528">
<area href="classXfc_1_1Gtk_1_1FileChooserOpenDialog.html" alt="Xfc::Gtk::FileChooserOpenDialog" shape="rect" coords="331,560,542,584">
<area href="classXfc_1_1Gtk_1_1FileChooserSaveAsDialog.html" alt="Xfc::Gtk::FileChooserSaveAsDialog" shape="rect" coords="552,560,763,584">
</map>
<a href="classXfc_1_1Gtk_1_1Window-members.html">List of all members.</a><h2>Signal Prototypes</h2>
<ul>
<li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">SetFocusSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#af570fdd10b663781760a6200c9f3788">set_focus_signal</a>
<dl class="el"><dd class="mdescRight">Set focus signal (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#b44afcc86d91813efcf9eb9c2013dacd">signal_set_focus()</a>).  <a href="#af570fdd10b663781760a6200c9f3788"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">FrameEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#b8b336602349cd4454c398f243a59d69">frame_event_signal</a>
<dl class="el"><dd class="mdescRight"><a class="el" href="classXfc_1_1Gtk_1_1Frame.html">Frame</a> event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#1710a1a74d1d5e4543f10a19eb53391e">signal_frame_event()</a>).  <a href="#b8b336602349cd4454c398f243a59d69"></a><br></dl><li>static const <a class="el" href="classXfc_1_1G_1_1Signal.html">KeysChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#dff3789fec3511ba2e1d7ddceb4ac3f4">keys_changed_signal</a>
<dl class="el"><dd class="mdescRight">Keys changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#5f0427faeaa5635f7c1bd7c999871c22">signal_keys_changed()</a>).  <a href="#dff3789fec3511ba2e1d7ddceb4ac3f4"></a><br></dl></ul>
<h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="242fca67f60aa64ad4c2da84d2a5894b"></a><!-- doxytag: member="Xfc::Gtk::Window::gtk_window" ref="242fca67f60aa64ad4c2da84d2a5894b" args="() const" -->
GtkWindow * <a class="el" href="classXfc_1_1Gtk_1_1Window.html#242fca67f60aa64ad4c2da84d2a5894b">gtk_window</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GtkWindow structure. <br></dl><li><a class="anchor" name="b528faf16f39055858d883957462196b"></a><!-- doxytag: member="Xfc::Gtk::Window::operator GtkWindow *" ref="b528faf16f39055858d883957462196b" args="() const" -->
<a class="el" href="classXfc_1_1Gtk_1_1Window.html#b528faf16f39055858d883957462196b">operator GtkWindow *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; safely converts a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> to a GtkWindow pointer. <br></dl><li><a class="anchor" name="b2dbf58fe41a2a99a924ae1c0184d7b4"></a><!-- doxytag: member="Xfc::Gtk::Window::is_toplevel" ref="b2dbf58fe41a2a99a924ae1c0184d7b4" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#b2dbf58fe41a2a99a924ae1c0184d7b4">is_toplevel</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the window type is WINDOW_TOPLEVEL. <br></dl><li><a class="anchor" name="6c0a8a1ad4425698c7c1ab5e729f0864"></a><!-- doxytag: member="Xfc::Gtk::Window::is_popup" ref="6c0a8a1ad4425698c7c1ab5e729f0864" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#6c0a8a1ad4425698c7c1ab5e729f0864">is_popup</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the window type is WINDOW_POPUP. <br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e4773c2601570d033b6829743c702325">is_active</a> () const
<dl class="el"><dd class="mdescRight">Determines whether the window is part of the current active toplevel.  <a href="#e4773c2601570d033b6829743c702325"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#4a286507814af52629824f0810b53604">has_toplevel_focus</a> () const
<dl class="el"><dd class="mdescRight">Determines whether the input focus is within this window.  <a href="#4a286507814af52629824f0810b53604"></a><br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#41475d477151b36edea1c0349322882d">get_title</a> () const
<dl class="el"><dd class="mdescRight">Retrieves the title of the window (see set_title()).  <a href="#41475d477151b36edea1c0349322882d"></a><br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7b26792b8d34fad228c5ae33e7ea15a4">get_role</a> () const
<dl class="el"><dd class="mdescRight">Returns the role of the window (see set_role() for further explanation).  <a href="#7b26792b8d34fad228c5ae33e7ea15a4"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> * <a class="el" href="classXfc_1_1Gtk_1_1Window.html#749e42d00abea0ad2cebb506f9e117d3">get_focus</a> () const
<dl class="el"><dd class="mdescRight">Retrieves the current focused widget within the window.  <a href="#749e42d00abea0ad2cebb506f9e117d3"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> * <a class="el" href="classXfc_1_1Gtk_1_1Window.html#ac3a29a4daaaddbad05c5cc925294ecc">get_transient_for</a> () const
<dl class="el"><dd class="mdescRight">Fetches the transient parent for this window (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c0784ba51aebb9dc07972a40776f8dc5">set_transient_for()</a>).  <a href="#ac3a29a4daaaddbad05c5cc925294ecc"></a><br></dl><li><a class="el" href="namespaceXfc_1_1Gdk.html#7bc9d7170459002f90922e5ece04678c">Gdk::WindowTypeHint</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#6e3440216a915bdedfa77dd75bf08ddd">get_type_hint</a> () const
<dl class="el"><dd class="mdescRight">Gets the type hint for this window (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8f4d750f5ec5303767336c6099750fb">set_type_hint()</a>).  <a href="#6e3440216a915bdedfa77dd75bf08ddd"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#b025012a90d6a4d9aacb6667e47db975">get_skip_taskbar_hint</a> () const
<dl class="el"><dd class="mdescRight">Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#07626b27d998e2d3a401530de5928f01">set_skip_taskbar_hint()</a>.  <a href="#b025012a90d6a4d9aacb6667e47db975"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#fdbab550a416a93d3b31ecfbd1e56947">get_accept_focus</a> () const
<dl class="el"><dd class="mdescRight">Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#39150af1dadd516cc41deaf48d0ee898">set_accept_focus()</a>.  <a href="#fdbab550a416a93d3b31ecfbd1e56947"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#4fee37a2732b539cf046d77eb214b509">get_skip_pager_hint</a> () const
<dl class="el"><dd class="mdescRight">Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#b714afeaaa82587c8e027d0edc8141b5">set_skip_pager_hint()</a>.  <a href="#4fee37a2732b539cf046d77eb214b509"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#566135d6bd64ec41b48ebb499b46a8af">get_focus_on_map</a> () const
<dl class="el"><dd class="mdescRight">Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#ed4d50f21fd8f0ddf8f875b76f26a7d1">set_focus_on_map()</a>.  <a href="#566135d6bd64ec41b48ebb499b46a8af"></a><br></dl><li><a class="anchor" name="19ae26a349f90e9453c5144fcd3b0e0d"></a><!-- doxytag: member="Xfc::Gtk::Window::get_destroy_with_parent" ref="19ae26a349f90e9453c5144fcd3b0e0d" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#19ae26a349f90e9453c5144fcd3b0e0d">get_destroy_with_parent</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the window will be destroyed with its transient parent (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#4b6efa7e339d5d74aa57e6865c3c4f30">set_destroy_with_parent()</a>). <br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#31b26392619b700445031abd9cbe5339">get_resizable</a> () const
<dl class="el"><dd class="mdescRight">Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7306d3ea119c6e6404ac41b189b8e742">set_resizable()</a>.  <a href="#31b26392619b700445031abd9cbe5339"></a><br></dl><li><a class="el" href="namespaceXfc_1_1Gdk.html#707ee0aacf7d421c407ec5674e037e0e">Gdk::Gravity</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0a56d41c05965e72220b2c55fddeb8a7">get_gravity</a> () const
<dl class="el"><dd class="mdescRight">Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#88d7aa5cb69343d848a8d68ec3317714">set_gravity()</a>.  <a href="#0a56d41c05965e72220b2c55fddeb8a7"></a><br></dl><li><a class="anchor" name="89fca906d29f72ab1dfe560aa469fd38"></a><!-- doxytag: member="Xfc::Gtk::Window::get_screen" ref="89fca906d29f72ab1dfe560aa469fd38" args="() const" -->
<a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> * <a class="el" href="classXfc_1_1Gtk_1_1Window.html#89fca906d29f72ab1dfe560aa469fd38">get_screen</a> () const
<dl class="el"><dd class="mdescRight">Returns the <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> associated with the window. <br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#9ec4cf38290f6827dbc7995023ff3459">get_has_frame</a> () const
<dl class="el"><dd class="mdescRight">Returns whether the window has a frame window exterior to <a class="el" href="classXfc_1_1Gtk_1_1Window.html#242fca67f60aa64ad4c2da84d2a5894b">gtk_window()</a>-&gt;window (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0343cbd8d48bb289501e1cfcf650c940">set_has_frame()</a>).  <a href="#9ec4cf38290f6827dbc7995023ff3459"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#d42a7a3730213b454567a19874719297">get_frame_dimensions</a> (int *left, int *top, int *right, int *bottom) const 
<dl class="el"><dd class="mdescRight">Retrieves the dimensions of the frame window for this toplevel.  <a href="#d42a7a3730213b454567a19874719297"></a><br></dl><li><a class="anchor" name="9e98149f925e936a280008befa4b6b4e"></a><!-- doxytag: member="Xfc::Gtk::Window::get_decorated" ref="9e98149f925e936a280008befa4b6b4e" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#9e98149f925e936a280008befa4b6b4e">get_decorated</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the window has been set to have decorations such as a title bar via <a class="el" href="classXfc_1_1Gtk_1_1Window.html#bdad0041d92dcf049c92d16747220140">set_decorated()</a>. <br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#76d6c46b6d8f75da81e9a02bd9991bf2">get_icon_name</a> () const
<dl class="el"><dd class="mdescRight">Returns the name of the themed icon for the window (see set_icon_name()).  <a href="#76d6c46b6d8f75da81e9a02bd9991bf2"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7c6bce91cebc5ee5772ce3ed9e1457e7">get_icon_list</a> (std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> * &gt; &amp;icons) const
<dl class="el"><dd class="mdescRight">Retrieves the list of icons set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a>.  <a href="#7c6bce91cebc5ee5772ce3ed9e1457e7"></a><br></dl><li><a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> * <a class="el" href="classXfc_1_1Gtk_1_1Window.html#3da62c8a9d475d3d9d5614e842a65320">get_icon</a> () const
<dl class="el"><dd class="mdescRight">Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7c5750ac3f8bb3d268d6bad8f8209a95">set_icon()</a>, or if you've called <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a>, gets the first icon in the icon list.  <a href="#3da62c8a9d475d3d9d5614e842a65320"></a><br></dl><li><a class="anchor" name="5862c069602edee9fe31341580655c98"></a><!-- doxytag: member="Xfc::Gtk::Window::get_modal" ref="5862c069602edee9fe31341580655c98" args="() const" -->
bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#5862c069602edee9fe31341580655c98">get_modal</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the window is modal and establishes a grab when shown (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#3d65e729e09373f8b05f3fd8afa7b523">set_modal()</a>). <br></dl><li><a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">Gdk::ModifierTypeField</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#15fa921dfb4fb08f7bdef72a46ee452a">get_mnemonic_modifier</a> () const
<dl class="el"><dd class="mdescRight">Returns the mnemonic modifier for this window (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#bcfa5954379e30fc26466d558fd7bb37">set_mnemonic_modifier()</a>).  <a href="#15fa921dfb4fb08f7bdef72a46ee452a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#aed33e9e6c50efcdc103ec2bdc88670f">get_default_size</a> (int *width, int *height) const
<dl class="el"><dd class="mdescRight">Gets the default size of the window.  <a href="#aed33e9e6c50efcdc103ec2bdc88670f"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7008d443d40a1fd3c959358176336d13">get_size</a> (int *width, int *height) const
<dl class="el"><dd class="mdescRight">Obtains the current size of the window.  <a href="#7008d443d40a1fd3c959358176336d13"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8448810f7b856b3694db1d3b82c41f7">get_position</a> (int *root_x, int *root_y) const
<dl class="el"><dd class="mdescRight">This method returns the position you need to pass to <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a> to keep window in its current position; the meaning of the returned value varies with window gravity (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a> for more details).  <a href="#e8448810f7b856b3694db1d3b82c41f7"></a><br></dl><li><a class="anchor" name="11ad328ad8e5f9d8da44345704b03cff"></a><!-- doxytag: member="Xfc::Gtk::Window::get_position" ref="11ad328ad8e5f9d8da44345704b03cff" args="() const" -->
<a class="el" href="classXfc_1_1Gdk_1_1Point.html">Gdk::Point</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#11ad328ad8e5f9d8da44345704b03cff">get_position</a> () const
<dl class="el"><dd class="mdescRight">This method returns the position you need to pass to <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a> to keep window in its current position, as a <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Gdk::Point</a> (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8448810f7b856b3694db1d3b82c41f7">get_position(int *, int *) const</a>). <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#992da9b94e8a8a325f40678e5d23e077">set_title</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;title)
<dl class="el"><dd class="mdescRight">Sets the title of the window.  <a href="#992da9b94e8a8a325f40678e5d23e077"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#cb24c9a82b36e0362677a7456360c4c2">set_wmclass</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;wmclass_name, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;wmclass_class)
<dl class="el"><dd class="mdescRight">Sets the X <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> System "class" and "name" hints for a window.  <a href="#cb24c9a82b36e0362677a7456360c4c2"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#8c14f7478c9b5404d56a9346dc11fb2c">set_role</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;role)
<dl class="el"><dd class="mdescRight">This method is only useful on X11, not with other GTK+ targets.  <a href="#8c14f7478c9b5404d56a9346dc11fb2c"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> * <a class="el" href="classXfc_1_1Gtk_1_1Window.html#2e9d3b1accd9df9ab34de6750cd782e2">add_accel_group</a> (<a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> *accel_group=0)
<dl class="el"><dd class="mdescRight">Associate <em>accel_group</em> with the window, such that calling Gtk::AccelGroup_activate() on the window will activate accelerators in <em>accel_group</em>.  <a href="#2e9d3b1accd9df9ab34de6750cd782e2"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#1b2edfb1c6d1569434c1ef61d7f45287">remove_accel_group</a> (<a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> &amp;accel_group)
<dl class="el"><dd class="mdescRight">Reverses the effects of <a class="el" href="classXfc_1_1Gtk_1_1Window.html#2e9d3b1accd9df9ab34de6750cd782e2">add_accel_group()</a>.  <a href="#1b2edfb1c6d1569434c1ef61d7f45287"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#781c88bbbd8db054acf8356878f9caad">set_position</a> (<a class="el" href="namespaceXfc_1_1Gtk.html#380331c0f0306dfbac20807298bdd79d">WindowPosition</a> position)
<dl class="el"><dd class="mdescRight">Sets a position constraint for this window.  <a href="#781c88bbbd8db054acf8356878f9caad"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#cfba0fa94624cc093f3062d7b5bdbd73">activate_focus</a> ()
<dl class="el"><dd class="mdescRight">Activate the current focused widget.  <a href="#cfba0fa94624cc093f3062d7b5bdbd73"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#ceee8dad850ee0ec09581076a878f0f5">set_focus</a> (<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> *focus)
<dl class="el"><dd class="mdescRight">If <em>focus</em> is not the current focus widget, and is focusable, sets it as the focus widget for the window.  <a href="#ceee8dad850ee0ec09581076a878f0f5"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#4f3ea9407a5d65fd8b49f3c505484fc0">set_default</a> (<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> *default_widget)
<dl class="el"><dd class="mdescRight">The default widget is the widget that's activated when the user presses Enter in a dialog, for example.  <a href="#4f3ea9407a5d65fd8b49f3c505484fc0"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#d3fa2306342cd74a022f8b901ee04525">activate_default</a> ()
<dl class="el"><dd class="mdescRight">Activate the default widget.  <a href="#d3fa2306342cd74a022f8b901ee04525"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c0784ba51aebb9dc07972a40776f8dc5">set_transient_for</a> (<a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> *parent)
<dl class="el"><dd class="mdescRight"><a class="el" href="classXfc_1_1Gtk_1_1Dialog.html">Dialog</a> windows should be set transient for the main application window they were spawned from.  <a href="#c0784ba51aebb9dc07972a40776f8dc5"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8f4d750f5ec5303767336c6099750fb">set_type_hint</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#7bc9d7170459002f90922e5ece04678c">Gdk::WindowTypeHint</a> hint)
<dl class="el"><dd class="mdescRight">By setting the type hint for the window, you allow the window manager to decorate and handle the window in a way which is suitable to the function of the window in your application.  <a href="#e8f4d750f5ec5303767336c6099750fb"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#07626b27d998e2d3a401530de5928f01">set_skip_taskbar_hint</a> (bool setting)
<dl class="el"><dd class="mdescRight">Windows may set a hint asking the desktop environment not to display the window in the task bar; this method toggles this hint.  <a href="#07626b27d998e2d3a401530de5928f01"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#b714afeaaa82587c8e027d0edc8141b5">set_skip_pager_hint</a> (bool setting)
<dl class="el"><dd class="mdescRight">Windows may set a hint asking the desktop environment not to display the window in the pager; this function toggles this hint.  <a href="#b714afeaaa82587c8e027d0edc8141b5"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#39150af1dadd516cc41deaf48d0ee898">set_accept_focus</a> (bool setting)
<dl class="el"><dd class="mdescRight">Set a hint telling the desktop environment whether or not this window should receive the input focus.  <a href="#39150af1dadd516cc41deaf48d0ee898"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#ed4d50f21fd8f0ddf8f875b76f26a7d1">set_focus_on_map</a> (bool setting)
<dl class="el"><dd class="mdescRight">Set a hint telling the desktop environment whether or not this window should receive the input focus when mapped.  <a href="#ed4d50f21fd8f0ddf8f875b76f26a7d1"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#4b6efa7e339d5d74aa57e6865c3c4f30">set_destroy_with_parent</a> (bool setting)
<dl class="el"><dd class="mdescRight">If setting is true, then destroying the transient parent of window will also destroy the window itself.  <a href="#4b6efa7e339d5d74aa57e6865c3c4f30"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7306d3ea119c6e6404ac41b189b8e742">set_resizable</a> (bool resizable)
<dl class="el"><dd class="mdescRight">Sets whether the user can resize a window.  <a href="#7306d3ea119c6e6404ac41b189b8e742"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#88d7aa5cb69343d848a8d68ec3317714">set_gravity</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#707ee0aacf7d421c407ec5674e037e0e">Gdk::Gravity</a> gravity)
<dl class="el"><dd class="mdescRight"><a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> gravity defines the meaning of coordinates passed to <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a> (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a> and <a class="el" href="namespaceXfc_1_1Gdk.html#707ee0aacf7d421c407ec5674e037e0e">Gdk::Gravity</a> for more details).  <a href="#88d7aa5cb69343d848a8d68ec3317714"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#93e8900077f3aa8274248734705f619c">set_geometry_hints</a> (<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> *geometry_widget, const <a class="el" href="classXfc_1_1Gdk_1_1Geometry.html">Gdk::Geometry</a> &amp;geometry)
<dl class="el"><dd class="mdescRight">This function sets up hints about how a window can be resized by the user.  <a href="#93e8900077f3aa8274248734705f619c"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#46e1ad25fabfe4483b5f0d420eabbd8d">set_screen</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> &amp;screen)
<dl class="el"><dd class="mdescRight">Sets the <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> where the window is displayed; if the window is already mapped, it will be unmapped, and then remapped on the new screen.  <a href="#46e1ad25fabfe4483b5f0d420eabbd8d"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0343cbd8d48bb289501e1cfcf650c940">set_has_frame</a> (bool setting)
<dl class="el"><dd class="mdescRight">This is a special-purpose method for the framebuffer port, that causes GTK+ to draw its own window border.  <a href="#0343cbd8d48bb289501e1cfcf650c940"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#fdf287ddc2eb5a0ad12f6e9c817eca0b">set_frame_dimensions</a> (int left, int top, int right, int bottom)
<dl class="el"><dd class="mdescRight">(Note: this is a special-purpose method intended for the framebuffer port; see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0343cbd8d48bb289501e1cfcf650c940">set_has_frame()</a>.  <a href="#fdf287ddc2eb5a0ad12f6e9c817eca0b"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#bdad0041d92dcf049c92d16747220140">set_decorated</a> (bool setting)
<dl class="el"><dd class="mdescRight">Ask the window manager to decorate or not decorate the window with a title bar, etc.  <a href="#bdad0041d92dcf049c92d16747220140"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list</a> (std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> * &gt; &amp;icons)
<dl class="el"><dd class="mdescRight">Sets up the icon representing the window.  <a href="#c37316a8d5906e459310f37afbb22c6d"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7c5750ac3f8bb3d268d6bad8f8209a95">set_icon</a> (<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &amp;icon)
<dl class="el"><dd class="mdescRight">Sets up the icon representing the window.  <a href="#7c5750ac3f8bb3d268d6bad8f8209a95"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#aa0a0f9894647007607fd1a82b50bcc1">set_icon_name</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;name)
<dl class="el"><dd class="mdescRight">Sets the icon for the window from a named themed icon.  <a href="#aa0a0f9894647007607fd1a82b50bcc1"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#90613c361d986fcdd9844fef0d973908">set_icon_from_file</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;filename, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Sets the icon for the window.  <a href="#90613c361d986fcdd9844fef0d973908"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#3d65e729e09373f8b05f3fd8afa7b523">set_modal</a> (bool modal)
<dl class="el"><dd class="mdescRight">Sets a window modal or non-modal.  <a href="#3d65e729e09373f8b05f3fd8afa7b523"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c12891acc5eab8abdf32a1e77555c738">add_mnemonic</a> (unsigned int keyval, <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;target)
<dl class="el"><dd class="mdescRight">Adds a mnemonic to this window.  <a href="#c12891acc5eab8abdf32a1e77555c738"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c4373af49f70c23a87d552201c615dbb">remove_mnemonic</a> (unsigned int keyval, <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;target)
<dl class="el"><dd class="mdescRight">Removes a mnemonic from this window.  <a href="#c4373af49f70c23a87d552201c615dbb"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#30509f2791b13451852ae9f496a3a22a">mnemonic_activate</a> (unsigned int keyval, <a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">Gdk::ModifierTypeField</a> modifier)
<dl class="el"><dd class="mdescRight">Activates the targets associated with the mnemonic.  <a href="#30509f2791b13451852ae9f496a3a22a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#bcfa5954379e30fc26466d558fd7bb37">set_mnemonic_modifier</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">Gdk::ModifierTypeField</a> modifier)
<dl class="el"><dd class="mdescRight">Sets the mnemonic modifier for this window.  <a href="#bcfa5954379e30fc26466d558fd7bb37"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#97cb54c8291e13ea02fd316e50892b19">activate_key</a> (const <a class="el" href="classXfc_1_1Gdk_1_1EventKey.html">Gdk::EventKey</a> &amp;event)
<dl class="el"><dd class="mdescRight">Activates mnemonics and accelerators for this window.  <a href="#97cb54c8291e13ea02fd316e50892b19"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8db50391ac58721b702622f8c877092">propagate_key_event</a> (const <a class="el" href="classXfc_1_1Gdk_1_1EventKey.html">Gdk::EventKey</a> &amp;event)
<dl class="el"><dd class="mdescRight">Propagate a key press or release event to the focus widget and up the focus container chain until a widget handles <em>event</em>.  <a href="#e8db50391ac58721b702622f8c877092"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#989fb247d36058c20ff009ef3ffe3266">present</a> ()
<dl class="el"><dd class="mdescRight">Presents a window to the user.  <a href="#989fb247d36058c20ff009ef3ffe3266"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#f08e9d7463a7fd859fe76f4b52c6a03a">iconify</a> ()
<dl class="el"><dd class="mdescRight">Asks to iconify (minimize) the specified window.  <a href="#f08e9d7463a7fd859fe76f4b52c6a03a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#5c6cdd7a8cd195a8a52b7fc97b8c8dac">deiconify</a> ()
<dl class="el"><dd class="mdescRight">Asks to deiconify (unminimize) the specified window.  <a href="#5c6cdd7a8cd195a8a52b7fc97b8c8dac"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0ddf327ef5eaca7e1d3544a51a07d4b6">stick</a> ()
<dl class="el"><dd class="mdescRight">Asks to stick the window, which means that it will appear on all user desktops.  <a href="#0ddf327ef5eaca7e1d3544a51a07d4b6"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c2d77af7104e871e2787984d014d62e6">unstick</a> ()
<dl class="el"><dd class="mdescRight">Asks to unstick the window, which means that it will appear on only one of the user's desktops.  <a href="#c2d77af7104e871e2787984d014d62e6"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7a0e75f04eb698cec542e96af1119ea1">maximize</a> ()
<dl class="el"><dd class="mdescRight">Asks to maximize window, so that it becomes full-screen.  <a href="#7a0e75f04eb698cec542e96af1119ea1"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#45f332ec89dfe2f843a4edf7902bd424">unmaximize</a> ()
<dl class="el"><dd class="mdescRight">Asks to unmaximize window.  <a href="#45f332ec89dfe2f843a4edf7902bd424"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#91901d0d4eed2aa24ef2a71acb1dbd66">fullscreen</a> ()
<dl class="el"><dd class="mdescRight">Asks to place the window in the fullscreen state.  <a href="#91901d0d4eed2aa24ef2a71acb1dbd66"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#401e9b68077a86cd5f83b169dd504f3a">unfullscreen</a> ()
<dl class="el"><dd class="mdescRight">Asks to toggle off the fullscreen state for the window.  <a href="#401e9b68077a86cd5f83b169dd504f3a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#b466bb0ab91bd21b5033ec52e6a8ab59">set_keep_above</a> (bool setting)
<dl class="el"><dd class="mdescRight">Asks to keep the window above, so that it stays on top.  <a href="#b466bb0ab91bd21b5033ec52e6a8ab59"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#4d68f70efa1c61bdecbba29a142b1f73">set_keep_below</a> (bool setting)
<dl class="el"><dd class="mdescRight">Asks to keep window below, so that it stays in bottom.  <a href="#4d68f70efa1c61bdecbba29a142b1f73"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#5c91e8d7f5bef2a590e3acb95093f753">begin_resize_drag</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#0e823b84cf97c36c12abce34415e9e39">Gdk::WindowEdge</a> edge, int button, int root_x, int root_y, unsigned int timestamp)
<dl class="el"><dd class="mdescRight">Starts resizing a window.  <a href="#5c91e8d7f5bef2a590e3acb95093f753"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#ef507e074f532bd2e01313596e616106">begin_move_drag</a> (int button, int root_x, int root_y, unsigned int timestamp)
<dl class="el"><dd class="mdescRight">Starts moving a window.  <a href="#ef507e074f532bd2e01313596e616106"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#228cb8888b8ce0ed08ce4f13c503065f">set_default_size</a> (int width, int height)
<dl class="el"><dd class="mdescRight">Sets the default size of a window.  <a href="#228cb8888b8ce0ed08ce4f13c503065f"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#45111b49a7d1569a6f3f5b1c6cb9a86a">resize</a> (int width, int height)
<dl class="el"><dd class="mdescRight">Resizes the window as if the user had done so, obeying geometry constraints.  <a href="#45111b49a7d1569a6f3f5b1c6cb9a86a"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move</a> (int x, int y)
<dl class="el"><dd class="mdescRight">Asks the window manager to move window to the given position.  <a href="#a383173d70e178817c4fbdbd5d475890"></a><br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#89b23518137576b034eea69775ca9214">move</a> (const <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Gdk::Point</a> &amp;point)
<dl class="el"><dd class="mdescRight">Asks the window manager to move window to the given point (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move(int, int)</a>).  <a href="#89b23518137576b034eea69775ca9214"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#ce6fcf8403fbfcd2a1b65b55d868400b">parse_geometry</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;geometry)
<dl class="el"><dd class="mdescRight">Parses a standard X <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> System geometry string - see the manual page for X (type 'man X') for details on this.  <a href="#ce6fcf8403fbfcd2a1b65b55d868400b"></a><br></dl><li><a class="anchor" name="54cd7786a592c8de3f779f04c80b33a4"></a><!-- doxytag: member="Xfc::Gtk::Window::reshow_with_initial_size" ref="54cd7786a592c8de3f779f04c80b33a4" args="()" -->
void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#54cd7786a592c8de3f779f04c80b33a4">reshow_with_initial_size</a> ()
<dl class="el"><dd class="mdescRight">Hides window, then reshows it, resetting the default size and position of the window (used by GUI builders only). <br></dl><li>void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#6039dcb928be22a669d7e41c74fc352d">show_about_dialog</a> (<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> *logo, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;name, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;version, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;comments, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;copyright, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;website=0, const std::vector&lt; <a class="el" href="classXfc_1_1String.html">String</a> &gt; *authors=0, const std::vector&lt; <a class="el" href="classXfc_1_1String.html">String</a> &gt; *documenters=0, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;license=0)
<dl class="el"><dd class="mdescRight">A convenience function for showing an application's about dialog box.  <a href="#6039dcb928be22a669d7e41c74fc352d"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Signal Proxies</div></td></tr>
<ul>
<li><a class="anchor" name="b44afcc86d91813efcf9eb9c2013dacd"></a><!-- doxytag: member="Xfc::Gtk::Window::signal_set_focus" ref="b44afcc86d91813efcf9eb9c2013dacd" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">SetFocusSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#b44afcc86d91813efcf9eb9c2013dacd">signal_set_focus</a> ()
<dl class="el"><dd class="mdescRight">Connect to the set_focus_signal; emitted when the focus widget for the window changes. <br></dl><li><a class="anchor" name="1710a1a74d1d5e4543f10a19eb53391e"></a><!-- doxytag: member="Xfc::Gtk::Window::signal_frame_event" ref="1710a1a74d1d5e4543f10a19eb53391e" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">FrameEventSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#1710a1a74d1d5e4543f10a19eb53391e">signal_frame_event</a> ()
<dl class="el"><dd class="mdescRight">Connect to the frame_event_signal; emitted whenever the window receives an event targeted at the frame. <br></dl><li><a class="anchor" name="5f0427faeaa5635f7c1bd7c999871c22"></a><!-- doxytag: member="Xfc::Gtk::Window::signal_keys_changed" ref="5f0427faeaa5635f7c1bd7c999871c22" args="()" -->
const <a class="el" href="classXfc_1_1G_1_1SignalProxy.html">KeysChangedSignalProxy</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#5f0427faeaa5635f7c1bd7c999871c22">signal_keys_changed</a> ()
<dl class="el"><dd class="mdescRight">Connect to the keys_changed_signal; emitted when the windows menmonic and/or accelerator keys have changed. <br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>static bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#d0b82a7885ea0453b26f4cf5fd4fa3ae">get_default_icon_list</a> (std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> * &gt; &amp;icons)
<dl class="el"><dd class="mdescRight">Gets the icon list set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#dde1c4f76c6ad7fad676fb88a7233409">set_default_icon_list()</a>.  <a href="#d0b82a7885ea0453b26f4cf5fd4fa3ae"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>static bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#cab255fb9f713fb078dda94666888c84">list_toplevels</a> (std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> * &gt; &amp;toplevels)
<dl class="el"><dd class="mdescRight">Retrieves a list of all existing toplevel windows.  <a href="#cab255fb9f713fb078dda94666888c84"></a><br></dl><li>static void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#dde1c4f76c6ad7fad676fb88a7233409">set_default_icon_list</a> (std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> * &gt; &amp;icons)
<dl class="el"><dd class="mdescRight">Sets an icon list to be used as fallback for windows that haven't had <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a> called on them to set up a window-specific icon list.  <a href="#dde1c4f76c6ad7fad676fb88a7233409"></a><br></dl><li>static void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#d1928df5d78a0af499711fdb778e230c">set_default_icon</a> (<a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &amp;icon)
<dl class="el"><dd class="mdescRight">Sets an icon to be used as fallback for windows that haven't had <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7c5750ac3f8bb3d268d6bad8f8209a95">set_icon()</a> called on them from a pixbuf.  <a href="#d1928df5d78a0af499711fdb778e230c"></a><br></dl><li>static void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#ccd275dcaf5746327b64515b1b191e41">set_default_icon_name</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;name)
<dl class="el"><dd class="mdescRight">Sets an icon to be used as a fallback for windows that haven't had <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a> called on them for a named themed icon (see set_icon_name()).  <a href="#ccd275dcaf5746327b64515b1b191e41"></a><br></dl><li>static bool <a class="el" href="classXfc_1_1Gtk_1_1Window.html#03ae60f34efa5e7919324ec7aa0c4bf3">set_default_icon_from_file</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;filename, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Sets an icon to be used as a fallback for windows that haven't had <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a> called on them from a file on disk.  <a href="#03ae60f34efa5e7919324ec7aa0c4bf3"></a><br></dl><li>static void <a class="el" href="classXfc_1_1Gtk_1_1Window.html#03ac5c3a64117c7a39900dfce35aefe9">set_auto_startup_notification</a> (bool setting)
<dl class="el"><dd class="mdescRight">Whether to do automatic startup notification.  <a href="#03ac5c3a64117c7a39900dfce35aefe9"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A GtkWindow C++ wrapper class. 
<p>
<a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> is usually the first widget instantiated in an application program and for regular applications (i.e. non-popup) is known a top-level widget. Its primary job is to provide a communication interface bewteen your application and the window manager. When the user resizes the application's main window with the window manager, that information is passed to the <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a>. <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> is derived from <a class="el" href="classXfc_1_1Gtk_1_1Bin.html">Bin</a> and thus can only have one child. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e2bcbecd35419de323704f01bf43b3ce"></a><!-- doxytag: member="Xfc::Gtk::Window::Window" ref="e2bcbecd35419de323704f01bf43b3ce" args="(GtkWindow *window, bool owns_reference=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::Window::Window           </td>
          <td>(</td>
          <td class="paramtype">GtkWindow *&nbsp;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> from an existing GtkWindow. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>window</em>&nbsp;</td><td>A pointer to a GtkWindow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>window</em> can be a newly created GtkWindow or an existing GtkWindow (see G::Object::Object). 
</div>
</div><p>
<a class="anchor" name="ee47c480261a702ab4bdf3b7ccdda7d2"></a><!-- doxytag: member="Xfc::Gtk::Window::Window" ref="ee47c480261a702ab4bdf3b7ccdda7d2" args="(WindowType type=WINDOW_TOPLEVEL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::Window::Window           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#6f0d8cc3138b46ebc4c7cff470b91889">WindowType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>WINDOW_TOPLEVEL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new window which is a toplevel window and can contain other widgets. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of window.</td></tr>
  </table>
</dl>
Nearly always, the type of the window should be WINDOW_TOPLEVEL. If you're implementing something like a popup menu from scratch (which is a bad idea, just use <a class="el" href="classXfc_1_1Gtk_1_1Menu.html">Menu</a>), you might use WINDOW_POPUP. WINDOW_POPUP is not for dialogs, though in some other toolkits dialogs are called "popups". In GTK+, WINDOW_POPUP means a pop-up menu or pop-up tooltip. On X11, popup windows are not controlled by the window manager. If you simply want an undecorated window (no window borders), use <a class="el" href="classXfc_1_1Gtk_1_1Window.html#bdad0041d92dcf049c92d16747220140">set_decorated()</a>, don't use WINDOW_POPUP. 
</div>
</div><p>
<a class="anchor" name="e2bcbecd35419de323704f01bf43b3ce"></a><!-- doxytag: member="Xfc::Gtk::Window::Window" ref="e2bcbecd35419de323704f01bf43b3ce" args="(GtkWindow *window, bool owns_reference=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::Window::Window           </td>
          <td>(</td>
          <td class="paramtype">GtkWindow *&nbsp;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owns_reference</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> from an existing GtkWindow. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>window</em>&nbsp;</td><td>A pointer to a GtkWindow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owns_reference</em>&nbsp;</td><td>Set false if the initial reference count is floating, set true if it's not.</td></tr>
  </table>
</dl>
The <em>window</em> can be a newly created GtkWindow or an existing GtkWindow (see G::Object::Object). 
</div>
</div><p>
<a class="anchor" name="ee47c480261a702ab4bdf3b7ccdda7d2"></a><!-- doxytag: member="Xfc::Gtk::Window::Window" ref="ee47c480261a702ab4bdf3b7ccdda7d2" args="(WindowType type=WINDOW_TOPLEVEL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::Gtk::Window::Window           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#6f0d8cc3138b46ebc4c7cff470b91889">WindowType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>WINDOW_TOPLEVEL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new window which is a toplevel window and can contain other widgets. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of window.</td></tr>
  </table>
</dl>
Nearly always, the type of the window should be WINDOW_TOPLEVEL. If you're implementing something like a popup menu from scratch (which is a bad idea, just use <a class="el" href="classXfc_1_1Gtk_1_1Menu.html">Menu</a>), you might use WINDOW_POPUP. WINDOW_POPUP is not for dialogs, though in some other toolkits dialogs are called "popups". In GTK+, WINDOW_POPUP means a pop-up menu or pop-up tooltip. On X11, popup windows are not controlled by the window manager. If you simply want an undecorated window (no window borders), use <a class="el" href="classXfc_1_1Gtk_1_1Window.html#bdad0041d92dcf049c92d16747220140">set_decorated()</a>, don't use WINDOW_POPUP. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e4773c2601570d033b6829743c702325"></a><!-- doxytag: member="Xfc::Gtk::Window::is_active" ref="e4773c2601570d033b6829743c702325" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::is_active           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the window is part of the current active toplevel. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the window is part of the current active window.</dd></dl>
A window is part of the current active toplevel if it is receiving keystrokes. The return value is <em>true</em> if the window is the active toplevel itself, but also if it is, say, a <a class="el" href="classXfc_1_1Gtk_1_1Plug.html">Gtk::Plug</a> embedded in the active toplevel. You might use this method if you wanted to draw a widget differently in an active window from a widget in an inactive window (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#4a286507814af52629824f0810b53604">has_toplevel_focus()</a>). 
</div>
</div><p>
<a class="anchor" name="4a286507814af52629824f0810b53604"></a><!-- doxytag: member="Xfc::Gtk::Window::has_toplevel_focus" ref="4a286507814af52629824f0810b53604" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::has_toplevel_focus           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the input focus is within this window. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the the input focus is within this window.</dd></dl>
For real toplevel windows, this is identical to <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e4773c2601570d033b6829743c702325">is_active()</a>, but for embedded windows, like <a class="el" href="classXfc_1_1Gtk_1_1Plug.html">Gtk::Plug</a>, the result will differ. 
</div>
</div><p>
<a class="anchor" name="41475d477151b36edea1c0349322882d"></a><!-- doxytag: member="Xfc::Gtk::Window::get_title" ref="41475d477151b36edea1c0349322882d" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Gtk::Window::get_title           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the title of the window (see set_title()). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The title of the window, or a null <a class="el" href="classXfc_1_1String.html">String</a> if none has been set explicitely. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b26792b8d34fad228c5ae33e7ea15a4"></a><!-- doxytag: member="Xfc::Gtk::Window::get_role" ref="7b26792b8d34fad228c5ae33e7ea15a4" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Gtk::Window::get_role           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the role of the window (see set_role() for further explanation). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The role of the window if set, or a null <a class="el" href="classXfc_1_1String.html">String</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="749e42d00abea0ad2cebb506f9e117d3"></a><!-- doxytag: member="Xfc::Gtk::Window::get_focus" ref="749e42d00abea0ad2cebb506f9e117d3" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a>* Xfc::Gtk::Window::get_focus           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the current focused widget within the window. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The currently focused widget.</dd></dl>
Note that this is the widget that would have the focus if the toplevel window is focused; if the toplevel window is not focused then <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#e88bba147c7b9e959236d4da285bf9f3">Gtk::Widget::has_focus()</a> will not be true for the widget. 
</div>
</div><p>
<a class="anchor" name="ac3a29a4daaaddbad05c5cc925294ecc"></a><!-- doxytag: member="Xfc::Gtk::Window::get_transient_for" ref="ac3a29a4daaaddbad05c5cc925294ecc" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a>* Xfc::Gtk::Window::get_transient_for           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetches the transient parent for this window (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c0784ba51aebb9dc07972a40776f8dc5">set_transient_for()</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The transient parent for this window, or null if no transient parent has been set. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6e3440216a915bdedfa77dd75bf08ddd"></a><!-- doxytag: member="Xfc::Gtk::Window::get_type_hint" ref="6e3440216a915bdedfa77dd75bf08ddd" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1Gdk.html#7bc9d7170459002f90922e5ece04678c">Gdk::WindowTypeHint</a> Xfc::Gtk::Window::get_type_hint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the type hint for this window (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8f4d750f5ec5303767336c6099750fb">set_type_hint()</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type hint for the window. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b025012a90d6a4d9aacb6667e47db975"></a><!-- doxytag: member="Xfc::Gtk::Window::get_skip_taskbar_hint" ref="b025012a90d6a4d9aacb6667e47db975" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::get_skip_taskbar_hint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#07626b27d998e2d3a401530de5928f01">set_skip_taskbar_hint()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the window shouldn't be in the taskbar. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fdbab550a416a93d3b31ecfbd1e56947"></a><!-- doxytag: member="Xfc::Gtk::Window::get_accept_focus" ref="fdbab550a416a93d3b31ecfbd1e56947" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::get_accept_focus           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#39150af1dadd516cc41deaf48d0ee898">set_accept_focus()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if window should receive the input focus. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4fee37a2732b539cf046d77eb214b509"></a><!-- doxytag: member="Xfc::Gtk::Window::get_skip_pager_hint" ref="4fee37a2732b539cf046d77eb214b509" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::get_skip_pager_hint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#b714afeaaa82587c8e027d0edc8141b5">set_skip_pager_hint()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the window shouldn't be in the pager. </dd></dl>

</div>
</div><p>
<a class="anchor" name="566135d6bd64ec41b48ebb499b46a8af"></a><!-- doxytag: member="Xfc::Gtk::Window::get_focus_on_map" ref="566135d6bd64ec41b48ebb499b46a8af" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::get_focus_on_map           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#ed4d50f21fd8f0ddf8f875b76f26a7d1">set_focus_on_map()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the window should receive the input focus when mapped. </dd></dl>

</div>
</div><p>
<a class="anchor" name="31b26392619b700445031abd9cbe5339"></a><!-- doxytag: member="Xfc::Gtk::Window::get_resizable" ref="31b26392619b700445031abd9cbe5339" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::get_resizable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7306d3ea119c6e6404ac41b189b8e742">set_resizable()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the user can resize the window. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0a56d41c05965e72220b2c55fddeb8a7"></a><!-- doxytag: member="Xfc::Gtk::Window::get_gravity" ref="0a56d41c05965e72220b2c55fddeb8a7" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1Gdk.html#707ee0aacf7d421c407ec5674e037e0e">Gdk::Gravity</a> Xfc::Gtk::Window::get_gravity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#88d7aa5cb69343d848a8d68ec3317714">set_gravity()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The window gravity. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ec4cf38290f6827dbc7995023ff3459"></a><!-- doxytag: member="Xfc::Gtk::Window::get_has_frame" ref="9ec4cf38290f6827dbc7995023ff3459" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::get_has_frame           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the window has a frame window exterior to <a class="el" href="classXfc_1_1Gtk_1_1Window.html#242fca67f60aa64ad4c2da84d2a5894b">gtk_window()</a>-&gt;window (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0343cbd8d48bb289501e1cfcf650c940">set_has_frame()</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if a frame has been added to the window via <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0343cbd8d48bb289501e1cfcf650c940">set_has_frame()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d42a7a3730213b454567a19874719297"></a><!-- doxytag: member="Xfc::Gtk::Window::get_frame_dimensions" ref="d42a7a3730213b454567a19874719297" args="(int *left, int *top, int *right, int *bottom) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::get_frame_dimensions           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bottom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the dimensions of the frame window for this toplevel. 
<p>
See <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0343cbd8d48bb289501e1cfcf650c940">set_has_frame()</a>, <a class="el" href="classXfc_1_1Gtk_1_1Window.html#fdf287ddc2eb5a0ad12f6e9c817eca0b">set_frame_dimensions()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>The location to store the width of the frame at the left, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>top</em>&nbsp;</td><td>The location to store the height of the frame at the top, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>right</em>&nbsp;</td><td>The location to store the width of the frame at the returns, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bottom</em>&nbsp;</td><td>The location to store the height of the frame at the bottom, or null.</td></tr>
  </table>
</dl>
This is a special-purpose method intended for the framebuffer port; see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0343cbd8d48bb289501e1cfcf650c940">set_has_frame()</a>. It will not return the size of the window border drawn by the window manager, which is the normal case when using a windowing system. See <a class="el" href="classXfc_1_1Gdk_1_1Window.html#079411ff10a2a25ff1c0382055733440">Gdk::Window::get_frame_extents()</a> to get the standard window border extents.) 
</div>
</div><p>
<a class="anchor" name="76d6c46b6d8f75da81e9a02bd9991bf2"></a><!-- doxytag: member="Xfc::Gtk::Window::get_icon_name" ref="76d6c46b6d8f75da81e9a02bd9991bf2" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::Gtk::Window::get_icon_name           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the themed icon for the window (see set_icon_name()). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The icon name or a null string if the window has no themed icon. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7c6bce91cebc5ee5772ce3ed9e1457e7"></a><!-- doxytag: member="Xfc::Gtk::Window::get_icon_list" ref="7c6bce91cebc5ee5772ce3ed9e1457e7" args="(std::vector&lt; Gdk::Pixbuf * &gt; &amp;icons) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::get_icon_list           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>icons</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the list of icons set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>icons</em>&nbsp;</td><td>A reference to a vector of <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a>* to hold the list. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the vector is not empty.</dd></dl>
The reference count on each member won't be incremented. 
</div>
</div><p>
<a class="anchor" name="3da62c8a9d475d3d9d5614e842a65320"></a><!-- doxytag: member="Xfc::Gtk::Window::get_icon" ref="3da62c8a9d475d3d9d5614e842a65320" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a>* Xfc::Gtk::Window::get_icon           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7c5750ac3f8bb3d268d6bad8f8209a95">set_icon()</a>, or if you've called <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a>, gets the first icon in the icon list. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The icon for window. </dd></dl>

</div>
</div><p>
<a class="anchor" name="15fa921dfb4fb08f7bdef72a46ee452a"></a><!-- doxytag: member="Xfc::Gtk::Window::get_mnemonic_modifier" ref="15fa921dfb4fb08f7bdef72a46ee452a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">Gdk::ModifierTypeField</a> Xfc::Gtk::Window::get_mnemonic_modifier           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the mnemonic modifier for this window (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#bcfa5954379e30fc26466d558fd7bb37">set_mnemonic_modifier()</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The modifier mask used to activate mnemonics on this window. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aed33e9e6c50efcdc103ec2bdc88670f"></a><!-- doxytag: member="Xfc::Gtk::Window::get_default_size" ref="aed33e9e6c50efcdc103ec2bdc88670f" args="(int *width, int *height) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::get_default_size           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the default size of the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The location to store the default width, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The location to store the default height, or null.</td></tr>
  </table>
</dl>
A value of -1 for the width or height indicates that a default size has not been explicitly set for that dimension, so the "natural" size of the window will be used. 
</div>
</div><p>
<a class="anchor" name="7008d443d40a1fd3c959358176336d13"></a><!-- doxytag: member="Xfc::Gtk::Window::get_size" ref="7008d443d40a1fd3c959358176336d13" args="(int *width, int *height) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::get_size           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the current size of the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The return location for width, or null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The return location for height, or null.</td></tr>
  </table>
</dl>
If the window is not onscreen, it returns the size GTK+ will suggest to the window manager for the initial window size (but this is not reliably the same as the size the window manager will actually select). The size obtained by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7008d443d40a1fd3c959358176336d13">get_size()</a> is the last size received in a GdkEventConfigure, that is, GTK+ uses its locally-stored size, rather than querying the X server for the size. As a result, if you call <a class="el" href="classXfc_1_1Gtk_1_1Window.html#45111b49a7d1569a6f3f5b1c6cb9a86a">resize()</a> then immediately call <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7008d443d40a1fd3c959358176336d13">get_size()</a>, the size won't have taken effect yet. After the window manager processes the resize request, GTK+ receives notification that the size has changed via a configure event, and the size of the window gets updated.<p>
<b>Note 1:</b> Nearly any use of this function creates a race condition, because the size of the window may change between the time that you get the size and the time that you perform some action assuming that size is the current size. To avoid race conditions, connect to "configure_event" on the window and adjust your size-dependent state to match the size delivered in the GdkEventConfigure.<p>
<b>Note 2:</b> The returned size does not include the size of the window manager decorations (aka the window frame or border). Those are not drawn by GTK+ and GTK+ has no reliable method of determining their size.<p>
<b>Note 3:</b> If you are getting a window size in order to position the window onscreen, there may be a better way. The preferred way is to simply set the window's semantic type with <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8f4d750f5ec5303767336c6099750fb">set_type_hint()</a>, which allows the window manager to e.g. center dialogs. Also, if you set the transient parent of dialogs with <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c0784ba51aebb9dc07972a40776f8dc5">set_transient_for()</a> window managers will often center the dialog over its parent window. It's much preferred to let the window manager handle these things rather than doing it yourself, because all applications will behave consistently and according to user preferences if the window manager handles it. Also, the window manager can take the size of the window decorations/border into account, while your application cannot.<p>
In any case, if you insist on application-specified window positioning, there's still a better way than doing it yourself - <a class="el" href="classXfc_1_1Gtk_1_1Window.html#781c88bbbd8db054acf8356878f9caad">set_position()</a> will frequently handle the details for you. 
</div>
</div><p>
<a class="anchor" name="e8448810f7b856b3694db1d3b82c41f7"></a><!-- doxytag: member="Xfc::Gtk::Window::get_position" ref="e8448810f7b856b3694db1d3b82c41f7" args="(int *root_x, int *root_y) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::get_position           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>root_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>root_y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the position you need to pass to <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a> to keep window in its current position; the meaning of the returned value varies with window gravity (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a> for more details). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>root_x</em>&nbsp;</td><td>The return location for X coordinate of gravity-determined reference point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_y</em>&nbsp;</td><td>The return location for Y coordinate of gravity-determined reference point.</td></tr>
  </table>
</dl>
If you haven't changed the window gravity, its gravity will be GRAVITY_NORTH_WEST. This means that <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8448810f7b856b3694db1d3b82c41f7">get_position()</a> gets the position of the top-left corner of the window manager frame for the window. <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a> sets the position of this same top-left corner. <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8448810f7b856b3694db1d3b82c41f7">get_position()</a> is not 100% reliable because the X <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> System does not specify a way to obtain the geometry of the decorations placed on a window by the window manager. Thus GTK+ is using a "best guess" that works with most window managers. Moreover, nearly all window managers are historically broken with respect to their handling of window gravity. So moving a window to its current position as returned by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8448810f7b856b3694db1d3b82c41f7">get_position()</a> tends to result in moving the window slightly. <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> managers are slowly getting better over time. If a window has gravity GRAVITY_STATIC the window manager frame is not relevant, and thus <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8448810f7b856b3694db1d3b82c41f7">get_position()</a> will always produce accurate results. However you can't use static gravity to do things like place a window in a corner of the screen, because static gravity ignores the window manager decorations. If you are saving and restoring your application's window positions, you should know that it's impossible for applications to do this without getting it somewhat wrong because applications do not have sufficient knowledge of window manager state. The Correct Mechanism is to support the session management protocol (see the "GnomeClient" object in the GNOME libraries for example) and allow the window manager to save your window sizes and positions. 
</div>
</div><p>
<a class="anchor" name="d0b82a7885ea0453b26f4cf5fd4fa3ae"></a><!-- doxytag: member="Xfc::Gtk::Window::get_default_icon_list" ref="d0b82a7885ea0453b26f4cf5fd4fa3ae" args="(std::vector&lt; Gdk::Pixbuf * &gt; &amp;icons)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Xfc::Gtk::Window::get_default_icon_list           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>icons</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the icon list set by <a class="el" href="classXfc_1_1Gtk_1_1Window.html#dde1c4f76c6ad7fad676fb88a7233409">set_default_icon_list()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>icons</em>&nbsp;</td><td>A reference to a vector of <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a>* to hold the list. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the vector is not empty.</dd></dl>
The pixbufs in the list have not had their reference count incremented, so don't unreference them. 
</div>
</div><p>
<a class="anchor" name="992da9b94e8a8a325f40678e5d23e077"></a><!-- doxytag: member="Xfc::Gtk::Window::set_title" ref="992da9b94e8a8a325f40678e5d23e077" args="(const String &amp;title)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_title           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>title</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the title of the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>title</em>&nbsp;</td><td>The title of the window.</td></tr>
  </table>
</dl>
The title of a window will be displayed in its title bar; on the X <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> System, the title bar is rendered by the window manager, so exactly how the title appears to users may vary according to a user's exact configuration. The title should help a user distinguish this window from other windows they may have open. A good title might include the application name and current document filename, for example. 
</div>
</div><p>
<a class="anchor" name="cb24c9a82b36e0362677a7456360c4c2"></a><!-- doxytag: member="Xfc::Gtk::Window::set_wmclass" ref="cb24c9a82b36e0362677a7456360c4c2" args="(const String &amp;wmclass_name, const String &amp;wmclass_class)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_wmclass           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>wmclass_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>wmclass_class</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the X <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> System "class" and "name" hints for a window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wmclass_name</em>&nbsp;</td><td>The window name hint. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wmclass_class</em>&nbsp;</td><td>The window class hint.</td></tr>
  </table>
</dl>
Don't use this method. According to the ICCCM, you should always set <em>wmclass_name</em> and <em>wmclass_class</em> to the same value for all windows in an application, and GTK+ sets them to that value by default, so calling this method is sort of pointless. However, you may want to call set_role() on each window in your application, for the benefit of the session manager. Setting the role allows the window manager to restore window positions when loading a saved session. 
</div>
</div><p>
<a class="anchor" name="8c14f7478c9b5404d56a9346dc11fb2c"></a><!-- doxytag: member="Xfc::Gtk::Window::set_role" ref="8c14f7478c9b5404d56a9346dc11fb2c" args="(const String &amp;role)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_role           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>role</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is only useful on X11, not with other GTK+ targets. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>role</em>&nbsp;</td><td>The unique identifier for the window to be used when restoring a session.</td></tr>
  </table>
</dl>
In combination with the window title, the window role allows a window manager to identify "the same" window when an application is restarted. So for example you might set the "toolbox" role on your app's toolbox window, so that when the user restarts their session, the window manager can put the toolbox back in the same place. If a window already has a unique title, you don't need to set the role, since the window manager can use the title to identify the window when restoring the session. 
</div>
</div><p>
<a class="anchor" name="2e9d3b1accd9df9ab34de6750cd782e2"></a><!-- doxytag: member="Xfc::Gtk::Window::add_accel_group" ref="2e9d3b1accd9df9ab34de6750cd782e2" args="(AccelGroup *accel_group=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a>* Xfc::Gtk::Window::add_accel_group           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>accel_group</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Associate <em>accel_group</em> with the window, such that calling Gtk::AccelGroup_activate() on the window will activate accelerators in <em>accel_group</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>accel_group</em>&nbsp;</td><td>An <a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to an <a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a>.</dd></dl>
If <em>accel_group</em> is null a newly created <a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> owned by the window is returned, otherwise <em>accel_group</em> is returned. 
</div>
</div><p>
<a class="anchor" name="1b2edfb1c6d1569434c1ef61d7f45287"></a><!-- doxytag: member="Xfc::Gtk::Window::remove_accel_group" ref="1b2edfb1c6d1569434c1ef61d7f45287" args="(AccelGroup &amp;accel_group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::remove_accel_group           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>accel_group</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reverses the effects of <a class="el" href="classXfc_1_1Gtk_1_1Window.html#2e9d3b1accd9df9ab34de6750cd782e2">add_accel_group()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>accel_group</em>&nbsp;</td><td>An <a class="el" href="classXfc_1_1Gtk_1_1AccelGroup.html">AccelGroup</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="781c88bbbd8db054acf8356878f9caad"></a><!-- doxytag: member="Xfc::Gtk::Window::set_position" ref="781c88bbbd8db054acf8356878f9caad" args="(WindowPosition position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_position           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gtk.html#380331c0f0306dfbac20807298bdd79d">WindowPosition</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a position constraint for this window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>A position constraint.</td></tr>
  </table>
</dl>
If the old or new constraint is WIN_POS_CENTER_ALWAYS, this will also cause the window to be repositioned to satisfy the new constraint. 
</div>
</div><p>
<a class="anchor" name="cfba0fa94624cc093f3062d7b5bdbd73"></a><!-- doxytag: member="Xfc::Gtk::Window::activate_focus" ref="cfba0fa94624cc093f3062d7b5bdbd73" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::activate_focus           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Activate the current focused widget. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the widget was activatable.</dd></dl>
Activation is what happens when you press Enter on a widget during key navigation; clicking a button, selecting a menu item, etc. If widget isn't activatable, this method returns false. 
</div>
</div><p>
<a class="anchor" name="ceee8dad850ee0ec09581076a878f0f5"></a><!-- doxytag: member="Xfc::Gtk::Window::set_focus" ref="ceee8dad850ee0ec09581076a878f0f5" args="(Widget *focus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_focus           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> *&nbsp;</td>
          <td class="paramname"> <em>focus</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If <em>focus</em> is not the current focus widget, and is focusable, sets it as the focus widget for the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>focus</em>&nbsp;</td><td>The new focus widget, or null to unset the current focus widget.</td></tr>
  </table>
</dl>
If <em>focus</em> is null, unsets the focus widget for this window. To set the focus to a particular widget in the toplevel, it is usually more convenient to use <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2faac78256ebb7930dc1d0812f77f19f">Gtk::Widget::grab_focus()</a> instead of this method. 
</div>
</div><p>
<a class="anchor" name="4f3ea9407a5d65fd8b49f3c505484fc0"></a><!-- doxytag: member="Xfc::Gtk::Window::set_default" ref="4f3ea9407a5d65fd8b49f3c505484fc0" args="(Widget *default_widget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_default           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> *&nbsp;</td>
          <td class="paramname"> <em>default_widget</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The default widget is the widget that's activated when the user presses Enter in a dialog, for example. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>default_widget</em>&nbsp;</td><td>The widget to be the default, or null to unset the default widget.</td></tr>
  </table>
</dl>
This method sets or unsets the default widget for a <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a>. When setting (rather than unsetting) the default widget it's generally easier to call <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#2faac78256ebb7930dc1d0812f77f19f">grab_focus()</a> on the widget. Before making a widget the default widget, you must set the CAN_DEFAULT flag on the widget you'd like to make the default using <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#505215cea2d040497ac37144da41b49a">Gtk::Widget::set_flags()</a>. 
</div>
</div><p>
<a class="anchor" name="d3fa2306342cd74a022f8b901ee04525"></a><!-- doxytag: member="Xfc::Gtk::Window::activate_default" ref="d3fa2306342cd74a022f8b901ee04525" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::activate_default           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Activate the default widget. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the default widget was activatable.</dd></dl>
Activation is what happens when you press Enter on a widget during key navigation; clicking a button, selecting a menu item, etc. If the default widget isn't activatable, then the current focused widget will be activated. If the focused widget isn't activatable, this method returns false. 
</div>
</div><p>
<a class="anchor" name="c0784ba51aebb9dc07972a40776f8dc5"></a><!-- doxytag: member="Xfc::Gtk::Window::set_transient_for" ref="c0784ba51aebb9dc07972a40776f8dc5" args="(Window *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_transient_for           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classXfc_1_1Gtk_1_1Dialog.html">Dialog</a> windows should be set transient for the main application window they were spawned from. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>The parent window.</td></tr>
  </table>
</dl>
This method allows window managers to e.g. keep a dialog on top of the main window, or center the dialog over the main window. 
</div>
</div><p>
<a class="anchor" name="e8f4d750f5ec5303767336c6099750fb"></a><!-- doxytag: member="Xfc::Gtk::Window::set_type_hint" ref="e8f4d750f5ec5303767336c6099750fb" args="(Gdk::WindowTypeHint hint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_type_hint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#7bc9d7170459002f90922e5ece04678c">Gdk::WindowTypeHint</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
By setting the type hint for the window, you allow the window manager to decorate and handle the window in a way which is suitable to the function of the window in your application. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hint</em>&nbsp;</td><td>The window type.</td></tr>
  </table>
</dl>
This method should be called before the window becomes visible. <a class="el" href="classXfc_1_1Gtk_1_1Dialog.html">Gtk::Dialog</a> will sometimes call <a class="el" href="classXfc_1_1Gtk_1_1Window.html#e8f4d750f5ec5303767336c6099750fb">set_type_hint()</a> on your behalf, so you wont need to. 
</div>
</div><p>
<a class="anchor" name="07626b27d998e2d3a401530de5928f01"></a><!-- doxytag: member="Xfc::Gtk::Window::set_skip_taskbar_hint" ref="07626b27d998e2d3a401530de5928f01" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_skip_taskbar_hint           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Windows may set a hint asking the desktop environment not to display the window in the task bar; this method toggles this hint. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Set <em>true</em> to keep this window from appearing in the task bar. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b714afeaaa82587c8e027d0edc8141b5"></a><!-- doxytag: member="Xfc::Gtk::Window::set_skip_pager_hint" ref="b714afeaaa82587c8e027d0edc8141b5" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_skip_pager_hint           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Windows may set a hint asking the desktop environment not to display the window in the pager; this function toggles this hint. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Set <em>true</em> to keep this window from appearing in the pager.</td></tr>
  </table>
</dl>
A "pager" is any desktop navigation tool such as a workspace switcher that displays a thumbnail representation of the windows on the screen. 
</div>
</div><p>
<a class="anchor" name="39150af1dadd516cc41deaf48d0ee898"></a><!-- doxytag: member="Xfc::Gtk::Window::set_accept_focus" ref="39150af1dadd516cc41deaf48d0ee898" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_accept_focus           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a hint telling the desktop environment whether or not this window should receive the input focus. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Set <em>true</em> to let this window receive the input focus. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ed4d50f21fd8f0ddf8f875b76f26a7d1"></a><!-- doxytag: member="Xfc::Gtk::Window::set_focus_on_map" ref="ed4d50f21fd8f0ddf8f875b76f26a7d1" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_focus_on_map           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a hint telling the desktop environment whether or not this window should receive the input focus when mapped. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Set to true to let this window receive input focus on map. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4b6efa7e339d5d74aa57e6865c3c4f30"></a><!-- doxytag: member="Xfc::Gtk::Window::set_destroy_with_parent" ref="4b6efa7e339d5d74aa57e6865c3c4f30" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_destroy_with_parent           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If setting is true, then destroying the transient parent of window will also destroy the window itself. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Whether to destroy window with its transient parent.</td></tr>
  </table>
</dl>
This is useful for dialogs that shouldn't persist beyond the lifetime of the main window they're associated with, for example. 
</div>
</div><p>
<a class="anchor" name="7306d3ea119c6e6404ac41b189b8e742"></a><!-- doxytag: member="Xfc::Gtk::Window::set_resizable" ref="7306d3ea119c6e6404ac41b189b8e742" args="(bool resizable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_resizable           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>resizable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether the user can resize a window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resizable</em>&nbsp;</td><td><em>true</em> if the user can resize this window.</td></tr>
  </table>
</dl>
Windows are user resizable by default. 
</div>
</div><p>
<a class="anchor" name="88d7aa5cb69343d848a8d68ec3317714"></a><!-- doxytag: member="Xfc::Gtk::Window::set_gravity" ref="88d7aa5cb69343d848a8d68ec3317714" args="(Gdk::Gravity gravity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_gravity           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#707ee0aacf7d421c407ec5674e037e0e">Gdk::Gravity</a>&nbsp;</td>
          <td class="paramname"> <em>gravity</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> gravity defines the meaning of coordinates passed to <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a> (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a> and <a class="el" href="namespaceXfc_1_1Gdk.html#707ee0aacf7d421c407ec5674e037e0e">Gdk::Gravity</a> for more details). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gravity</em>&nbsp;</td><td>The window gravity</td></tr>
  </table>
</dl>
The default window gravity is GRAVITY_NORTH_WEST which will typically "do what you mean." 
</div>
</div><p>
<a class="anchor" name="93e8900077f3aa8274248734705f619c"></a><!-- doxytag: member="Xfc::Gtk::Window::set_geometry_hints" ref="93e8900077f3aa8274248734705f619c" args="(Widget *geometry_widget, const Gdk::Geometry &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_geometry_hints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> *&nbsp;</td>
          <td class="paramname"> <em>geometry_widget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Geometry.html">Gdk::Geometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets up hints about how a window can be resized by the user. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geometry_widget</em>&nbsp;</td><td>The widget the geometry hints will be applied to, or null for the toplevel widget. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geometry</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Geometry.html">Gdk::Geometry</a> object containing geometry information.</td></tr>
  </table>
</dl>
You can set a minimum and maximum size; allowed resize increments (e.g. for xterm, you can only resize by the size of a character); aspect ratios; and more. See the <a class="el" href="classXfc_1_1Gdk_1_1Geometry.html">Gdk::Geometry</a>. 
</div>
</div><p>
<a class="anchor" name="46e1ad25fabfe4483b5f0d420eabbd8d"></a><!-- doxytag: member="Xfc::Gtk::Window::set_screen" ref="46e1ad25fabfe4483b5f0d420eabbd8d" args="(const Gdk::Screen &amp;screen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_screen           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>screen</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a> where the window is displayed; if the window is already mapped, it will be unmapped, and then remapped on the new screen. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screen</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0343cbd8d48bb289501e1cfcf650c940"></a><!-- doxytag: member="Xfc::Gtk::Window::set_has_frame" ref="0343cbd8d48bb289501e1cfcf650c940" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_has_frame           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a special-purpose method for the framebuffer port, that causes GTK+ to draw its own window border. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Set <em>true</em> if the window is to have a frame.</td></tr>
  </table>
</dl>
For most applications, you want <a class="el" href="classXfc_1_1Gtk_1_1Window.html#bdad0041d92dcf049c92d16747220140">set_decorated()</a> instead, which tells the window manager whether to draw the window border. If this method is called on a window with setting of true, before it is realized or showed, it will have a "frame" window around window-&gt;window, accessible in <a class="el" href="classXfc_1_1Gtk_1_1Window.html#242fca67f60aa64ad4c2da84d2a5894b">gtk_window()</a>-&gt;frame. Using the signal frame_event you can recieve all events targeted at the frame.<p>
This method is used by the linux-fb port to implement managed windows, but it could concievably be used by X-programs that want to do their own window decorations. 
</div>
</div><p>
<a class="anchor" name="fdf287ddc2eb5a0ad12f6e9c817eca0b"></a><!-- doxytag: member="Xfc::Gtk::Window::set_frame_dimensions" ref="fdf287ddc2eb5a0ad12f6e9c817eca0b" args="(int left, int top, int right, int bottom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_frame_dimensions           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bottom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
(Note: this is a special-purpose method intended for the framebuffer port; see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0343cbd8d48bb289501e1cfcf650c940">set_has_frame()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>The width of the left border. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>top</em>&nbsp;</td><td>The height of the top border. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>right</em>&nbsp;</td><td>The width of the right border. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bottom</em>&nbsp;</td><td>The height of the bottom border.</td></tr>
  </table>
</dl>
This method will have no effect on the window border drawn by the window manager, which is the normal case when using the X <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> system. For windows with frames (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#0343cbd8d48bb289501e1cfcf650c940">set_has_frame()</a>) this method can be used to change the size of the frame border. 
</div>
</div><p>
<a class="anchor" name="bdad0041d92dcf049c92d16747220140"></a><!-- doxytag: member="Xfc::Gtk::Window::set_decorated" ref="bdad0041d92dcf049c92d16747220140" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_decorated           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ask the window manager to decorate or not decorate the window with a title bar, etc. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Set <em>true</em> to decorate the window.</td></tr>
  </table>
</dl>
By default, windows are decorated with a title bar, resize controls, etc. Some window managers allow GTK+ to disable these decorations, creating a borderless window. If you set the decorated property to false using this function, GTK+ will do its best to convince the window manager not to decorate the window. Depending on the system, this function may not have any effect when called on a window that is already visible, so you should call it before calling <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#89dc83a4d424c700b9dc9430d18c9fc0">Gtk::Widget::show()</a>. 
</div>
</div><p>
<a class="anchor" name="c37316a8d5906e459310f37afbb22c6d"></a><!-- doxytag: member="Xfc::Gtk::Window::set_icon_list" ref="c37316a8d5906e459310f37afbb22c6d" args="(std::vector&lt; Gdk::Pixbuf * &gt; &amp;icons)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_icon_list           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>icons</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up the icon representing the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>icons</em>&nbsp;</td><td>A reference to a vector of <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a>* that holds the list.</td></tr>
  </table>
</dl>
The icon is used when the window is minimized (also known as iconified). Some window managers or desktop environments may also place it in the window frame, or display it in other contexts. <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a> allows you to pass in the same icon in several hand-drawn sizes. The list should contain the natural sizes your icon is available in; that is, don't scale the image before passing it to GTK+. Scaling is postponed until the last minute, when the desired final size is known, to allow best quality. By passing several sizes, you may improve the final image quality of the icon, by reducing or eliminating automatic image scaling. Recommended sizes to provide: 16x16, 32x32, 48x48 at minimum, and larger images (64x64, 128x128) if you have them. See also <a class="el" href="classXfc_1_1Gtk_1_1Window.html#dde1c4f76c6ad7fad676fb88a7233409">set_default_icon_list()</a> to set the icon for all windows in your application in one go.<p>
Note that transient windows (those who have been set transient for another window using <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c0784ba51aebb9dc07972a40776f8dc5">set_transient_for()</a>) will inherit their icon from their transient parent. So there's no need to explicitly set the icon on transient windows. 
</div>
</div><p>
<a class="anchor" name="7c5750ac3f8bb3d268d6bad8f8209a95"></a><!-- doxytag: member="Xfc::Gtk::Window::set_icon" ref="7c5750ac3f8bb3d268d6bad8f8209a95" args="(Gdk::Pixbuf &amp;icon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_icon           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>icon</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up the icon representing the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>icon</em>&nbsp;</td><td>The icon image, or null.</td></tr>
  </table>
</dl>
This icon is used when the window is minimized (also known as iconified). Some window managers or desktop environments may also place it in the window frame, or display it in other contexts. The icon should be provided in whatever size it was naturally drawn; that is, don't scale the image before passing it to GTK+. Scaling is postponed until the last minute, when the desired final size is known, to allow best quality. If you have your icon hand-drawn in multiple sizes, use <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a>. Then the best size will be used. This method is equivalent to calling <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a> with one element in the list. See also <a class="el" href="classXfc_1_1Gtk_1_1Window.html#dde1c4f76c6ad7fad676fb88a7233409">set_default_icon_list()</a> to set the icon for all windows in your application in one go. 
</div>
</div><p>
<a class="anchor" name="aa0a0f9894647007607fd1a82b50bcc1"></a><!-- doxytag: member="Xfc::Gtk::Window::set_icon_name" ref="aa0a0f9894647007607fd1a82b50bcc1" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_icon_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the icon for the window from a named themed icon. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the themed icon.</td></tr>
  </table>
</dl>
See the docs for <a class="el" href="classXfc_1_1Gtk_1_1IconTheme.html">Gtk::IconTheme</a> for more details. Note that this method has nothing to do with the WM_ICON_NAME property which is mentioned in the ICCCM. 
</div>
</div><p>
<a class="anchor" name="90613c361d986fcdd9844fef0d973908"></a><!-- doxytag: member="Xfc::Gtk::Window::set_icon_from_file" ref="90613c361d986fcdd9844fef0d973908" args="(const String &amp;filename, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::set_icon_from_file           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the icon for the window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The location of the icon file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location of a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> object to store any error, or null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if setting the icon succeeded.</dd></dl>
This method is equivalent to calling <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7c5750ac3f8bb3d268d6bad8f8209a95">set_icon()</a> with a pixbuf created by loading the image from <em>filename</em>. There are several examples of using <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> in the source code for gfc-demo program.<p>
<b>Note:</b> Warns on failure if error is null. 
</div>
</div><p>
<a class="anchor" name="3d65e729e09373f8b05f3fd8afa7b523"></a><!-- doxytag: member="Xfc::Gtk::Window::set_modal" ref="3d65e729e09373f8b05f3fd8afa7b523" args="(bool modal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_modal           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>modal</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a window modal or non-modal. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>modal</em>&nbsp;</td><td>Whether the window is modal.</td></tr>
  </table>
</dl>
Modal windows prevent interaction with other windows in the same application. To keep modal dialogs on top of the main application windows, use <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c0784ba51aebb9dc07972a40776f8dc5">set_transient_for()</a> to make the dialog transient for the parent; most window managers will then disallow lowering the dialog below the parent. 
</div>
</div><p>
<a class="anchor" name="c12891acc5eab8abdf32a1e77555c738"></a><!-- doxytag: member="Xfc::Gtk::Window::add_mnemonic" ref="c12891acc5eab8abdf32a1e77555c738" args="(unsigned int keyval, Widget &amp;target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::add_mnemonic           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>keyval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a mnemonic to this window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyval</em>&nbsp;</td><td>The mnemonic. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The widget that gets activated by the mnemonic. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c4373af49f70c23a87d552201c615dbb"></a><!-- doxytag: member="Xfc::Gtk::Window::remove_mnemonic" ref="c4373af49f70c23a87d552201c615dbb" args="(unsigned int keyval, Widget &amp;target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::remove_mnemonic           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>keyval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a mnemonic from this window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyval</em>&nbsp;</td><td>The mnemonic. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The widget that gets activated by the mnemonic. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="30509f2791b13451852ae9f496a3a22a"></a><!-- doxytag: member="Xfc::Gtk::Window::mnemonic_activate" ref="30509f2791b13451852ae9f496a3a22a" args="(unsigned int keyval, Gdk::ModifierTypeField modifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::mnemonic_activate           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>keyval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">Gdk::ModifierTypeField</a>&nbsp;</td>
          <td class="paramname"> <em>modifier</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Activates the targets associated with the mnemonic. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyval</em>&nbsp;</td><td>The mnemonic. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modifier</em>&nbsp;</td><td>The modifiers </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the activation is done. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bcfa5954379e30fc26466d558fd7bb37"></a><!-- doxytag: member="Xfc::Gtk::Window::set_mnemonic_modifier" ref="bcfa5954379e30fc26466d558fd7bb37" args="(Gdk::ModifierTypeField modifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_mnemonic_modifier           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">Gdk::ModifierTypeField</a>&nbsp;</td>
          <td class="paramname"> <em>modifier</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mnemonic modifier for this window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>modifier</em>&nbsp;</td><td>The modifier mask used to activate mnemonics on this window. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="97cb54c8291e13ea02fd316e50892b19"></a><!-- doxytag: member="Xfc::Gtk::Window::activate_key" ref="97cb54c8291e13ea02fd316e50892b19" args="(const Gdk::EventKey &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::activate_key           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1EventKey.html">Gdk::EventKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Activates mnemonics and accelerators for this window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1EventKey.html">Gdk::EventKey</a> event </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if a mnemonic or accelerator was found and activated.</dd></dl>
This is normally called by the default <em>key_press_event</em> handler for toplevel windows, however in some cases it may be useful to call this directly when overriding the standard key handling for a toplevel window. 
</div>
</div><p>
<a class="anchor" name="e8db50391ac58721b702622f8c877092"></a><!-- doxytag: member="Xfc::Gtk::Window::propagate_key_event" ref="e8db50391ac58721b702622f8c877092" args="(const Gdk::EventKey &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::propagate_key_event           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1EventKey.html">Gdk::EventKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Propagate a key press or release event to the focus widget and up the focus container chain until a widget handles <em>event</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Gdk_1_1EventKey.html">Gdk::EventKey</a> event </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if a widget in the focus chain handled the event.</dd></dl>
This is normally called by the default <em>key_press_event</em> and <em>key_release_event</em> handlers for toplevel windows, however in some cases it may be useful to call this directly when overriding the standard key handling for a toplevel window. 
</div>
</div><p>
<a class="anchor" name="989fb247d36058c20ff009ef3ffe3266"></a><!-- doxytag: member="Xfc::Gtk::Window::present" ref="989fb247d36058c20ff009ef3ffe3266" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::present           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Presents a window to the user. 
<p>
This may mean raising the window in the stacking order, deiconifying it, moving it to the current desktop, and/or giving it the keyboard focus, possibly dependent on the user's platform, window manager, and preferences. If the window is hidden, this method calls <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#89dc83a4d424c700b9dc9430d18c9fc0">Gtk::Widget::show()</a> as well. This method should be used when the user tries to open a window that's already open. Say for example the preferences dialog is currently open, and the user chooses Preferences from the menu a second time; use <a class="el" href="classXfc_1_1Gtk_1_1Window.html#989fb247d36058c20ff009ef3ffe3266">present()</a> to move the already-open dialog where the user can see it. 
</div>
</div><p>
<a class="anchor" name="f08e9d7463a7fd859fe76f4b52c6a03a"></a><!-- doxytag: member="Xfc::Gtk::Window::iconify" ref="f08e9d7463a7fd859fe76f4b52c6a03a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::iconify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to iconify (minimize) the specified window. 
<p>
Note that you shouldn't assume the window is definitely iconified afterward, because other entities (e.g. the user or window manager) could deiconify it again, or there may not be a window manager in which case iconification isn't possible, etc. But normally the window will end up iconified. Just don't write code that crashes if not. It's permitted to call this method before showing a window, in which case the window will be iconified before it ever appears onscreen. You can track iconification via the "window_state_event" signal on the window. 
</div>
</div><p>
<a class="anchor" name="5c6cdd7a8cd195a8a52b7fc97b8c8dac"></a><!-- doxytag: member="Xfc::Gtk::Window::deiconify" ref="5c6cdd7a8cd195a8a52b7fc97b8c8dac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::deiconify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to deiconify (unminimize) the specified window. 
<p>
Note that you shouldn't assume the window is definitely deiconified afterward, because other entities (e.g. the user or window manager) could iconify it again before your code which assumes deiconification gets to run. You can track iconification via the "window_state_event" signal on the window. 
</div>
</div><p>
<a class="anchor" name="0ddf327ef5eaca7e1d3544a51a07d4b6"></a><!-- doxytag: member="Xfc::Gtk::Window::stick" ref="0ddf327ef5eaca7e1d3544a51a07d4b6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::stick           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to stick the window, which means that it will appear on all user desktops. 
<p>
Note that you shouldn't assume the window is definitely stuck afterward, because other entities (e.g. the user or window manager) could unstick it again, and some window managers do not support sticking windows. But normally the window will end up stuck. Just don't write code that crashes if not. It's permitted to call this method before showing a window. You can track stickiness via the "window_state_event" signal on the window. 
</div>
</div><p>
<a class="anchor" name="c2d77af7104e871e2787984d014d62e6"></a><!-- doxytag: member="Xfc::Gtk::Window::unstick" ref="c2d77af7104e871e2787984d014d62e6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::unstick           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to unstick the window, which means that it will appear on only one of the user's desktops. 
<p>
Note that you shouldn't assume the window is definitely unstuck afterward, because other entities (e.g. the user or window manager) could stick it again. But normally the window will end up stuck. Just don't write code that crashes if not. You can track stickiness via the "window_state_event" signal on the window. 
</div>
</div><p>
<a class="anchor" name="7a0e75f04eb698cec542e96af1119ea1"></a><!-- doxytag: member="Xfc::Gtk::Window::maximize" ref="7a0e75f04eb698cec542e96af1119ea1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::maximize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to maximize window, so that it becomes full-screen. 
<p>
Note that you shouldn't assume the window is definitely maximized afterward, because other entities (e.g. the user or window manager) could unmaximize it again, and not all window managers support maximization. But normally the window will end up maximized. Just don't write code that crashes if not. It's permitted to call this method before showing a window, in which case the window will be maximized when it appears onscreen initially. You can track maximization via the "window_state_event" signal on the window. 
</div>
</div><p>
<a class="anchor" name="45f332ec89dfe2f843a4edf7902bd424"></a><!-- doxytag: member="Xfc::Gtk::Window::unmaximize" ref="45f332ec89dfe2f843a4edf7902bd424" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::unmaximize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to unmaximize window. 
<p>
Note that you shouldn't assume the window is definitely unmaximized afterward, because other entities (e.g. the user or window manager) could maximize it again, and not all window managers honor requests to unmaximize. But normally the window will end up unmaximized. Just don't write code that crashes if not. You can track maximization via the "window_state_event" signal on the window. 
</div>
</div><p>
<a class="anchor" name="91901d0d4eed2aa24ef2a71acb1dbd66"></a><!-- doxytag: member="Xfc::Gtk::Window::fullscreen" ref="91901d0d4eed2aa24ef2a71acb1dbd66" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::fullscreen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to place the window in the fullscreen state. 
<p>
Note that you shouldn't assume the window is definitely full screen afterward, because other entities (e.g. the user or window manager) could unfullscreen it again, and not all window managers honor requests to fullscreen windows. But normally the window will end up fullscreen. Just don't write code that crashes if not. You can track the fullscreen state via the <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a> "window_state_event" signal. 
</div>
</div><p>
<a class="anchor" name="401e9b68077a86cd5f83b169dd504f3a"></a><!-- doxytag: member="Xfc::Gtk::Window::unfullscreen" ref="401e9b68077a86cd5f83b169dd504f3a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::unfullscreen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to toggle off the fullscreen state for the window. 
<p>
Note that you shouldn't assume the window is definitely not full screen afterward, because other entities (e.g. the user or window manager) could fullscreen it again, and not all window managers honor requests to unfullscreen windows. But normally the window will end up restored to its normal state. Just don't write code that crashes if not. You can track the fullscreen state via the <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a> "window_state_event" signal. 
</div>
</div><p>
<a class="anchor" name="b466bb0ab91bd21b5033ec52e6a8ab59"></a><!-- doxytag: member="Xfc::Gtk::Window::set_keep_above" ref="b466bb0ab91bd21b5033ec52e6a8ab59" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_keep_above           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to keep the window above, so that it stays on top. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Whether to keep window above other windows.</td></tr>
  </table>
</dl>
Note that you shouldn't assume the window is definitely above afterward, because other entities (e.g. the user or window manager) could not keep it above, and not all window managers support keeping windows above. But normally the window will end up kept above. Just don't write code that crashes if not.<p>
It's permitted to call this function before showing a window, in which case the window will be kept above when it appears onscreen initially. You can track the above state via the <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a> <em>window_state_event</em> signal.<p>
Note that, according to the Extended <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> Manager Hints specification, the above state is mainly meant for user preferences and should not be used by applications e.g. for drawing attention to their dialogs. 
</div>
</div><p>
<a class="anchor" name="4d68f70efa1c61bdecbba29a142b1f73"></a><!-- doxytag: member="Xfc::Gtk::Window::set_keep_below" ref="4d68f70efa1c61bdecbba29a142b1f73" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_keep_below           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to keep window below, so that it stays in bottom. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Whether to keep window below other windows.</td></tr>
  </table>
</dl>
Note that you shouldn't assume the window is definitely below afterward, because other entities (e.g. the user or window manager) could not keep it below, and not all window managers support putting windows below. But normally the window will be kept below. Just don't write code that crashes if not.<p>
It's permitted to call this function before showing a window, in which case the window will be kept below when it appears onscreen initially. You can track the below state via the <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a> <em>window_state_event</em> signal.<p>
Note that, according to the Extended <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> Manager Hints specification, the above state is mainly meant for user preferences and should not be used by applications e.g. for drawing attention to their dialogs. 
</div>
</div><p>
<a class="anchor" name="5c91e8d7f5bef2a590e3acb95093f753"></a><!-- doxytag: member="Xfc::Gtk::Window::begin_resize_drag" ref="5c91e8d7f5bef2a590e3acb95093f753" args="(Gdk::WindowEdge edge, int button, int root_x, int root_y, unsigned int timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::begin_resize_drag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXfc_1_1Gdk.html#0e823b84cf97c36c12abce34415e9e39">Gdk::WindowEdge</a>&nbsp;</td>
          <td class="paramname"> <em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts resizing a window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge</em>&nbsp;</td><td>The position of the resize control. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>button</em>&nbsp;</td><td>The mouse button that initiated the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_x</em>&nbsp;</td><td>The X position where the user clicked to initiate the drag, in root window coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_y</em>&nbsp;</td><td>The Y position where the user clicked to initiate the drag in root window coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>The timestamp from the click event that initiated the drag.</td></tr>
  </table>
</dl>
This mehod is used if an application has window resizing controls. When GDK can support it, the resize will be done using the standard mechanism for the window manager or windowing system. Otherwise, GDK will try to emulate window resizing, potentially not all that well, depending on the windowing system. 
</div>
</div><p>
<a class="anchor" name="ef507e074f532bd2e01313596e616106"></a><!-- doxytag: member="Xfc::Gtk::Window::begin_move_drag" ref="ef507e074f532bd2e01313596e616106" args="(int button, int root_x, int root_y, unsigned int timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::begin_move_drag           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts moving a window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>button</em>&nbsp;</td><td>The mouse button that initiated the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_x</em>&nbsp;</td><td>The X position where the user clicked to initiate the drag, in root window coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_y</em>&nbsp;</td><td>The Y position where the user clicked to initiate the drag in root window coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>The timestamp from the click event that initiated the drag.</td></tr>
  </table>
</dl>
This method is used if an application has window movement grips. When GDK can support it, the window movement will be done using the standard mechanism for the window manager or windowing system. Otherwise, GDK will try to emulate window movement, potentially not all that well, depending on the windowing system. 
</div>
</div><p>
<a class="anchor" name="228cb8888b8ce0ed08ce4f13c503065f"></a><!-- doxytag: member="Xfc::Gtk::Window::set_default_size" ref="228cb8888b8ce0ed08ce4f13c503065f" args="(int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::set_default_size           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the default size of a window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width in pixels, or -1 to unset the default width. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height in pixels, or -1 to unset the default height.</td></tr>
  </table>
</dl>
If the window's "natural" size (its size request) is larger than the default, the default will be ignored. More generally, if the default size does not obey the geometry hints for the window (<a class="el" href="classXfc_1_1Gtk_1_1Window.html#93e8900077f3aa8274248734705f619c">set_geometry_hints()</a> can be used to set these explicitly), the default size will be clamped to the nearest permitted size.<p>
Unlike <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#24e094379581001370a84c3e734b5086">set_size_request()</a>, which sets a size request for a widget and thus would keep users from shrinking the window, this method only sets the initial size, just as if the user had resized the window themselves. Users can still shrink the window again as they normally would. Setting a default size of -1 means to use the "natural" default size (the size request of the window).<p>
For more control over a window's initial size and how resizing works, investigate <a class="el" href="classXfc_1_1Gtk_1_1Window.html#93e8900077f3aa8274248734705f619c">set_geometry_hints()</a>. For some uses, <a class="el" href="classXfc_1_1Gtk_1_1Window.html#45111b49a7d1569a6f3f5b1c6cb9a86a">resize()</a> is a more appropriate method. <a class="el" href="classXfc_1_1Gtk_1_1Window.html#45111b49a7d1569a6f3f5b1c6cb9a86a">resize()</a> changes the current size of the window, rather than the size to be used on initial display. <a class="el" href="classXfc_1_1Gtk_1_1Window.html#45111b49a7d1569a6f3f5b1c6cb9a86a">resize()</a> always affects the window itself, not the geometry widget. The default size of a window only affects the first time a window is shown; if a window is hidden and re-shown, it will remember the size it had prior to hiding, rather than using the default size. Windows can't actually be 0x0 in size, they must be at least 1x1, but passing 0 for width and height is OK, resulting in a 1x1 default size. 
</div>
</div><p>
<a class="anchor" name="45111b49a7d1569a6f3f5b1c6cb9a86a"></a><!-- doxytag: member="Xfc::Gtk::Window::resize" ref="45111b49a7d1569a6f3f5b1c6cb9a86a" args="(int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::resize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resizes the window as if the user had done so, obeying geometry constraints. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width in pixels to resize the window to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height in pixels to resize the window to.</td></tr>
  </table>
</dl>
The default geometry constraint is that windows may not be smaller than their size request; to override this constraint, call <a class="el" href="classXfc_1_1Gtk_1_1Widget.html#24e094379581001370a84c3e734b5086">Gtk::Widget::set_size_request()</a> to set the window's request to a smaller value. If <a class="el" href="classXfc_1_1Gtk_1_1Window.html#45111b49a7d1569a6f3f5b1c6cb9a86a">resize()</a> is called before showing a window for the first time, it overrides any default size set with <a class="el" href="classXfc_1_1Gtk_1_1Window.html#228cb8888b8ce0ed08ce4f13c503065f">set_default_size()</a>. Windows may not be resized smaller than 1 by 1 pixels. 
</div>
</div><p>
<a class="anchor" name="a383173d70e178817c4fbdbd5d475890"></a><!-- doxytag: member="Xfc::Gtk::Window::move" ref="a383173d70e178817c4fbdbd5d475890" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::move           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks the window manager to move window to the given position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X coordinate to move window to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y coordinate to move window to.</td></tr>
  </table>
</dl>
<a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> managers are free to ignore this; most window managers ignore requests for initial window positions (instead using a user-defined placement algorithm) and honor requests after the window has already been shown.<p>
Note: the position is the position of the gravity-determined reference point for the window. The gravity determines two things: first, the location of the reference point in root window coordinates; and second, which point on the window is positioned at the reference point. By default the gravity is GRAVITY_NORTH_WEST, so the reference point is simply the x, y supplied to <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a>. The top-left corner of the window decorations (aka window frame or border) will be placed at x, y. Therefore, to position a window at the top left of the screen, you want to use the default gravity (which is GRAVITY_NORTH_WEST) and move the window to 0,0. To position a window at the bottom right corner of the screen, you would set GRAVITY_SOUTH_EAST, which means that the reference point is at x + the window width and y + the window height, and the bottom-right corner of the window border will be placed at that reference point. So, to place a window in the bottom right corner you would first set gravity to south east, then write: <div class="fragment"><pre class="fragment">&lt; <a class="code" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move</a>(gdk_screen_width() - window_width, gdk_screen_height() - window_height). 
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="89b23518137576b034eea69775ca9214"></a><!-- doxytag: member="Xfc::Gtk::Window::move" ref="89b23518137576b034eea69775ca9214" args="(const Gdk::Point &amp;point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::move           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Gdk::Point</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks the window manager to move window to the given point (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move(int, int)</a>). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>The X,Y coordinates to move window to, as a <a class="el" href="classXfc_1_1Gdk_1_1Point.html">Gdk::Point</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ce6fcf8403fbfcd2a1b65b55d868400b"></a><!-- doxytag: member="Xfc::Gtk::Window::parse_geometry" ref="ce6fcf8403fbfcd2a1b65b55d868400b" args="(const String &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Gtk::Window::parse_geometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses a standard X <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Window</a> System geometry string - see the manual page for X (type 'man X') for details on this. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geometry</em>&nbsp;</td><td>The geometry string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if string was parsed successfully.</dd></dl>
This method does work on all GTK+ ports including Win32 but is primarily intended for an X environment. If either a size or a position can be extracted from the geometry string, parse_geometry() returns true and calls <a class="el" href="classXfc_1_1Gtk_1_1Window.html#228cb8888b8ce0ed08ce4f13c503065f">set_default_size()</a> and/or <a class="el" href="classXfc_1_1Gtk_1_1Window.html#a383173d70e178817c4fbdbd5d475890">move()</a> to resize/move the window. If parse_geometry() returns true, it will also set the Gdk::HINT_USER_POS and/or Gdk::HINT_USER_SIZE hints indicating to the window manager that the size/position of the window was user-specified. This causes most window managers to honor the geometry. 
</div>
</div><p>
<a class="anchor" name="6039dcb928be22a669d7e41c74fc352d"></a><!-- doxytag: member="Xfc::Gtk::Window::show_about_dialog" ref="6039dcb928be22a669d7e41c74fc352d" args="(Gdk::Pixbuf *logo, const String &amp;name, const String &amp;version, const String &amp;comments, const String &amp;copyright, const String &amp;website=0, const std::vector&lt; String &gt; *authors=0, const std::vector&lt; String &gt; *documenters=0, const String &amp;license=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Gtk::Window::show_about_dialog           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>logo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>comments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyright</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>website</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXfc_1_1String.html">String</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>authors</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXfc_1_1String.html">String</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>documenters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>license</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A convenience function for showing an application's about dialog box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>logo</em>&nbsp;</td><td>The pixbuf to display as the logo in the about dialog, or null for none. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the program. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>The version of the program. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comments</em>&nbsp;</td><td>A short explanation of the main purpose of the program, not a detailed list of features. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copyright</em>&nbsp;</td><td>The copyright information for the program. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>website</em>&nbsp;</td><td>The URL for the link to the website of the program starting with "http://", or null for none. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>authors</em>&nbsp;</td><td>The authors of the program as a vector of <a class="el" href="classXfc_1_1String.html">String</a>, or null for none. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>documenters</em>&nbsp;</td><td>The people documenting the program as a vector of <a class="el" href="classXfc_1_1String.html">String</a>, or null for none. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>license</em>&nbsp;</td><td>The license of the program, or null for none.</td></tr>
  </table>
</dl>
The constructed dialog is associated with this parent window and reused for future invocations of this method. If you require any more functionality than this you will need to create and manage your own <a class="el" href="classXfc_1_1Gtk_1_1AboutDialog.html">Gtk::AboutDialog</a>.<p>
Each string in the authors and documenters vectors may contain email addresses and URLs, which will be displayed as links. Email addresses are recognized by looking for &lt;user@host&gt;, URLs are recognized by looking for <a href="http://url,">http://url,</a> with url extending to the next space, tab or line break. The license string is displayed in a text view in a secondary dialog, therefore it is fine to use a long text with multiple paragraphs. Note that the text is not wrapped in the text view, thus it must contain the intended linebreaks. 
</div>
</div><p>
<a class="anchor" name="cab255fb9f713fb078dda94666888c84"></a><!-- doxytag: member="Xfc::Gtk::Window::list_toplevels" ref="cab255fb9f713fb078dda94666888c84" args="(std::vector&lt; Widget * &gt; &amp;toplevels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Xfc::Gtk::Window::list_toplevels           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Widget</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>toplevels</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a list of all existing toplevel windows. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>toplevels</em>&nbsp;</td><td>A reference to a vector of Widget* to hold the list. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the vector is not empty.</dd></dl>
The widgets in the list are not individually referenced. If you want to iterate through the list and perform actions involving callbacks that might destroy the widgets, you must call <a class="el" href="classXfc_1_1Gtk_1_1Object.html#60fabe4bda00b4ef724a14fb67be5c45">ref()</a> on all the widgets first, and then <a class="el" href="classXfc_1_1G_1_1Object.html#513fc400272db0db24d32f9a280e64a5">unref()</a> all the widgets afterwards. 
</div>
</div><p>
<a class="anchor" name="dde1c4f76c6ad7fad676fb88a7233409"></a><!-- doxytag: member="Xfc::Gtk::Window::set_default_icon_list" ref="dde1c4f76c6ad7fad676fb88a7233409" args="(std::vector&lt; Gdk::Pixbuf * &gt; &amp;icons)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Gtk::Window::set_default_icon_list           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>icons</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an icon list to be used as fallback for windows that haven't had <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a> called on them to set up a window-specific icon list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>icons</em>&nbsp;</td><td>A reference to a vector of <a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a>* that holds the list.</td></tr>
  </table>
</dl>
This method allows you to set up the icon for all windows in your application at once. See <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a> for more details. 
</div>
</div><p>
<a class="anchor" name="d1928df5d78a0af499711fdb778e230c"></a><!-- doxytag: member="Xfc::Gtk::Window::set_default_icon" ref="d1928df5d78a0af499711fdb778e230c" args="(Gdk::Pixbuf &amp;icon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Gtk::Window::set_default_icon           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Gdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>icon</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an icon to be used as fallback for windows that haven't had <a class="el" href="classXfc_1_1Gtk_1_1Window.html#7c5750ac3f8bb3d268d6bad8f8209a95">set_icon()</a> called on them from a pixbuf. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>icon</em>&nbsp;</td><td>The icon. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ccd275dcaf5746327b64515b1b191e41"></a><!-- doxytag: member="Xfc::Gtk::Window::set_default_icon_name" ref="ccd275dcaf5746327b64515b1b191e41" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Gtk::Window::set_default_icon_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an icon to be used as a fallback for windows that haven't had <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a> called on them for a named themed icon (see set_icon_name()). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the themed icon. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="03ae60f34efa5e7919324ec7aa0c4bf3"></a><!-- doxytag: member="Xfc::Gtk::Window::set_default_icon_from_file" ref="03ae60f34efa5e7919324ec7aa0c4bf3" args="(const String &amp;filename, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Xfc::Gtk::Window::set_default_icon_from_file           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an icon to be used as a fallback for windows that haven't had <a class="el" href="classXfc_1_1Gtk_1_1Window.html#c37316a8d5906e459310f37afbb22c6d">set_icon_list()</a> called on them from a file on disk. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The location of the icon file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location of a <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> object to store any error, or null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if setting the icon succeeded.</dd></dl>
<b>Note:</b> Warns on failure if error is null. 
</div>
</div><p>
<a class="anchor" name="03ac5c3a64117c7a39900dfce35aefe9"></a><!-- doxytag: member="Xfc::Gtk::Window::set_auto_startup_notification" ref="03ac5c3a64117c7a39900dfce35aefe9" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Gtk::Window::set_auto_startup_notification           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether to do automatic startup notification. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Set <em>true</em> to automatically do startup notification.</td></tr>
  </table>
</dl>
By default, after showing the first <a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> for each <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a>, GTK+ calls gdk_screen_notify_startup_complete(). Call this function to disable the automatic startup notification. You might do this if your first window is a splash screen, and you want to delay notification until after your real main window has been shown, for example. In that example, you would disable startup notification temporarily, show your splash screen, then re-enable it so that showing the main window would automatically result in notification. 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="af570fdd10b663781760a6200c9f3788"></a><!-- doxytag: member="Xfc::Gtk::Window::set_focus_signal" ref="af570fdd10b663781760a6200c9f3788" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">SetFocusSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#af570fdd10b663781760a6200c9f3788">Xfc::Gtk::Window::set_focus_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set focus signal (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#b44afcc86d91813efcf9eb9c2013dacd">signal_set_focus()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function(<a class="code" href="classXfc_1_1Gtk_1_1Widget.html#795fe42510abe2c532bfee98211b6005">Widget</a> *focus);
&lt; <span class="comment">// focus: The focus widget, or null if the focus is unset.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="b8b336602349cd4454c398f243a59d69"></a><!-- doxytag: member="Xfc::Gtk::Window::frame_event_signal" ref="b8b336602349cd4454c398f243a59d69" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">FrameEventSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#b8b336602349cd4454c398f243a59d69">Xfc::Gtk::Window::frame_event_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classXfc_1_1Gtk_1_1Frame.html">Frame</a> event signal (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#1710a1a74d1d5e4543f10a19eb53391e">signal_frame_event()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">bool</span> function(<span class="keyword">const</span> Gdk::Event&amp; event);
&lt; <span class="comment">// event: The Gdk::Event.</span>
&lt; <span class="comment">// return: false to allow the default frame event handler to be called.</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="dff3789fec3511ba2e1d7ddceb4ac3f4"></a><!-- doxytag: member="Xfc::Gtk::Window::keys_changed_signal" ref="dff3789fec3511ba2e1d7ddceb4ac3f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXfc_1_1G_1_1Signal.html">KeysChangedSignalType</a> <a class="el" href="classXfc_1_1Gtk_1_1Window.html#dff3789fec3511ba2e1d7ddceb4ac3f4">Xfc::Gtk::Window::keys_changed_signal</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Keys changed signal (see <a class="el" href="classXfc_1_1Gtk_1_1Window.html#5f0427faeaa5635f7c1bd7c999871c22">signal_keys_changed()</a>). 
<p>
Calls a slot with the signature: <div class="fragment"><pre>&lt; <span class="keywordtype">void</span> function();
&lt;
</pre></div> 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="gtk_2window_8hh.html">gtk/window.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
