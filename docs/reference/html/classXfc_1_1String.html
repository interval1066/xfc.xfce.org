<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="classXfc_1_1String.html">String</a></div>
<h1>Xfc::String Class Reference</h1><!-- doxytag: class="Xfc::String" -->A UTF-8 standard string compatible string class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/utfstring.hh&gt;</code>
<p>
<a href="classXfc_1_1String-members.html">List of all members.</a><h2>Public Types</h2>
<ul>
<li><a class="anchor" name="87576004293473e0f8728a14727a03e5"></a><!-- doxytag: member="Xfc::String::const_pointer" ref="87576004293473e0f8728a14727a03e5" args="" -->
typedef const char * <a class="el" href="classXfc_1_1String.html#87576004293473e0f8728a14727a03e5">const_pointer</a>
<dl class="el"><dd class="mdescRight">A constant pointer to a byte within the string. <br></dl><li><a class="anchor" name="b3fcc2f5fd663ed05a89a5968602868a"></a><!-- doxytag: member="Xfc::String::iterator" ref="b3fcc2f5fd663ed05a89a5968602868a" args="" -->
typedef <a class="el" href="classXfc_1_1Forward__StringIterator.html">Forward_StringIterator</a> <a class="el" href="classXfc_1_1String.html#b3fcc2f5fd663ed05a89a5968602868a">iterator</a>
<dl class="el"><dd class="mdescRight">The forward iterator; points to the first byte of a UTF-8 character. <br></dl><li><a class="anchor" name="1037441f79c7aee8a27c216a76cf3fc5"></a><!-- doxytag: member="Xfc::String::reverse_iterator" ref="1037441f79c7aee8a27c216a76cf3fc5" args="" -->
typedef <a class="el" href="classXfc_1_1Reverse__StringIterator.html">Reverse_StringIterator</a> <a class="el" href="classXfc_1_1String.html#1037441f79c7aee8a27c216a76cf3fc5">reverse_iterator</a>
<dl class="el"><dd class="mdescRight">The reverse iterator; points to the first byte of a UTF-8 character. <br></dl></ul>
<h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="7e85a2b7813fc07aa35c20e3384b2447"></a><!-- doxytag: member="Xfc::String::data" ref="7e85a2b7813fc07aa35c20e3384b2447" args="() const" -->
const char * <a class="el" href="classXfc_1_1String.html#7e85a2b7813fc07aa35c20e3384b2447">data</a> () const
<dl class="el"><dd class="mdescRight">Returns a constant pointer to the internal std::string data; this may or may not be null terminated. <br></dl><li><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> <a class="el" href="classXfc_1_1String.html#dfdeb437cb20716ba0b3902b4c804d7c">get_char</a> (size_t char_pos) const
<dl class="el"><dd class="mdescRight">Converts the UTF-8 byte sequence at <em>char_pos</em> to a unicode character.  <a href="#dfdeb437cb20716ba0b3902b4c804d7c"></a><br></dl><li><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> <a class="el" href="classXfc_1_1String.html#61b3a44dd05e4b3264a79852f2d3a2e2">get_char_validated</a> (size_t char_pos, size_t n_bytes=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Converts the UTF-8 byte sequence at <em>p</em> to a unicode character.  <a href="#61b3a44dd05e4b3264a79852f2d3a2e2"></a><br></dl><li>size_t <a class="el" href="classXfc_1_1String.html#7a65e6eac3aca9d55a75e97e3933f327">index</a> (size_t char_pos) const
<dl class="el"><dd class="mdescRight">Converts the character offset <em>char_pos</em> to a integer byte index.  <a href="#7a65e6eac3aca9d55a75e97e3933f327"></a><br></dl><li>size_t <a class="el" href="classXfc_1_1String.html#12f39eb0f6bcbf28e2b9ca58ce044b8e">offset</a> (<a class="el" href="classXfc_1_1String.html#87576004293473e0f8728a14727a03e5">const_pointer</a> p) const
<dl class="el"><dd class="mdescRight">Converts a constant pointer to a position within the string to a integer character offset.  <a href="#12f39eb0f6bcbf28e2b9ca58ce044b8e"></a><br></dl><li><a class="el" href="classXfc_1_1String.html#87576004293473e0f8728a14727a03e5">const_pointer</a> <a class="el" href="classXfc_1_1String.html#e96eca7fac8cdb35aeba2e88cec43de5">pointer</a> (size_t char_pos) const
<dl class="el"><dd class="mdescRight">Converts an integer character offset to a constant pointer to a position within the string.  <a href="#e96eca7fac8cdb35aeba2e88cec43de5"></a><br></dl><li>size_t <a class="el" href="classXfc_1_1String.html#6298e17cc74f5eef2e2ae204dcd406d8">length</a> () const
<dl class="el"><dd class="mdescRight">Returns the length of the string in characters.  <a href="#6298e17cc74f5eef2e2ae204dcd406d8"></a><br></dl><li>size_t <a class="el" href="classXfc_1_1String.html#80b48da9d8cd2832eab306626d6b95c6">size</a> () const
<dl class="el"><dd class="mdescRight">Returns the size of the string in bytes.  <a href="#80b48da9d8cd2832eab306626d6b95c6"></a><br></dl><li><a class="anchor" name="20233877619c204ce1b5a5bc9930d5d4"></a><!-- doxytag: member="Xfc::String::max_size" ref="20233877619c204ce1b5a5bc9930d5d4" args="() const" -->
size_t <a class="el" href="classXfc_1_1String.html#20233877619c204ce1b5a5bc9930d5d4">max_size</a> () const
<dl class="el"><dd class="mdescRight">Returns the maximum possible size of the string in bytes. <br></dl><li><a class="anchor" name="d3e9648ee72bd78380714fad02351150"></a><!-- doxytag: member="Xfc::String::capacity" ref="d3e9648ee72bd78380714fad02351150" args="() const" -->
size_t <a class="el" href="classXfc_1_1String.html#d3e9648ee72bd78380714fad02351150">capacity</a> () const
<dl class="el"><dd class="mdescRight">Returns the largest number of bytes the string can hold without reallocation. <br></dl><li><a class="anchor" name="1cc4087dae10cf553ff45cd4bf38df13"></a><!-- doxytag: member="Xfc::String::empty" ref="1cc4087dae10cf553ff45cd4bf38df13" args="() const" -->
bool <a class="el" href="classXfc_1_1String.html#1cc4087dae10cf553ff45cd4bf38df13">empty</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the string is empty. <br></dl><li><a class="anchor" name="6a559fa7f81d0f8480175198dcd093b1"></a><!-- doxytag: member="Xfc::String::null" ref="6a559fa7f81d0f8480175198dcd093b1" args="() const" -->
bool <a class="el" href="classXfc_1_1String.html#6a559fa7f81d0f8480175198dcd093b1">null</a> () const
<dl class="el"><dd class="mdescRight">Returns true if the <a class="el" href="classXfc_1_1String.html">String</a> is empty and was initialized with a null pointer. <br></dl><li><a class="anchor" name="c0310d1e8861ade4ae28d859778b6791"></a><!-- doxytag: member="Xfc::String::c_str" ref="c0310d1e8861ade4ae28d859778b6791" args="() const" -->
const char * <a class="el" href="classXfc_1_1String.html#c0310d1e8861ade4ae28d859778b6791">c_str</a> () const
<dl class="el"><dd class="mdescRight">Returns a null pointer if <a class="el" href="classXfc_1_1String.html#6a559fa7f81d0f8480175198dcd093b1">null()</a> is true; otherwise it returns a pointer to the internal character string. <br></dl><li>const std::string &amp; <a class="el" href="classXfc_1_1String.html#47ffb2d05493b6860c78492441d9e4df">str</a> () const
<dl class="el"><dd class="mdescRight">Returns a const reference to the internal std::string.  <a href="#47ffb2d05493b6860c78492441d9e4df"></a><br></dl><li><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> <a class="el" href="classXfc_1_1String.html#88c40e38b734d66ac7911a2da50de92e">at</a> (size_t char_pos) const
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1String.html#61b3a44dd05e4b3264a79852f2d3a2e2">get_char_validated()</a> to return the character at <em>char_pos</em> as unicode character.  <a href="#88c40e38b734d66ac7911a2da50de92e"></a><br></dl><li><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> <a class="el" href="classXfc_1_1String.html#01238eb949b011f16581a574e076f109">operator[]</a> (size_t char_pos) const
<dl class="el"><dd class="mdescRight">Calls <a class="el" href="classXfc_1_1String.html#dfdeb437cb20716ba0b3902b4c804d7c">get_char()</a> to return the character at <em>char_pos</em> as unicode character.  <a href="#01238eb949b011f16581a574e076f109"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Forward iterators</div></td></tr>
<ul>
<li><a class="anchor" name="c51efa1e01ca08da2f0da7e4c0b03026"></a><!-- doxytag: member="Xfc::String::begin" ref="c51efa1e01ca08da2f0da7e4c0b03026" args="() const" -->
<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> <a class="el" href="classXfc_1_1String.html#c51efa1e01ca08da2f0da7e4c0b03026">begin</a> () const
<dl class="el"><dd class="mdescRight">Returns an iterator that points to the first byte in the string. <br></dl><li><a class="anchor" name="ae91bfac97d4a48819054f63a7bc94b0"></a><!-- doxytag: member="Xfc::String::end" ref="ae91bfac97d4a48819054f63a7bc94b0" args="() const" -->
<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> <a class="el" href="classXfc_1_1String.html#ae91bfac97d4a48819054f63a7bc94b0">end</a> () const
<dl class="el"><dd class="mdescRight">Returns an iterator that points to one past the last byte in the string, usually the null terminator. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Reverse iterators</div></td></tr>
<ul>
<li><a class="anchor" name="8724a81b3cb8194ee864a61be3854271"></a><!-- doxytag: member="Xfc::String::rbegin" ref="8724a81b3cb8194ee864a61be3854271" args="() const" -->
<a class="el" href="classXfc_1_1Reverse__StringIterator.html">reverse_iterator</a> <a class="el" href="classXfc_1_1String.html#8724a81b3cb8194ee864a61be3854271">rbegin</a> () const
<dl class="el"><dd class="mdescRight">Returns an iterator that points to the first byte in the reverse string. <br></dl><li><a class="anchor" name="c969e66ea9bf7909f46c0c9624202c59"></a><!-- doxytag: member="Xfc::String::rend" ref="c969e66ea9bf7909f46c0c9624202c59" args="() const" -->
<a class="el" href="classXfc_1_1Reverse__StringIterator.html">reverse_iterator</a> <a class="el" href="classXfc_1_1String.html#c969e66ea9bf7909f46c0c9624202c59">rend</a> () const
<dl class="el"><dd class="mdescRight">Returns an iterator that points to last byte in the reverse string. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Append characters to the end of the string</div></td></tr>
<ul>
<li><a class="anchor" name="4022080fc6d5d710ad0ef6cc8f730225"></a><!-- doxytag: member="Xfc::String::append" ref="4022080fc6d5d710ad0ef6cc8f730225" args="(const String &amp;str)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#4022080fc6d5d710ad0ef6cc8f730225">append</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Append the characters in str to the end of the string. <br></dl><li><a class="anchor" name="f57d5d6340b6b707d33a60503b80d439"></a><!-- doxytag: member="Xfc::String::append" ref="f57d5d6340b6b707d33a60503b80d439" args="(const String &amp;str, size_t char_pos, size_t n_chars=npos)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#f57d5d6340b6b707d33a60503b80d439">append</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t char_pos, size_t n_chars=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>)
<dl class="el"><dd class="mdescRight">Starting at char_pos in str, append n_chars number of characters to the end of the string. <br></dl><li><a class="anchor" name="016cd6222b7be8995994847f39567ad3"></a><!-- doxytag: member="Xfc::String::append" ref="016cd6222b7be8995994847f39567ad3" args="(const char *s, size_t n_chars)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#016cd6222b7be8995994847f39567ad3">append</a> (const char *s, size_t n_chars)
<dl class="el"><dd class="mdescRight">Append n_chars number of characters from array s to the end of the string. <br></dl><li><a class="anchor" name="f2a4250be9da5f65fe5acf6df5f1f593"></a><!-- doxytag: member="Xfc::String::append" ref="f2a4250be9da5f65fe5acf6df5f1f593" args="(const char *s)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#f2a4250be9da5f65fe5acf6df5f1f593">append</a> (const char *s)
<dl class="el"><dd class="mdescRight">Append the characters is array s to the end of the string. <br></dl><li><a class="anchor" name="643b43fd61b27731cf9bb39571b30420"></a><!-- doxytag: member="Xfc::String::append" ref="643b43fd61b27731cf9bb39571b30420" args="(size_t n, char c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#643b43fd61b27731cf9bb39571b30420">append</a> (size_t n, char c)
<dl class="el"><dd class="mdescRight">Append the ascii character c to the end of the string n times. <br></dl><li><a class="anchor" name="f436d8cfa67fb38281e62af5432f4e83"></a><!-- doxytag: member="Xfc::String::append" ref="f436d8cfa67fb38281e62af5432f4e83" args="(size_t n, gunichar c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#f436d8cfa67fb38281e62af5432f4e83">append</a> (size_t n, gunichar c)
<dl class="el"><dd class="mdescRight">Convert the unicode character c to UTF-8 and append it to the string n times. <br></dl><li><a class="anchor" name="13c9f29a1a40be596f99c2bef4d5e268"></a><!-- doxytag: member="Xfc::String::append" ref="13c9f29a1a40be596f99c2bef4d5e268" args="(const gunichar *s, int n_chars, G::Error *error=0)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#13c9f29a1a40be596f99c2bef4d5e268">append</a> (const gunichar *s, int n_chars, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Convert n_chars number of unicode characters from array s to UTF-8 and append them to the end of the string; if n_chars is -1 then s is null-terminated. <br></dl><li><a class="anchor" name="ebdaabde67bc2f5540ed2574fa329e40"></a><!-- doxytag: member="Xfc::String::append" ref="ebdaabde67bc2f5540ed2574fa329e40" args="(iterator first, iterator last)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#ebdaabde67bc2f5540ed2574fa329e40">append</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> first, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> last)
<dl class="el"><dd class="mdescRight">Append the UTF-8 characters in the range first to last to the end of the string. <br></dl><li><a class="anchor" name="cab50786fbf6e665593cfc1e0c55aed8"></a><!-- doxytag: member="Xfc::String::push_back" ref="cab50786fbf6e665593cfc1e0c55aed8" args="(char c)" -->
void <a class="el" href="classXfc_1_1String.html#cab50786fbf6e665593cfc1e0c55aed8">push_back</a> (char c)
<dl class="el"><dd class="mdescRight">Append the ascii character c to the end of the string. <br></dl><li><a class="anchor" name="ff689ef8a89ea3ab2957b67bcbbaa55c"></a><!-- doxytag: member="Xfc::String::push_back" ref="ff689ef8a89ea3ab2957b67bcbbaa55c" args="(gunichar c)" -->
void <a class="el" href="classXfc_1_1String.html#ff689ef8a89ea3ab2957b67bcbbaa55c">push_back</a> (gunichar c)
<dl class="el"><dd class="mdescRight">Convert the unicode character c to UTF-8 and append it to the string. <br></dl><li><a class="anchor" name="58e8058d3349d2c102d4c506c6f7f8f4"></a><!-- doxytag: member="Xfc::String::operator+=" ref="58e8058d3349d2c102d4c506c6f7f8f4" args="(const String &amp;str)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#58e8058d3349d2c102d4c506c6f7f8f4">operator+=</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Append the characters in str to the end of the string. <br></dl><li><a class="anchor" name="30d4ebd1f36521807d1529df007e6da3"></a><!-- doxytag: member="Xfc::String::operator+=" ref="30d4ebd1f36521807d1529df007e6da3" args="(const char *s)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#30d4ebd1f36521807d1529df007e6da3">operator+=</a> (const char *s)
<dl class="el"><dd class="mdescRight">Append the characters in array s to the end of the string. <br></dl><li><a class="anchor" name="492c4bfb62e5f4d23d1ff2cec4c00e04"></a><!-- doxytag: member="Xfc::String::operator+=" ref="492c4bfb62e5f4d23d1ff2cec4c00e04" args="(char c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#492c4bfb62e5f4d23d1ff2cec4c00e04">operator+=</a> (char c)
<dl class="el"><dd class="mdescRight">Append the ascii character c to the end of the string. <br></dl><li><a class="anchor" name="42f2790373b6c8c50e8b5adeab3f38b7"></a><!-- doxytag: member="Xfc::String::operator+=" ref="42f2790373b6c8c50e8b5adeab3f38b7" args="(gunichar c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#42f2790373b6c8c50e8b5adeab3f38b7">operator+=</a> (gunichar c)
<dl class="el"><dd class="mdescRight">Convert the unicode character c to UTF-8 and append it to the string. <br></dl><li><a class="anchor" name="c50573d588c2beb7223a3515760b8990"></a><!-- doxytag: member="Xfc::String::operator+=" ref="c50573d588c2beb7223a3515760b8990" args="(const gunichar *s)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#c50573d588c2beb7223a3515760b8990">operator+=</a> (const gunichar *s)
<dl class="el"><dd class="mdescRight">Convert unicode characters in array s to UTF-8 and append them to the end of the string; the string is assumed to be null terminated. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Assign a new value to the string</div></td></tr>
<ul>
<li><a class="anchor" name="4f722e5db229029611f6510c5a483a7d"></a><!-- doxytag: member="Xfc::String::assign" ref="4f722e5db229029611f6510c5a483a7d" args="(const String &amp;str)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#4f722e5db229029611f6510c5a483a7d">assign</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Replace all the characters in the string with the characters in str. <br></dl><li><a class="anchor" name="fc29d594a73bf8e13ff0157fefad0154"></a><!-- doxytag: member="Xfc::String::assign" ref="fc29d594a73bf8e13ff0157fefad0154" args="(const String &amp;str, size_t char_pos, size_t n_chars=npos)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#fc29d594a73bf8e13ff0157fefad0154">assign</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t char_pos, size_t n_chars=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>)
<dl class="el"><dd class="mdescRight">Starting at char_pos in str, Replace all the characters in the string with n_chars number of characters. <br></dl><li><a class="anchor" name="87d5d76e3fa608efe41f2d83d9e9bb54"></a><!-- doxytag: member="Xfc::String::assign" ref="87d5d76e3fa608efe41f2d83d9e9bb54" args="(const char *s, size_t n_chars)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#87d5d76e3fa608efe41f2d83d9e9bb54">assign</a> (const char *s, size_t n_chars)
<dl class="el"><dd class="mdescRight">Replace all the characters in the string with n_chars number of characters from array s. <br></dl><li><a class="anchor" name="2f250cc359cc3a37d2659b7a61516268"></a><!-- doxytag: member="Xfc::String::assign" ref="2f250cc359cc3a37d2659b7a61516268" args="(const char *s)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#2f250cc359cc3a37d2659b7a61516268">assign</a> (const char *s)
<dl class="el"><dd class="mdescRight">Replace all the characters in the string with the characters is array s. <br></dl><li><a class="anchor" name="7ff574de53ffe4a5683bd006364655f9"></a><!-- doxytag: member="Xfc::String::assign" ref="7ff574de53ffe4a5683bd006364655f9" args="(size_t n, char c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#7ff574de53ffe4a5683bd006364655f9">assign</a> (size_t n, char c)
<dl class="el"><dd class="mdescRight">Replace all the characters in the string with the ascii character c, n times. <br></dl><li><a class="anchor" name="721c4c15d028478190565921395a9455"></a><!-- doxytag: member="Xfc::String::assign" ref="721c4c15d028478190565921395a9455" args="(size_t n, gunichar c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#721c4c15d028478190565921395a9455">assign</a> (size_t n, gunichar c)
<dl class="el"><dd class="mdescRight">Convert the unicode character c to UTF-8 and replace all the characters in the string with it n times. <br></dl><li><a class="anchor" name="0b909fbbee826160127cc2fe9cf7df11"></a><!-- doxytag: member="Xfc::String::assign" ref="0b909fbbee826160127cc2fe9cf7df11" args="(const gunichar *s, int n_chars, G::Error *error=0)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#0b909fbbee826160127cc2fe9cf7df11">assign</a> (const gunichar *s, int n_chars, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Convert n_chars number of unicode characters from array s to UTF-8 and assign them to the string; if n_chars is -1 then s is null-terminated. <br></dl><li><a class="anchor" name="294e8cadfe45750061f140b7f6397b1d"></a><!-- doxytag: member="Xfc::String::assign" ref="294e8cadfe45750061f140b7f6397b1d" args="(iterator first, iterator last)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#294e8cadfe45750061f140b7f6397b1d">assign</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> first, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> last)
<dl class="el"><dd class="mdescRight">Replace all the characters in the string with the UTF-8 characters in the range first to last. <br></dl><li><a class="anchor" name="1917a48656f30e30b5a5a4faa7c3c691"></a><!-- doxytag: member="Xfc::String::operator=" ref="1917a48656f30e30b5a5a4faa7c3c691" args="(const String &amp;str)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#1917a48656f30e30b5a5a4faa7c3c691">operator=</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Replace all the characters in the string with the characters in str. <br></dl><li><a class="anchor" name="7d1d5a85159226ffd4abdb3f6f8788d6"></a><!-- doxytag: member="Xfc::String::operator=" ref="7d1d5a85159226ffd4abdb3f6f8788d6" args="(const char *s)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#7d1d5a85159226ffd4abdb3f6f8788d6">operator=</a> (const char *s)
<dl class="el"><dd class="mdescRight">Replace all the characters in the string with the characters is array s. <br></dl><li><a class="anchor" name="d2f3f9cd87578ab6517fbebd96661e9e"></a><!-- doxytag: member="Xfc::String::operator=" ref="d2f3f9cd87578ab6517fbebd96661e9e" args="(char c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#d2f3f9cd87578ab6517fbebd96661e9e">operator=</a> (char c)
<dl class="el"><dd class="mdescRight">Replace all the characters in the string with the ascii character c. <br></dl><li><a class="anchor" name="5b34ab075b09ca134782cc22f0176ef3"></a><!-- doxytag: member="Xfc::String::operator=" ref="5b34ab075b09ca134782cc22f0176ef3" args="(gunichar c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#5b34ab075b09ca134782cc22f0176ef3">operator=</a> (gunichar c)
<dl class="el"><dd class="mdescRight">Convert the unicode character c to UTF-8 and assign it to the string. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Compare two strings</div></td></tr>
<tr><td colspan="2"><div class="groupText">The compare methods return 0 it the two strings are the same, a negative number if this string is lexicographically before the comparison string and a positive number otherwise. <br><br></div></td></tr>
<ul>
<li><a class="anchor" name="cb5ed9a01325c40a9e275999c3919191"></a><!-- doxytag: member="Xfc::String::compare" ref="cb5ed9a01325c40a9e275999c3919191" args="(const String &amp;str) const" -->
int <a class="el" href="classXfc_1_1String.html#cb5ed9a01325c40a9e275999c3919191">compare</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str) const
<dl class="el"><dd class="mdescRight">Compare the contents of the string with str. <br></dl><li><a class="anchor" name="ad393a1c5d7d44fae46b2d4ef9da4331"></a><!-- doxytag: member="Xfc::String::compare" ref="ad393a1c5d7d44fae46b2d4ef9da4331" args="(size_t char_pos, size_t n_chars, const String &amp;str) const " -->
int <a class="el" href="classXfc_1_1String.html#ad393a1c5d7d44fae46b2d4ef9da4331">compare</a> (size_t char_pos, size_t n_chars, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str) const 
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, compare n_chars number of characters in the string with str. <br></dl><li><a class="anchor" name="cd08e7e4658426f631d5735ef890700f"></a><!-- doxytag: member="Xfc::String::compare" ref="cd08e7e4658426f631d5735ef890700f" args="(size_t char_pos1, size_t n_chars1, const String &amp;str, size_t char_pos2, size_t n_chars2) const" -->
int <a class="el" href="classXfc_1_1String.html#cd08e7e4658426f631d5735ef890700f">compare</a> (size_t char_pos1, size_t n_chars1, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t char_pos2, size_t n_chars2) const
<dl class="el"><dd class="mdescRight">Starting at char_pos1 in the string and char_pos2 in str, compare n_chars1 number of characters in the string with n_chars2 number of characters in str. <br></dl><li><a class="anchor" name="2b9bef1396c67b9f993de25ed13ec072"></a><!-- doxytag: member="Xfc::String::compare" ref="2b9bef1396c67b9f993de25ed13ec072" args="(const char *s) const " -->
int <a class="el" href="classXfc_1_1String.html#2b9bef1396c67b9f993de25ed13ec072">compare</a> (const char *s) const 
<dl class="el"><dd class="mdescRight">Compare the contents of the string with the characters in the array s. <br></dl><li><a class="anchor" name="52a8afc4511c6f61a8707ff3db05b54d"></a><!-- doxytag: member="Xfc::String::compare" ref="52a8afc4511c6f61a8707ff3db05b54d" args="(size_t char_pos, size_t n_chars, const char *s) const" -->
int <a class="el" href="classXfc_1_1String.html#52a8afc4511c6f61a8707ff3db05b54d">compare</a> (size_t char_pos, size_t n_chars, const char *s) const
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, compare n_chars number of characters in the string with the characters in array s. <br></dl><li><a class="anchor" name="5a833aaaac51ebba0f27700ac7a6b9b6"></a><!-- doxytag: member="Xfc::String::compare" ref="5a833aaaac51ebba0f27700ac7a6b9b6" args="(size_t char_pos, size_t n_chars1, const char *s, size_t n_chars2) const " -->
int <a class="el" href="classXfc_1_1String.html#5a833aaaac51ebba0f27700ac7a6b9b6">compare</a> (size_t char_pos, size_t n_chars1, const char *s, size_t n_chars2) const 
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, compare n_chars1 number of characters in the string with n_chars2 number of characters in the array s. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Copy the contents of the string into a buffer.</div></td></tr>
<tr><td colspan="2"><div class="groupText">The copy methods return the number of bytes copied into the buffer. <br><br></div></td></tr>
<ul>
<li><a class="anchor" name="f6bcd92377cc5f545d1a95baff1826b2"></a><!-- doxytag: member="Xfc::String::copy" ref="f6bcd92377cc5f545d1a95baff1826b2" args="(char *s, size_t n_chars, size_t char_pos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#f6bcd92377cc5f545d1a95baff1826b2">copy</a> (char *s, size_t n_chars, size_t char_pos) const
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, copy n_chars characters into buffer s. <br></dl><li><a class="anchor" name="c16b16d493a299338be21b501db3c7da"></a><!-- doxytag: member="Xfc::String::copy" ref="c16b16d493a299338be21b501db3c7da" args="(char *s, size_t n_chars) const" -->
size_t <a class="el" href="classXfc_1_1String.html#c16b16d493a299338be21b501db3c7da">copy</a> (char *s, size_t n_chars) const
<dl class="el"><dd class="mdescRight">Starting at the beginning of the string, copy n_chars characters into buffer s. <br></dl><li><a class="anchor" name="050652172018d62e45870124a96d4829"></a><!-- doxytag: member="Xfc::String::copy" ref="050652172018d62e45870124a96d4829" args="(gunichar **s, size_t n_bytes, iterator i, G::Error *error=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#050652172018d62e45870124a96d4829">copy</a> (gunichar **s, size_t n_bytes, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> i, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0) const
<dl class="el"><dd class="mdescRight">Starting at the position in the string pointed by i, convert n_bytes to UCS-4 characters and copy them into a new buffer pointed to by s; this buffer must be freed with g_free(). <br></dl><li><a class="anchor" name="2c32376cc1774aa84df08e475d94ccea"></a><!-- doxytag: member="Xfc::String::copy" ref="2c32376cc1774aa84df08e475d94ccea" args="(gunichar2 **s, size_t n_bytes, iterator i, G::Error *error=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#2c32376cc1774aa84df08e475d94ccea">copy</a> (gunichar2 **s, size_t n_bytes, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> i, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0) const
<dl class="el"><dd class="mdescRight">Starting at the position in the string pointed by i, convert n_bytes to UTF-16 characters and copy them into a new buffer pointed to by s; this buffer must be freed with g_free(). <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Erase characters from the string</div></td></tr>
<tr><td colspan="2"><div class="groupText">The iterator returned by the erase methods points to the character one past the last character removed. <br><br></div></td></tr>
<ul>
<li><a class="anchor" name="197027b20ad990f08592df956623bf8a"></a><!-- doxytag: member="Xfc::String::erase" ref="197027b20ad990f08592df956623bf8a" args="()" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#197027b20ad990f08592df956623bf8a">erase</a> ()
<dl class="el"><dd class="mdescRight">Remove all the characters from the string. <br></dl><li><a class="anchor" name="58c05961493abb4af684cad51c1469db"></a><!-- doxytag: member="Xfc::String::erase" ref="58c05961493abb4af684cad51c1469db" args="(size_t char_pos, size_t n_chars=npos)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#58c05961493abb4af684cad51c1469db">erase</a> (size_t char_pos, size_t n_chars=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>)
<dl class="el"><dd class="mdescRight">Starting at char_pos, remove n_chars number of characters from the string. <br></dl><li><a class="anchor" name="2402e9a72da9dd3c1d227f97efd0956b"></a><!-- doxytag: member="Xfc::String::erase" ref="2402e9a72da9dd3c1d227f97efd0956b" args="(iterator i)" -->
<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> <a class="el" href="classXfc_1_1String.html#2402e9a72da9dd3c1d227f97efd0956b">erase</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> i)
<dl class="el"><dd class="mdescRight">Remove the character pointed to by i from the string. <br></dl><li><a class="anchor" name="2a0d86664a29e422f1dcbc98a4f4cc54"></a><!-- doxytag: member="Xfc::String::erase" ref="2a0d86664a29e422f1dcbc98a4f4cc54" args="(iterator first, iterator last)" -->
<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> <a class="el" href="classXfc_1_1String.html#2a0d86664a29e422f1dcbc98a4f4cc54">erase</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> first, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> last)
<dl class="el"><dd class="mdescRight">Remove the characters in the range first to last from the string. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Insert characters into the string</div></td></tr>
<ul>
<li><a class="anchor" name="b9eaec3718ed804c06b501b40b43aa27"></a><!-- doxytag: member="Xfc::String::insert" ref="b9eaec3718ed804c06b501b40b43aa27" args="(iterator i, size_t n, char c)" -->
void <a class="el" href="classXfc_1_1String.html#b9eaec3718ed804c06b501b40b43aa27">insert</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> i, size_t n, char c)
<dl class="el"><dd class="mdescRight">Starting at the position in the string pointed to by i, insert the ascii character c n times. <br></dl><li><a class="anchor" name="74e6735e235c063fe3f7b19f516d4e72"></a><!-- doxytag: member="Xfc::String::insert" ref="74e6735e235c063fe3f7b19f516d4e72" args="(iterator i, size_t n, gunichar c)" -->
void <a class="el" href="classXfc_1_1String.html#74e6735e235c063fe3f7b19f516d4e72">insert</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> i, size_t n, gunichar c)
<dl class="el"><dd class="mdescRight">Starting at the position in the string pointed to by i, convert the unicode character c to UTF-8 and insert it n times. <br></dl><li><a class="anchor" name="2257f2677627995964780a7842e8d515"></a><!-- doxytag: member="Xfc::String::insert" ref="2257f2677627995964780a7842e8d515" args="(iterator i, iterator first, iterator last)" -->
void <a class="el" href="classXfc_1_1String.html#2257f2677627995964780a7842e8d515">insert</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> i, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> first, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> last)
<dl class="el"><dd class="mdescRight">Insert the characters in the range first to last at the position in the string pointed to by i. <br></dl><li><a class="anchor" name="637a9bbcb9ff97bf8c8102b7526454cd"></a><!-- doxytag: member="Xfc::String::insert" ref="637a9bbcb9ff97bf8c8102b7526454cd" args="(size_t char_pos, const String &amp;str)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#637a9bbcb9ff97bf8c8102b7526454cd">insert</a> (size_t char_pos, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Insert str into the string at char_pos. <br></dl><li><a class="anchor" name="23b8301387694255487db398ae0b608b"></a><!-- doxytag: member="Xfc::String::insert" ref="23b8301387694255487db398ae0b608b" args="(size_t char_pos1, const String &amp;str, size_t char_pos2, size_t n_chars=npos)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#23b8301387694255487db398ae0b608b">insert</a> (size_t char_pos1, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t char_pos2, size_t n_chars=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>)
<dl class="el"><dd class="mdescRight">Starting at char_pos2 in str, insert n_chars number of characters from str into the string at char_pos1. <br></dl><li><a class="anchor" name="0b2f468435cbffe7a6c918aea319eca1"></a><!-- doxytag: member="Xfc::String::insert" ref="0b2f468435cbffe7a6c918aea319eca1" args="(size_t char_pos, const char *s, size_t n_chars)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#0b2f468435cbffe7a6c918aea319eca1">insert</a> (size_t char_pos, const char *s, size_t n_chars)
<dl class="el"><dd class="mdescRight">Insert n_chars number of characters in array s into the string at char_pos. <br></dl><li><a class="anchor" name="b335daa7927b98908bdbf707a81e29e8"></a><!-- doxytag: member="Xfc::String::insert" ref="b335daa7927b98908bdbf707a81e29e8" args="(size_t char_pos, const char *s)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#b335daa7927b98908bdbf707a81e29e8">insert</a> (size_t char_pos, const char *s)
<dl class="el"><dd class="mdescRight">Insert the characters in array s into the string at char_pos. <br></dl><li><a class="anchor" name="12f2814b86a4d153022f7da27079092c"></a><!-- doxytag: member="Xfc::String::insert" ref="12f2814b86a4d153022f7da27079092c" args="(size_t char_pos, size_t n, char c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#12f2814b86a4d153022f7da27079092c">insert</a> (size_t char_pos, size_t n, char c)
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, insert the ascii character c n times. <br></dl><li><a class="anchor" name="66f68b7065bbd385dde0263f59e29a91"></a><!-- doxytag: member="Xfc::String::insert" ref="66f68b7065bbd385dde0263f59e29a91" args="(size_t char_pos, size_t n, gunichar c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#66f68b7065bbd385dde0263f59e29a91">insert</a> (size_t char_pos, size_t n, gunichar c)
<dl class="el"><dd class="mdescRight">Starting char_pos in the string, convert the unicode character c to UTF-8 and insert it n times. <br></dl><li><a class="anchor" name="86744f8cc2292e57c9b5e5bb5f34481f"></a><!-- doxytag: member="Xfc::String::insert" ref="86744f8cc2292e57c9b5e5bb5f34481f" args="(size_t char_pos, const gunichar *s, int n_chars, G::Error *error=0)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#86744f8cc2292e57c9b5e5bb5f34481f">insert</a> (size_t char_pos, const gunichar *s, int n_chars, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Convert n_chars number of unicode characters from array s to UTF-8 and insert them into the string at char_pos; if n_chars is -1 then s is null-terminated. <br></dl><li><a class="anchor" name="c141c68938e08d0f7b67c99ae63183aa"></a><!-- doxytag: member="Xfc::String::insert" ref="c141c68938e08d0f7b67c99ae63183aa" args="(size_t char_pos, gunichar c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#c141c68938e08d0f7b67c99ae63183aa">insert</a> (size_t char_pos, gunichar c)
<dl class="el"><dd class="mdescRight">Convert the unicode character c to UTF-8 and insert it into the string at char_pos. <br></dl><li><a class="anchor" name="bdda0533c1e25483d50966d167fc1785"></a><!-- doxytag: member="Xfc::String::insert" ref="bdda0533c1e25483d50966d167fc1785" args="(iterator i, char c)" -->
<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> <a class="el" href="classXfc_1_1String.html#bdda0533c1e25483d50966d167fc1785">insert</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> i, char c)
<dl class="el"><dd class="mdescRight">Insert the ascii character c into the string at the position pointed to by i. <br></dl><li><a class="anchor" name="8ce55e20df7c60172b13216526700b49"></a><!-- doxytag: member="Xfc::String::insert" ref="8ce55e20df7c60172b13216526700b49" args="(iterator i, gunichar c)" -->
<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> <a class="el" href="classXfc_1_1String.html#8ce55e20df7c60172b13216526700b49">insert</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> i, gunichar c)
<dl class="el"><dd class="mdescRight">Convert the unicode character c to UTF-8 and insert it into the string at the position pointed to by i. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Replace characters in the string</div></td></tr>
<ul>
<li><a class="anchor" name="5ed369037f34dea1a209806bec582014"></a><!-- doxytag: member="Xfc::String::replace" ref="5ed369037f34dea1a209806bec582014" args="(size_t char_pos, size_t n_chars, const String &amp;str)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#5ed369037f34dea1a209806bec582014">replace</a> (size_t char_pos, size_t n_chars, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, replace n_chars number of characters with str. <br></dl><li><a class="anchor" name="c185bc9d84a448aab6ff3c4ed45dc07e"></a><!-- doxytag: member="Xfc::String::replace" ref="c185bc9d84a448aab6ff3c4ed45dc07e" args="(size_t char_pos1, size_t n_chars1, const String &amp;str, size_t char_pos2, size_t n_chars2=npos)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#c185bc9d84a448aab6ff3c4ed45dc07e">replace</a> (size_t char_pos1, size_t n_chars1, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t char_pos2, size_t n_chars2=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>)
<dl class="el"><dd class="mdescRight">Starting at char_pos1 in the string and char_pos2 in str, replace n_chars1 number of characters in the string with n_chars2 number of characters from str. <br></dl><li><a class="anchor" name="e933686361d1ef17093982c70369eb35"></a><!-- doxytag: member="Xfc::String::replace" ref="e933686361d1ef17093982c70369eb35" args="(size_t char_pos, size_t n_chars1, const char *s, size_t n_chars2)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#e933686361d1ef17093982c70369eb35">replace</a> (size_t char_pos, size_t n_chars1, const char *s, size_t n_chars2)
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, replace n_chars1 number of characters in the string with n_chars2 number of characters in array s. <br></dl><li><a class="anchor" name="7fec549d03bbe5cd3ef5b19c237fb2b8"></a><!-- doxytag: member="Xfc::String::replace" ref="7fec549d03bbe5cd3ef5b19c237fb2b8" args="(size_t char_pos, size_t n_chars, const char *s)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#7fec549d03bbe5cd3ef5b19c237fb2b8">replace</a> (size_t char_pos, size_t n_chars, const char *s)
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, replace n_chars number of characters with the characters in array s. <br></dl><li><a class="anchor" name="984e3870e3e46706d61c1a4e44b9ea43"></a><!-- doxytag: member="Xfc::String::replace" ref="984e3870e3e46706d61c1a4e44b9ea43" args="(size_t char_pos, size_t n_chars, size_t n, char c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#984e3870e3e46706d61c1a4e44b9ea43">replace</a> (size_t char_pos, size_t n_chars, size_t n, char c)
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, replace n_chars number of characters with n copies of the ascii character c. <br></dl><li><a class="anchor" name="46d5d51c2280b42194222c066ebbbc3a"></a><!-- doxytag: member="Xfc::String::replace" ref="46d5d51c2280b42194222c066ebbbc3a" args="(size_t char_pos, size_t n_chars, size_t n, gunichar c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#46d5d51c2280b42194222c066ebbbc3a">replace</a> (size_t char_pos, size_t n_chars, size_t n, gunichar c)
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, replace n_chars number of characters with n copies of the unicode character c coverted to UTF-8. <br></dl><li><a class="anchor" name="d7f9196f53bf046126f2fbcdf0eea9e8"></a><!-- doxytag: member="Xfc::String::replace" ref="d7f9196f53bf046126f2fbcdf0eea9e8" args="(size_t char_pos, size_t n_chars, gunichar c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#d7f9196f53bf046126f2fbcdf0eea9e8">replace</a> (size_t char_pos, size_t n_chars, gunichar c)
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, replace n_chars number of characters with the unicode character c coverted to UTF-8. <br></dl><li><a class="anchor" name="4ad5e845089d5443ee3ced6cfa0b8adf"></a><!-- doxytag: member="Xfc::String::replace" ref="4ad5e845089d5443ee3ced6cfa0b8adf" args="(size_t char_pos, size_t n_chars1, const gunichar *s, int n_chars2, G::Error *error=0)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#4ad5e845089d5443ee3ced6cfa0b8adf">replace</a> (size_t char_pos, size_t n_chars1, const gunichar *s, int n_chars2, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Starting at char_pos in the string, replace n_chars1 number of characters with n_chars2 number of characters in unicode array s converted to UTF-8; if n_chars2 is -1 then s is null-terminated. <br></dl><li><a class="anchor" name="1fd242782639727d9ea8b4c0ff54a29c"></a><!-- doxytag: member="Xfc::String::replace" ref="1fd242782639727d9ea8b4c0ff54a29c" args="(iterator first, iterator last, const String &amp;str)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#1fd242782639727d9ea8b4c0ff54a29c">replace</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> first, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> last, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Replace the characters in the string in the range first to last with str. <br></dl><li><a class="anchor" name="8ac48a3c4135a5ceb1d0101eaa34c2b6"></a><!-- doxytag: member="Xfc::String::replace" ref="8ac48a3c4135a5ceb1d0101eaa34c2b6" args="(iterator first, iterator last, const char *s, size_t n_chars)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#8ac48a3c4135a5ceb1d0101eaa34c2b6">replace</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> first, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> last, const char *s, size_t n_chars)
<dl class="el"><dd class="mdescRight">Replace the characters in the string in the range first to last with n_chars characters in array s. <br></dl><li><a class="anchor" name="4475ff2c9fc7288a87bdc355648a6f95"></a><!-- doxytag: member="Xfc::String::replace" ref="4475ff2c9fc7288a87bdc355648a6f95" args="(iterator first, iterator last, const char *s)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#4475ff2c9fc7288a87bdc355648a6f95">replace</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> first, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> last, const char *s)
<dl class="el"><dd class="mdescRight">Replace the characters in the string in the range first to last with the characters in array s. <br></dl><li><a class="anchor" name="246ade45dbe4bc69df475e2a54febe9d"></a><!-- doxytag: member="Xfc::String::replace" ref="246ade45dbe4bc69df475e2a54febe9d" args="(iterator first, iterator last, size_t n, char c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#246ade45dbe4bc69df475e2a54febe9d">replace</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> first, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> last, size_t n, char c)
<dl class="el"><dd class="mdescRight">Replace the characters in the string in the range first to last with n copies of the ascii characters c. <br></dl><li><a class="anchor" name="34944f89bea92106269b540b0809d3d2"></a><!-- doxytag: member="Xfc::String::replace" ref="34944f89bea92106269b540b0809d3d2" args="(iterator first, iterator last, gunichar c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#34944f89bea92106269b540b0809d3d2">replace</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> first, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> last, gunichar c)
<dl class="el"><dd class="mdescRight">Replace the characters in the string in the range first to last with the unicode character c converted to UTF-8. <br></dl><li><a class="anchor" name="3f744d8cf9f00162f4448cc25899f5cc"></a><!-- doxytag: member="Xfc::String::replace" ref="3f744d8cf9f00162f4448cc25899f5cc" args="(iterator first1, iterator last1, iterator first2, iterator last2)" -->
<a class="el" href="classXfc_1_1String.html">String</a> &amp; <a class="el" href="classXfc_1_1String.html#3f744d8cf9f00162f4448cc25899f5cc">replace</a> (<a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> first1, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> last1, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> first2, <a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a> last2)
<dl class="el"><dd class="mdescRight">Replace the characters in the string in the range first1 to last1 with the characters in another string in the range first2 to last2. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Resize the string</div></td></tr>
<ul>
<li><a class="anchor" name="b0de8895adb646fa62323dbd157802a1"></a><!-- doxytag: member="Xfc::String::resize" ref="b0de8895adb646fa62323dbd157802a1" args="(size_t n_bytes)" -->
void <a class="el" href="classXfc_1_1String.html#b0de8895adb646fa62323dbd157802a1">resize</a> (size_t n_bytes)
<dl class="el"><dd class="mdescRight">Resize the string to hold n_bytes extra. <br></dl><li><a class="anchor" name="5cb22f96862714e6a6792c96e7489d42"></a><!-- doxytag: member="Xfc::String::reserve" ref="5cb22f96862714e6a6792c96e7489d42" args="(size_t n_bytes=0)" -->
void <a class="el" href="classXfc_1_1String.html#5cb22f96862714e6a6792c96e7489d42">reserve</a> (size_t n_bytes=0)
<dl class="el"><dd class="mdescRight">Reserve n_bytes to be allocated at the next reallocation;. <br></dl><li><a class="anchor" name="1cf8257aeec669b499f13095f789fe84"></a><!-- doxytag: member="Xfc::String::clear" ref="1cf8257aeec669b499f13095f789fe84" args="()" -->
void <a class="el" href="classXfc_1_1String.html#1cf8257aeec669b499f13095f789fe84">clear</a> ()
<dl class="el"><dd class="mdescRight">Erase all the characters in the string. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Search the string for a subsequence</div></td></tr>
<tr><td colspan="2"><div class="groupText">The find methods search the string for a subsequence and if successful return the byte index of the first occurrence found, otherwise npos is returned. <br><br></div></td></tr>
<ul>
<li><a class="anchor" name="00311c0d3e421fe9e59526decda0be82"></a><!-- doxytag: member="Xfc::String::find" ref="00311c0d3e421fe9e59526decda0be82" args="(const char *s, size_t byte_pos, size_t n_chars) const" -->
size_t <a class="el" href="classXfc_1_1String.html#00311c0d3e421fe9e59526decda0be82">find</a> (const char *s, size_t byte_pos, size_t n_chars) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search n_chars number of characters for the first occurrence of s. <br></dl><li><a class="anchor" name="8fc9bc864779b06276c3d2d85eb3a0cf"></a><!-- doxytag: member="Xfc::String::find" ref="8fc9bc864779b06276c3d2d85eb3a0cf" args="(const String &amp;str, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#8fc9bc864779b06276c3d2d85eb3a0cf">find</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first occurrence of str. <br></dl><li><a class="anchor" name="25b2372d292d4c5960c89c6f060a0c01"></a><!-- doxytag: member="Xfc::String::find" ref="25b2372d292d4c5960c89c6f060a0c01" args="(const char *s, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#25b2372d292d4c5960c89c6f060a0c01">find</a> (const char *s, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first occurrence of s. <br></dl><li><a class="anchor" name="3a99430e3a70e2337b26141f4f88f9ed"></a><!-- doxytag: member="Xfc::String::find" ref="3a99430e3a70e2337b26141f4f88f9ed" args="(char c, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#3a99430e3a70e2337b26141f4f88f9ed">find</a> (char c, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first occurrence of the ascii character c. <br></dl><li><a class="anchor" name="67fc8c1e9c03189c91540aa42acefedd"></a><!-- doxytag: member="Xfc::String::find" ref="67fc8c1e9c03189c91540aa42acefedd" args="(gunichar c, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#67fc8c1e9c03189c91540aa42acefedd">find</a> (gunichar c, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first occurrence of the unicode character c. <br></dl><li><a class="anchor" name="ddbaedcf879c4bf4eab2de00803cf3b4"></a><!-- doxytag: member="Xfc::String::rfind" ref="ddbaedcf879c4bf4eab2de00803cf3b4" args="(const String &amp;str, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#ddbaedcf879c4bf4eab2de00803cf3b4">rfind</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards for the first occurrence str. <br></dl><li><a class="anchor" name="51ca82c485156cd2a2a06565a8f3a6b6"></a><!-- doxytag: member="Xfc::String::rfind" ref="51ca82c485156cd2a2a06565a8f3a6b6" args="(const char *s, size_t byte_pos, size_t n_chars) const" -->
size_t <a class="el" href="classXfc_1_1String.html#51ca82c485156cd2a2a06565a8f3a6b6">rfind</a> (const char *s, size_t byte_pos, size_t n_chars) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards n_chars number of characters for the first occurrence of s. <br></dl><li><a class="anchor" name="f48786495474622d0972c57907a2fefc"></a><!-- doxytag: member="Xfc::String::rfind" ref="f48786495474622d0972c57907a2fefc" args="(const char *s, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#f48786495474622d0972c57907a2fefc">rfind</a> (const char *s, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search bacwards for the first occurrence of s. <br></dl><li><a class="anchor" name="719969241087657c4e15f1a0405d41b5"></a><!-- doxytag: member="Xfc::String::rfind" ref="719969241087657c4e15f1a0405d41b5" args="(char c, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#719969241087657c4e15f1a0405d41b5">rfind</a> (char c, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards for the first occurrence of the ascii character c. <br></dl><li><a class="anchor" name="16c0c2dc473498b41e6d8ff7b5257cbe"></a><!-- doxytag: member="Xfc::String::rfind" ref="16c0c2dc473498b41e6d8ff7b5257cbe" args="(gunichar c, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#16c0c2dc473498b41e6d8ff7b5257cbe">rfind</a> (gunichar c, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards for the first occurrence of the unicode character c. <br></dl><li><a class="anchor" name="fdd9eec0d8d086b2a8d23dd48cc1251e"></a><!-- doxytag: member="Xfc::String::find_first_of" ref="fdd9eec0d8d086b2a8d23dd48cc1251e" args="(const String &amp;str, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#fdd9eec0d8d086b2a8d23dd48cc1251e">find_first_of</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first occurrence of any character in str. <br></dl><li><a class="anchor" name="fcd02e6cdc2724ce957c141bf6984e3f"></a><!-- doxytag: member="Xfc::String::find_first_of" ref="fcd02e6cdc2724ce957c141bf6984e3f" args="(const char *s, size_t byte_pos, size_t n_chars) const" -->
size_t <a class="el" href="classXfc_1_1String.html#fcd02e6cdc2724ce957c141bf6984e3f">find_first_of</a> (const char *s, size_t byte_pos, size_t n_chars) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search n_chars number of characters for the first occurrence of any character in s. <br></dl><li><a class="anchor" name="07798754e2021d74767c03f8abb54635"></a><!-- doxytag: member="Xfc::String::find_first_of" ref="07798754e2021d74767c03f8abb54635" args="(const char *s, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#07798754e2021d74767c03f8abb54635">find_first_of</a> (const char *s, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first occurrence of any character in s. <br></dl><li><a class="anchor" name="e2360db7dd152bb7a4d6a02435c1edca"></a><!-- doxytag: member="Xfc::String::find_first_of" ref="e2360db7dd152bb7a4d6a02435c1edca" args="(char c, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#e2360db7dd152bb7a4d6a02435c1edca">find_first_of</a> (char c, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first character matching the ascii character c. <br></dl><li><a class="anchor" name="47f627ed7a3ea964a7f52d1323bc7418"></a><!-- doxytag: member="Xfc::String::find_first_of" ref="47f627ed7a3ea964a7f52d1323bc7418" args="(gunichar c, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#47f627ed7a3ea964a7f52d1323bc7418">find_first_of</a> (gunichar c, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first character matching the unicode character c. <br></dl><li><a class="anchor" name="9fd5062911a5adf24b9d27ce3f189cab"></a><!-- doxytag: member="Xfc::String::find_last_of" ref="9fd5062911a5adf24b9d27ce3f189cab" args="(const String &amp;str, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#9fd5062911a5adf24b9d27ce3f189cab">find_last_of</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards for the first occurrence of any character in str. <br></dl><li><a class="anchor" name="08dadd35b22155d1707470fc44b312c4"></a><!-- doxytag: member="Xfc::String::find_last_of" ref="08dadd35b22155d1707470fc44b312c4" args="(const char *s, size_t byte_pos, size_t n_chars) const" -->
size_t <a class="el" href="classXfc_1_1String.html#08dadd35b22155d1707470fc44b312c4">find_last_of</a> (const char *s, size_t byte_pos, size_t n_chars) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards n_chars number of characters for the first occurrence of any character in s. <br></dl><li><a class="anchor" name="45ca40423747b1b83dcdce7ef693d3ea"></a><!-- doxytag: member="Xfc::String::find_last_of" ref="45ca40423747b1b83dcdce7ef693d3ea" args="(const char *s, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#45ca40423747b1b83dcdce7ef693d3ea">find_last_of</a> (const char *s, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards for the first occurrence of any character in s. <br></dl><li><a class="anchor" name="cc28f05636bb4ba154138198a7920d9a"></a><!-- doxytag: member="Xfc::String::find_last_of" ref="cc28f05636bb4ba154138198a7920d9a" args="(char c, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#cc28f05636bb4ba154138198a7920d9a">find_last_of</a> (char c, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards for the first character matching the ascii character c. <br></dl><li><a class="anchor" name="0bdc9754b4f434b5a72fb3cac17fce84"></a><!-- doxytag: member="Xfc::String::find_last_of" ref="0bdc9754b4f434b5a72fb3cac17fce84" args="(gunichar c, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#0bdc9754b4f434b5a72fb3cac17fce84">find_last_of</a> (gunichar c, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards for the first character matching the unicode character c. <br></dl><li><a class="anchor" name="7fd0be3484a264d36bcfc8b41b0bdd02"></a><!-- doxytag: member="Xfc::String::find_first_not_of" ref="7fd0be3484a264d36bcfc8b41b0bdd02" args="(const String &amp;str, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#7fd0be3484a264d36bcfc8b41b0bdd02">find_first_not_of</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first occurrence of any character not in str. <br></dl><li><a class="anchor" name="4a12afb0dcdf0de63cf1d4ec0ba0945e"></a><!-- doxytag: member="Xfc::String::find_first_not_of" ref="4a12afb0dcdf0de63cf1d4ec0ba0945e" args="(const char *s, size_t byte_pos, size_t n_chars) const" -->
size_t <a class="el" href="classXfc_1_1String.html#4a12afb0dcdf0de63cf1d4ec0ba0945e">find_first_not_of</a> (const char *s, size_t byte_pos, size_t n_chars) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search n_chars number of characters for the first occurrence of any character not in s. <br></dl><li><a class="anchor" name="ed99d4998e3429b57c6fe3729a2cc945"></a><!-- doxytag: member="Xfc::String::find_first_not_of" ref="ed99d4998e3429b57c6fe3729a2cc945" args="(const char *s, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#ed99d4998e3429b57c6fe3729a2cc945">find_first_not_of</a> (const char *s, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first occurrence of any character not in s. <br></dl><li><a class="anchor" name="a28636c8becb1932dbf7ef8a2e652208"></a><!-- doxytag: member="Xfc::String::find_first_not_of" ref="a28636c8becb1932dbf7ef8a2e652208" args="(char c, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#a28636c8becb1932dbf7ef8a2e652208">find_first_not_of</a> (char c, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first character not matching the ascii character c. <br></dl><li><a class="anchor" name="75cd6100fe74ede55f0d0f34212dc961"></a><!-- doxytag: member="Xfc::String::find_first_not_of" ref="75cd6100fe74ede55f0d0f34212dc961" args="(gunichar c, size_t byte_pos=0) const" -->
size_t <a class="el" href="classXfc_1_1String.html#75cd6100fe74ede55f0d0f34212dc961">find_first_not_of</a> (gunichar c, size_t byte_pos=0) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search for the first character not matching the unicode character c. <br></dl><li><a class="anchor" name="ab1dd91a9ccd0aef1a64ce4227a03751"></a><!-- doxytag: member="Xfc::String::find_last_not_of" ref="ab1dd91a9ccd0aef1a64ce4227a03751" args="(const String &amp;str, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#ab1dd91a9ccd0aef1a64ce4227a03751">find_last_not_of</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards for the first occurrence of any character not in str. <br></dl><li><a class="anchor" name="3db5b3eae09e945729689e31620ec9e7"></a><!-- doxytag: member="Xfc::String::find_last_not_of" ref="3db5b3eae09e945729689e31620ec9e7" args="(const char *s, size_t byte_pos, size_t n_chars) const" -->
size_t <a class="el" href="classXfc_1_1String.html#3db5b3eae09e945729689e31620ec9e7">find_last_not_of</a> (const char *s, size_t byte_pos, size_t n_chars) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards n_chars number of characters for the first occurrence of any character not in s. <br></dl><li><a class="anchor" name="bc244b3175eefab701d99238652fe982"></a><!-- doxytag: member="Xfc::String::find_last_not_of" ref="bc244b3175eefab701d99238652fe982" args="(const char *s, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#bc244b3175eefab701d99238652fe982">find_last_not_of</a> (const char *s, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards for the first occurrence of any character not in s. <br></dl><li><a class="anchor" name="a977e24596d99935c69f6e36695d7795"></a><!-- doxytag: member="Xfc::String::find_last_not_of" ref="a977e24596d99935c69f6e36695d7795" args="(char c, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#a977e24596d99935c69f6e36695d7795">find_last_not_of</a> (char c, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards for the first character not matching the ascii character c. <br></dl><li><a class="anchor" name="c1eb7d5228861c4098a73b79d68d2d53"></a><!-- doxytag: member="Xfc::String::find_last_not_of" ref="c1eb7d5228861c4098a73b79d68d2d53" args="(gunichar c, size_t byte_pos=npos) const" -->
size_t <a class="el" href="classXfc_1_1String.html#c1eb7d5228861c4098a73b79d68d2d53">find_last_not_of</a> (gunichar c, size_t byte_pos=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at byte_pos in the string, search backwards for the first character not matching the unicode character c. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Select a substring</div></td></tr>
<ul>
<li><a class="anchor" name="ade6e24f0a5d1815caa9f37e7b819904"></a><!-- doxytag: member="Xfc::String::substr" ref="ade6e24f0a5d1815caa9f37e7b819904" args="(size_t char_pos=0, size_t n_chars=npos) const" -->
<a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#ade6e24f0a5d1815caa9f37e7b819904">substr</a> (size_t char_pos=0, size_t n_chars=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>) const
<dl class="el"><dd class="mdescRight">Starting at char_pos, return n_chars number of characters as a new string. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Swap strings</div></td></tr>
<ul>
<li><a class="anchor" name="535a01fdba849175dcdca38d857c4aac"></a><!-- doxytag: member="Xfc::String::swap" ref="535a01fdba849175dcdca38d857c4aac" args="(String &amp;str)" -->
void <a class="el" href="classXfc_1_1String.html#535a01fdba849175dcdca38d857c4aac">swap</a> (<a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Swap the contents of the string with the contents of str. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Case conversion</div></td></tr>
<ul>
<li><a class="anchor" name="0d1cabd363280e64fdf4a31912fe9c3a"></a><!-- doxytag: member="Xfc::String::upper" ref="0d1cabd363280e64fdf4a31912fe9c3a" args="()" -->
<a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#0d1cabd363280e64fdf4a31912fe9c3a">upper</a> ()
<dl class="el"><dd class="mdescRight">Convert all the characters in the string to upper case. <br></dl><li><a class="anchor" name="a0669a6bbe502dbf7728d3c4d3a460e6"></a><!-- doxytag: member="Xfc::String::upper" ref="a0669a6bbe502dbf7728d3c4d3a460e6" args="(size_t char_pos, size_t n_bytes=npos)" -->
<a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#a0669a6bbe502dbf7728d3c4d3a460e6">upper</a> (size_t char_pos, size_t n_bytes=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>)
<dl class="el"><dd class="mdescRight">Starting at char_pos, convert n_bytes in the string to upper case. <br></dl><li><a class="anchor" name="4612ded8aaaf7d0697fed22bfbbedf88"></a><!-- doxytag: member="Xfc::String::lower" ref="4612ded8aaaf7d0697fed22bfbbedf88" args="()" -->
<a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#4612ded8aaaf7d0697fed22bfbbedf88">lower</a> ()
<dl class="el"><dd class="mdescRight">Convert all the characters in the string to lower case. <br></dl><li><a class="anchor" name="945b510896493b01c5a8e88f4d5c01c7"></a><!-- doxytag: member="Xfc::String::lower" ref="945b510896493b01c5a8e88f4d5c01c7" args="(size_t char_pos, size_t n_bytes=npos)" -->
<a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#945b510896493b01c5a8e88f4d5c01c7">lower</a> (size_t char_pos, size_t n_bytes=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>)
<dl class="el"><dd class="mdescRight">Starting at char_pos, convert n_bytes in the string to lower case. <br></dl><li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#affc092137503f2531be8f72cb6757d3">casefold</a> (size_t n_bytes=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>)
<dl class="el"><dd class="mdescRight">Converts a string into a form that is independent of case.  <a href="#affc092137503f2531be8f72cb6757d3"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">UTF-8 methods</div></td></tr>
<ul>
<li><a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#164d280bb6bb412843c14763a5ab14c1">normalize</a> (GNormalizeMode mode, size_t n_bytes=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>)
<dl class="el"><dd class="mdescRight">Converts a string into canonical form.  <a href="#164d280bb6bb412843c14763a5ab14c1"></a><br></dl><li>int <a class="el" href="classXfc_1_1String.html#9e25c18e2a5855507e53a984d7194cf7">collate</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Compare the string and str for ordering using the linguistically correct rules for the current locale.  <a href="#9e25c18e2a5855507e53a984d7194cf7"></a><br></dl><li>int <a class="el" href="classXfc_1_1String.html#73baaa651b004932c9412f4b9fd23469">collate_key</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, size_t n_bytes=<a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a>)
<dl class="el"><dd class="mdescRight">Converts the string and str into collation keys and compares them using strcmp().  <a href="#73baaa651b004932c9412f4b9fd23469"></a><br></dl><li>std::string <a class="el" href="classXfc_1_1String.html#2099e0fd7432aa7c28baf8e41f0f0659">convert</a> (const char *to_codeset, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Converts the string from UTF-8 to another character set.  <a href="#2099e0fd7432aa7c28baf8e41f0f0659"></a><br></dl><li>std::string <a class="el" href="classXfc_1_1String.html#55ec19242d943cadec5e7b4facfbc7ee">convert_with_fallback</a> (const char *to_codeset, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Converts the string from UTF-8 to another character set, possibly including fallback sequences for characters not representable in the output.  <a href="#55ec19242d943cadec5e7b4facfbc7ee"></a><br></dl><li>std::string <a class="el" href="classXfc_1_1String.html#ed4400fdcb285a53682e3863f8ad4ccd">convert_with_fallback</a> (const char *to_codeset, const char *fallback, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Converts the string from UTF-8 to another character set, possibly including fallback sequences for characters not representable in the output.  <a href="#ed4400fdcb285a53682e3863f8ad4ccd"></a><br></dl><li>std::string <a class="el" href="classXfc_1_1String.html#1223c24876567ad92ea83c3395a4373e">to_locale</a> (<a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0) const
<dl class="el"><dd class="mdescRight">Converts the string from UTF-8 to the encoding used by the C runtime for the current locale.  <a href="#1223c24876567ad92ea83c3395a4373e"></a><br></dl><li>std::string <a class="el" href="classXfc_1_1String.html#dbb85a544662aa75b6f2fed6c670086c">to_filename</a> (<a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0) const
<dl class="el"><dd class="mdescRight">Converts a string from UTF-8 to the encoding used for filenames.  <a href="#dbb85a544662aa75b6f2fed6c670086c"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Validate the characters in the string.</div></td></tr>
<ul>
<li>bool <a class="el" href="classXfc_1_1String.html#d2c27b6290af059734de51ecbd29e4b1">validate</a> (size_t &amp;byte_pos) const
<dl class="el"><dd class="mdescRight">Validates UTF-8 encoded text.  <a href="#d2c27b6290af059734de51ecbd29e4b1"></a><br></dl><li>bool <a class="el" href="classXfc_1_1String.html#18467d84356eaf48b6656a0492267456">validate</a> (<a class="el" href="classXfc_1_1String.html#87576004293473e0f8728a14727a03e5">const_pointer</a> *end=0) const
<dl class="el"><dd class="mdescRight">Validates UTF-8 encoded text.  <a href="#18467d84356eaf48b6656a0492267456"></a><br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> <a class="el" href="classXfc_1_1String.html#662c0ec8a8a6137d56beb1c282ea42c1">get_char</a> (<a class="el" href="classXfc_1_1String.html#87576004293473e0f8728a14727a03e5">const_pointer</a> p)
<dl class="el"><dd class="mdescRight">Converts the UTF-8 byte sequence at <em>p</em> to a unicode character.  <a href="#662c0ec8a8a6137d56beb1c282ea42c1"></a><br></dl><li>static <a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> <a class="el" href="classXfc_1_1String.html#c42a5bb913ffe678f3c4bdebcaf63dec">get_char_validated</a> (<a class="el" href="classXfc_1_1String.html#87576004293473e0f8728a14727a03e5">const_pointer</a> p, size_t n_bytes)
<dl class="el"><dd class="mdescRight">Converts the UTF-8 byte sequence at <em>p</em> to a unicode character.  <a href="#c42a5bb913ffe678f3c4bdebcaf63dec"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Format a new value for the string</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#91c0b737e6d80c5f467425cd707a6b8b">format</a> (const char *message_format,...)
<dl class="el"><dd class="mdescRight">Convenience method that does sprintf-style string formatting.  <a href="#91c0b737e6d80c5f467425cd707a6b8b"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">UTF-8 filename conversion methods</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#2e851a4e19942d2c765e3823f4a58703">from_locale</a> (const std::string &amp;opsysstring, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Convert the opsysstring from the current locale's encoding used by the C runtime into a UTF-8 string.  <a href="#2e851a4e19942d2c765e3823f4a58703"></a><br></dl><li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#1b9579a5346a9a51d4c099551801f795">from_filename</a> (const std::string &amp;opsysstring, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Converts a string from the encoding used for filenames into a UTF-8 string.  <a href="#1b9579a5346a9a51d4c099551801f795"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">UTF-8 character set conversion methods</div></td></tr>
<ul>
<li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#5e74063a2a9761ce5669918ef13f537e">convert</a> (const std::string &amp;str, const char *from_codeset, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Converts a string from one character set to UTF-8.  <a href="#5e74063a2a9761ce5669918ef13f537e"></a><br></dl><li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#d9846979dda8e4d648100899f013325e">convert_with_fallback</a> (const std::string &amp;str, const char *from_codeset, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Converts a string from one character set to UTF-8, possibly including fallback sequences for characters not representable in the output.  <a href="#d9846979dda8e4d648100899f013325e"></a><br></dl><li>static <a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="classXfc_1_1String.html#6b1c8f1efdda691108dca969a0f89289">convert_with_fallback</a> (const std::string &amp;str, const char *from_codeset, const char *fallback, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error=0)
<dl class="el"><dd class="mdescRight">Converts a string from one character set to UTF-8, possibly including fallback sequences for characters not representable in the output.  <a href="#6b1c8f1efdda691108dca969a0f89289"></a><br></dl></ul>
<h2>Static Public Attributes</h2>
<ul>
<li><a class="anchor" name="9f5a01ee75a540c8ab7faeb44c5019d1"></a><!-- doxytag: member="Xfc::String::npos" ref="9f5a01ee75a540c8ab7faeb44c5019d1" args="" -->
static const size_t <a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a> = static_cast&lt;size_t&gt;(-1)
<dl class="el"><dd class="mdescRight">npos is an unsigned type that is used to mean 'all of the elements'. <br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A UTF-8 standard string compatible string class. 
<p>
<a class="el" href="classXfc_1_1String.html">String</a> is a custom UTF-8 string class that provides standard string interoperability. It is implemented using a standard string as an internal byte array but uses its own iterators, <a class="el" href="classXfc_1_1Forward__StringIterator.html">Forward_StringIterator</a> and <a class="el" href="classXfc_1_1Reverse__StringIterator.html">Reverse_StringIterator</a>. To keep the syntax consistent with standard string the <a class="el" href="classXfc_1_1String.html">String</a> class typedefs these iterators as iterator and revervse_iterator respectively. The const prefix has been omitted since there are no non-const iterators. <a class="el" href="classXfc_1_1String.html">String</a> presents an interface similar to standard string but with extra method wrappers for GLIB's UTF-8 functions. One important difference are the values returned <a class="el" href="classXfc_1_1String.html#6298e17cc74f5eef2e2ae204dcd406d8">length()</a> and <a class="el" href="classXfc_1_1String.html#80b48da9d8cd2832eab306626d6b95c6">size()</a>. The <em>length</em> is the number of UTF-8 characters in the string whereas the <em>size</em> is the number of bytes occupied by <em>length</em> characters. Remember, in UTF-8 strings characters can span multiple bytes. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="ef3d46bc158f5997b8711eb96c3d7b2f"></a><!-- doxytag: member="Xfc::String::String" ref="ef3d46bc158f5997b8711eb96c3d7b2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an empty string. 
<p>
Creates an empty <a class="el" href="classXfc_1_1String.html">String</a> with no characters. This string can be represented as "" and is therefore never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="bde9e1ad29d5920c226bc2458a7e12fd"></a><!-- doxytag: member="Xfc::String::String" ref="bde9e1ad29d5920c226bc2458a7e12fd" args="(const String &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1String.html">String</a> containing valid UTF-8 characters.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> from <em>str</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="0b6a5188bfc91a210567cafc039404fd"></a><!-- doxytag: member="Xfc::String::String" ref="0b6a5188bfc91a210567cafc039404fd" args="(const String &amp;str, size_t char_pos, size_t n_chars=npos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>char_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_chars</em> = <code><a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a substring of <em>str</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1String.html">String</a> containing valid UTF-8 characters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>char_pos</em>&nbsp;</td><td>The starting character position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_chars</em>&nbsp;</td><td>The maximum number of UTF-8 characters to read.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> that is a substring of <em>str</em>. The substring begins at <em>char_pos</em> and contains at most <em>n_chars</em> characters. If n_chars is <em>npos</em> the substring contains all the remaining characters in <em>str</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="c04c4a5324b9dfeb918ccd3ee5e74bf8"></a><!-- doxytag: member="Xfc::String::String" ref="c04c4a5324b9dfeb918ccd3ee5e74bf8" args="(const std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a copy of the standard string <em>str</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A standard string containing valid UTF-8 characters.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> from <em>str</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="db6a00c60b526c13a337954a88c9ac29"></a><!-- doxytag: member="Xfc::String::String" ref="db6a00c60b526c13a337954a88c9ac29" args="(const std::string &amp;str, size_t n_chars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_chars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a substring of the standard string <em>str</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A standard string containing valid UTF-8 characters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_chars</em>&nbsp;</td><td>The maximum number of UTF-8 characters to read.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> that is a substring of <em>str</em>. The substring contains at most <em>n_chars</em> characters. If n_chars is <em>npos</em> the substring contains all the characters in <em>str</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="f3a1cc3b54962535b42ab1bf2c5fd3f3"></a><!-- doxytag: member="Xfc::String::String" ref="f3a1cc3b54962535b42ab1bf2c5fd3f3" args="(const char *s, size_t n_chars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_chars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a substring of the characters in array <em>s</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A UTF-8 character string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_chars</em>&nbsp;</td><td>The maximum number of UTF-8 characters to read.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> whose contents is <em>n_chars</em> characters pointed to by <em>s</em>, a UTF-8 character string. If <em>n_chars</em> is <em>npos</em> the string contains all the characters pointed to by <em>s</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="8fc8eee92095db4aafb0cf8014e6ac48"></a><!-- doxytag: member="Xfc::String::String" ref="8fc8eee92095db4aafb0cf8014e6ac48" args="(const char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a copy of the characters in array <em>s</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A UTF-8 character string.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> whose contents is equal to the array of UTF-8 characters pointed to by <em>s</em>. If <em>s</em> is a null, then the new <a class="el" href="classXfc_1_1String.html">String</a> will be null and the <a class="el" href="classXfc_1_1String.html#6a559fa7f81d0f8480175198dcd093b1">null()</a> method will return <em>true</em>. Calling <a class="el" href="classXfc_1_1String.html#c0310d1e8861ade4ae28d859778b6791">c_str()</a> on a null <a class="el" href="classXfc_1_1String.html">String</a> will return a null pointer, whereas calling <a class="el" href="classXfc_1_1String.html#c0310d1e8861ade4ae28d859778b6791">c_str()</a> on an empty <a class="el" href="classXfc_1_1String.html">String</a> will return a pointer to a character string whose only character is set to null (i.e. ""). This is the only constructor that creates a <em>null</em> <a class="el" href="classXfc_1_1String.html">String</a>. The concept of a null <a class="el" href="classXfc_1_1String.html">String</a> exists so that a C string, whose value may or may not be null, can be used to initialize a new <a class="el" href="classXfc_1_1String.html">String</a>, preserving its null state. Then, when you pass <a class="el" href="classXfc_1_1String.html#c0310d1e8861ade4ae28d859778b6791">c_str()</a> to a C function, a null pointer is passed if the <a class="el" href="classXfc_1_1String.html">String</a> is null, not a pointer to an empty string. 
</div>
</div><p>
<a class="anchor" name="3562e43121e2975f309bf4b1b92d388a"></a><!-- doxytag: member="Xfc::String::String" ref="3562e43121e2975f309bf4b1b92d388a" args="(size_t n, char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string with n copies of the ascii character <em>c</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The number of copies of character c. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>An ASCII character.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> with <em>n</em> copies of the ASCII character <em>c</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="2c238d4315c2ffd90eb7ac84680d3472"></a><!-- doxytag: member="Xfc::String::String" ref="2c238d4315c2ffd90eb7ac84680d3472" args="(size_t n, gunichar c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gunichar&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string with n copies of the unicode character <em>c</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The number of copies of character c. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>A UCS-4 unicode character.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> with <em>n</em> copies of the unicode character <em>c</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="2aea5aa14c2d579ec05bb08d72759918"></a><!-- doxytag: member="Xfc::String::String" ref="2aea5aa14c2d579ec05bb08d72759918" args="(const gunichar *s, int n_chars, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const gunichar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a substring of the unicode string <em>s</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A UCS-4 unicode character string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_chars</em>&nbsp;</td><td>The maximum number of UCS-4 unicode characters to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>return location for an allocated <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>, or null to ignore errors.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> that is a substring of the UCS-4 unicode character string <em>s</em>. The substring contains at most <em>n_chars</em> unicode characters converted to UTF-8 characters. If n_chars is <em>npos</em> the substring contains all the characters in <em>s</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="a8fe572129beab6a1d424c9c5007e076"></a><!-- doxytag: member="Xfc::String::String" ref="a8fe572129beab6a1d424c9c5007e076" args="(iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string with the characters in the range+ <em>first</em> to <em>last</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>An iterator pointing to the first byte of a UTF-8 character. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>An iterator pointing to the first byte of a UTF-8 character.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> by reading all the characters in the range <em>first</em> to <em>last</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="ef3d46bc158f5997b8711eb96c3d7b2f"></a><!-- doxytag: member="Xfc::String::String" ref="ef3d46bc158f5997b8711eb96c3d7b2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an empty string. 
<p>
Creates an empty <a class="el" href="classXfc_1_1String.html">String</a> with no characters. This string can be represented as "" and is therefore never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="bde9e1ad29d5920c226bc2458a7e12fd"></a><!-- doxytag: member="Xfc::String::String" ref="bde9e1ad29d5920c226bc2458a7e12fd" args="(const String &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1String.html">String</a> containing valid UTF-8 characters.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> from <em>str</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="0b6a5188bfc91a210567cafc039404fd"></a><!-- doxytag: member="Xfc::String::String" ref="0b6a5188bfc91a210567cafc039404fd" args="(const String &amp;str, size_t char_pos, size_t n_chars=npos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>char_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_chars</em> = <code><a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a substring of <em>str</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1String.html">String</a> containing valid UTF-8 characters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>char_pos</em>&nbsp;</td><td>The starting character position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_chars</em>&nbsp;</td><td>The maximum number of UTF-8 characters to read.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> that is a substring of <em>str</em>. The substring begins at <em>char_pos</em> and contains at most <em>n_chars</em> characters. If n_chars is <em>npos</em> the substring contains all the remaining characters in <em>str</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="c04c4a5324b9dfeb918ccd3ee5e74bf8"></a><!-- doxytag: member="Xfc::String::String" ref="c04c4a5324b9dfeb918ccd3ee5e74bf8" args="(const std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a copy of the standard string <em>str</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A standard string containing valid UTF-8 characters.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> from <em>str</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="db6a00c60b526c13a337954a88c9ac29"></a><!-- doxytag: member="Xfc::String::String" ref="db6a00c60b526c13a337954a88c9ac29" args="(const std::string &amp;str, size_t n_chars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_chars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a substring of the standard string <em>str</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A standard string containing valid UTF-8 characters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_chars</em>&nbsp;</td><td>The maximum number of UTF-8 characters to read.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> that is a substring of <em>str</em>. The substring contains at most <em>n_chars</em> characters. If n_chars is <em>npos</em> the substring contains all the characters in <em>str</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="f3a1cc3b54962535b42ab1bf2c5fd3f3"></a><!-- doxytag: member="Xfc::String::String" ref="f3a1cc3b54962535b42ab1bf2c5fd3f3" args="(const char *s, size_t n_chars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_chars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a substring of the characters in array <em>s</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A UTF-8 character string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_chars</em>&nbsp;</td><td>The maximum number of UTF-8 characters to read.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> whose contents is <em>n_chars</em> characters pointed to by <em>s</em>, a UTF-8 character string. If <em>n_chars</em> is <em>npos</em> the string contains all the characters pointed to by <em>s</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="8fc8eee92095db4aafb0cf8014e6ac48"></a><!-- doxytag: member="Xfc::String::String" ref="8fc8eee92095db4aafb0cf8014e6ac48" args="(const char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a copy of the characters in array <em>s</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A UTF-8 character string.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> whose contents is equal to the array of UTF-8 characters pointed to by <em>s</em>. If <em>s</em> is a null, then the new <a class="el" href="classXfc_1_1String.html">String</a> will be null and the <a class="el" href="classXfc_1_1String.html#6a559fa7f81d0f8480175198dcd093b1">null()</a> method will return <em>true</em>. Calling <a class="el" href="classXfc_1_1String.html#c0310d1e8861ade4ae28d859778b6791">c_str()</a> on a null <a class="el" href="classXfc_1_1String.html">String</a> will return a null pointer, whereas calling <a class="el" href="classXfc_1_1String.html#c0310d1e8861ade4ae28d859778b6791">c_str()</a> on an empty <a class="el" href="classXfc_1_1String.html">String</a> will return a pointer to a character string whose only character is set to null (i.e. ""). This is the only constructor that creates a <em>null</em> <a class="el" href="classXfc_1_1String.html">String</a>. The concept of a null <a class="el" href="classXfc_1_1String.html">String</a> exists so that a C string, whose value may or may not be null, can be used to initialize a new <a class="el" href="classXfc_1_1String.html">String</a>, preserving its null state. Then, when you pass <a class="el" href="classXfc_1_1String.html#c0310d1e8861ade4ae28d859778b6791">c_str()</a> to a C function, a null pointer is passed if the <a class="el" href="classXfc_1_1String.html">String</a> is null, not a pointer to an empty string. 
</div>
</div><p>
<a class="anchor" name="3562e43121e2975f309bf4b1b92d388a"></a><!-- doxytag: member="Xfc::String::String" ref="3562e43121e2975f309bf4b1b92d388a" args="(size_t n, char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string with n copies of the ascii character <em>c</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The number of copies of character c. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>An ASCII character.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> with <em>n</em> copies of the ASCII character <em>c</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="2c238d4315c2ffd90eb7ac84680d3472"></a><!-- doxytag: member="Xfc::String::String" ref="2c238d4315c2ffd90eb7ac84680d3472" args="(size_t n, gunichar c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gunichar&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string with n copies of the unicode character <em>c</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The number of copies of character c. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>A UCS-4 unicode character.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> with <em>n</em> copies of the unicode character <em>c</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="2aea5aa14c2d579ec05bb08d72759918"></a><!-- doxytag: member="Xfc::String::String" ref="2aea5aa14c2d579ec05bb08d72759918" args="(const gunichar *s, int n_chars, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype">const gunichar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string that is a substring of the unicode string <em>s</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A UCS-4 unicode character string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_chars</em>&nbsp;</td><td>The maximum number of UCS-4 unicode characters to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>return location for an allocated <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a>, or null to ignore errors.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> that is a substring of the UCS-4 unicode character string <em>s</em>. The substring contains at most <em>n_chars</em> unicode characters converted to UTF-8 characters. If n_chars is <em>npos</em> the substring contains all the characters in <em>s</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<a class="anchor" name="a8fe572129beab6a1d424c9c5007e076"></a><!-- doxytag: member="Xfc::String::String" ref="a8fe572129beab6a1d424c9c5007e076" args="(iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xfc::String::String           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1Forward__StringIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a string with the characters in the range+ <em>first</em> to <em>last</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>An iterator pointing to the first byte of a UTF-8 character. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>An iterator pointing to the first byte of a UTF-8 character.</td></tr>
  </table>
</dl>
Create a new <a class="el" href="classXfc_1_1String.html">String</a> by reading all the characters in the range <em>first</em> to <em>last</em>. This <a class="el" href="classXfc_1_1String.html">String</a> is never <em>null</em>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="dfdeb437cb20716ba0b3902b4c804d7c"></a><!-- doxytag: member="Xfc::String::get_char" ref="dfdeb437cb20716ba0b3902b4c804d7c" args="(size_t char_pos) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> Xfc::String::get_char           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>char_pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the UTF-8 byte sequence at <em>char_pos</em> to a unicode character. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_pos</em>&nbsp;</td><td>The character position. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A unicode character or (gunichar)-1 if the unicode character is invalid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="61b3a44dd05e4b3264a79852f2d3a2e2"></a><!-- doxytag: member="Xfc::String::get_char_validated" ref="61b3a44dd05e4b3264a79852f2d3a2e2" args="(size_t char_pos, size_t n_bytes=npos) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> Xfc::String::get_char_validated           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>char_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_bytes</em> = <code><a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the UTF-8 byte sequence at <em>p</em> to a unicode character. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_pos</em>&nbsp;</td><td>The character position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_bytes</em>&nbsp;</td><td>The maximum number of bytes to read, or npos, for no maximum. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A unicode character.</dd></dl>
This method checks for incomplete and invalid characters. It returns (gunichar)-2 if the character at <em>char_pos</em> contains a partial byte sequence that could begin a valid character. It returns gunichar(-1) if the character at <em>char_pos</em> does not contain a valid UTF-8 encoded unicode character. 
</div>
</div><p>
<a class="anchor" name="7a65e6eac3aca9d55a75e97e3933f327"></a><!-- doxytag: member="Xfc::String::index" ref="7a65e6eac3aca9d55a75e97e3933f327" args="(size_t char_pos) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Xfc::String::index           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>char_pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the character offset <em>char_pos</em> to a integer byte index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_pos</em>&nbsp;</td><td>The character offset. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The integer byte index corresponding to <em>char_pos</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="12f39eb0f6bcbf28e2b9ca58ce044b8e"></a><!-- doxytag: member="Xfc::String::offset" ref="12f39eb0f6bcbf28e2b9ca58ce044b8e" args="(const_pointer p) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Xfc::String::offset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1String.html#87576004293473e0f8728a14727a03e5">const_pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a constant pointer to a position within the string to a integer character offset. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>A constant pointer to a byte position within the string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the integer character offset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e96eca7fac8cdb35aeba2e88cec43de5"></a><!-- doxytag: member="Xfc::String::pointer" ref="e96eca7fac8cdb35aeba2e88cec43de5" args="(size_t char_pos) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html#87576004293473e0f8728a14727a03e5">const_pointer</a> Xfc::String::pointer           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>char_pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts an integer character offset to a constant pointer to a position within the string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_pos</em>&nbsp;</td><td>The integer character offset. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A constant pointer to a byte position within the string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6298e17cc74f5eef2e2ae204dcd406d8"></a><!-- doxytag: member="Xfc::String::length" ref="6298e17cc74f5eef2e2ae204dcd406d8" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Xfc::String::length           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the length of the string in characters. 
<p>
For a string containing ASCII characters, the <em>length</em> of the string will be the same as the <em>size</em> of the string. For other UTF-8 characters it will be less. 
</div>
</div><p>
<a class="anchor" name="80b48da9d8cd2832eab306626d6b95c6"></a><!-- doxytag: member="Xfc::String::size" ref="80b48da9d8cd2832eab306626d6b95c6" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Xfc::String::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the size of the string in bytes. 
<p>
For a string containing ASCII characters, the <em>size</em> of the string will be the same as the <em>length</em> of the string. For other UTF-8 characters it will be greater. 
</div>
</div><p>
<a class="anchor" name="47ffb2d05493b6860c78492441d9e4df"></a><!-- doxytag: member="Xfc::String::str" ref="47ffb2d05493b6860c78492441d9e4df" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; Xfc::String::str           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a const reference to the internal std::string. 
<p>
This method can be used to pass a <a class="el" href="classXfc_1_1String.html">String</a> to a function expecting a standard string. 
</div>
</div><p>
<a class="anchor" name="88c40e38b734d66ac7911a2da50de92e"></a><!-- doxytag: member="Xfc::String::at" ref="88c40e38b734d66ac7911a2da50de92e" args="(size_t char_pos) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> Xfc::String::at           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>char_pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1String.html#61b3a44dd05e4b3264a79852f2d3a2e2">get_char_validated()</a> to return the character at <em>char_pos</em> as unicode character. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_pos</em>&nbsp;</td><td>The integer character offset. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The unicode character at <em>char_pos</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="01238eb949b011f16581a574e076f109"></a><!-- doxytag: member="Xfc::String::operator[]" ref="01238eb949b011f16581a574e076f109" args="(size_t char_pos) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> Xfc::String::operator[]           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>char_pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classXfc_1_1String.html#dfdeb437cb20716ba0b3902b4c804d7c">get_char()</a> to return the character at <em>char_pos</em> as unicode character. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_pos</em>&nbsp;</td><td>The integer character offset. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The unicode character at <em>char_pos</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="662c0ec8a8a6137d56beb1c282ea42c1"></a><!-- doxytag: member="Xfc::String::get_char" ref="662c0ec8a8a6137d56beb1c282ea42c1" args="(const_pointer p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> Xfc::String::get_char           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1String.html#87576004293473e0f8728a14727a03e5">const_pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the UTF-8 byte sequence at <em>p</em> to a unicode character. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>A constant pointer to a UTF-8 byte sequence. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A unicode character or (gunichar)-1 if the unicode character is invalid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c42a5bb913ffe678f3c4bdebcaf63dec"></a><!-- doxytag: member="Xfc::String::get_char_validated" ref="c42a5bb913ffe678f3c4bdebcaf63dec" args="(const_pointer p, size_t n_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1G_1_1Unichar.html">G::Unichar</a> Xfc::String::get_char_validated           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1String.html#87576004293473e0f8728a14727a03e5">const_pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the UTF-8 byte sequence at <em>p</em> to a unicode character. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>A constant pointer to a UTF-8 byte sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_bytes</em>&nbsp;</td><td>The maximum number of bytes to read, or npos, for no maximum. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A unicode character.</dd></dl>
This method checks for incomplete and invalid characters. It returns (gunichar)-2 if the character at <em>char_pos</em> contains a partial byte sequence that could begin a valid character. It returns gunichar(-1) if the character at <em>char_pos</em> does not contain a valid UTF-8 encoded unicode character. 
</div>
</div><p>
<a class="anchor" name="91c0b737e6d80c5f467425cd707a6b8b"></a><!-- doxytag: member="Xfc::String::format" ref="91c0b737e6d80c5f467425cd707a6b8b" args="(const char *message_format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::String::format           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>message_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method that does sprintf-style string formatting. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>message_format</em>&nbsp;</td><td>The format string (see the printf() documentation). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>A variable list of arguments to insert in the output. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXfc_1_1String.html">String</a> that holds the formatted output.</dd></dl>
<b>Example:</b> Formatting a string. <div class="fragment"><pre class="fragment">&lt; <a class="code" href="classXfc_1_1String.html#ef3d46bc158f5997b8711eb96c3d7b2f">String</a> <a class="code" href="classXfc_1_1String.html#47ffb2d05493b6860c78492441d9e4df">str</a> = <a class="code" href="classXfc_1_1String.html#91c0b737e6d80c5f467425cd707a6b8b">String::format</a>(<span class="stringliteral">"This is a %s string."</span>, <span class="stringliteral">"formatted"</span>);
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="affc092137503f2531be8f72cb6757d3"></a><!-- doxytag: member="Xfc::String::casefold" ref="affc092137503f2531be8f72cb6757d3" args="(size_t n_bytes=npos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::String::casefold           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_bytes</em> = <code><a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a string into a form that is independent of case. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n_bytes</em>&nbsp;</td><td>The length in bytes, or npos for the entire string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new string, that is a case independent form of the string.</dd></dl>
The result will not correspond to any particular case, but can be compared for equality or ordered with the results of calling <a class="el" href="classXfc_1_1String.html#affc092137503f2531be8f72cb6757d3">casefold()</a> on other strings. Note that calling <a class="el" href="classXfc_1_1String.html#affc092137503f2531be8f72cb6757d3">casefold()</a> followed by <a class="el" href="classXfc_1_1String.html#9e25c18e2a5855507e53a984d7194cf7">collate()</a> is only an approximation to the correct linguistic case insensitive ordering, though it is a fairly good one. Getting this exactly right would require a more sophisticated collation function that takes case sensitivity into account. Currently, such a function is not provided. 
</div>
</div><p>
<a class="anchor" name="164d280bb6bb412843c14763a5ab14c1"></a><!-- doxytag: member="Xfc::String::normalize" ref="164d280bb6bb412843c14763a5ab14c1" args="(GNormalizeMode mode, size_t n_bytes=npos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1String.html">String</a> Xfc::String::normalize           </td>
          <td>(</td>
          <td class="paramtype">GNormalizeMode&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_bytes</em> = <code><a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a string into canonical form. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The type of normalization to perform. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_bytes</em>&nbsp;</td><td>The length in bytes, or npos for the entire string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new string, that is the normalized form of the string.</dd></dl>
Converts a string into canonical form, standardizing such issues as whether a character with an accent is represented as a base character and combining accent or as a single precomposed character. You should generally call <a class="el" href="classXfc_1_1String.html#164d280bb6bb412843c14763a5ab14c1">normalize()</a> before comparing two Unicode strings. The normalization mode G_NORMALIZE_DEFAULT only standardizes differences that do not affect the text content, such as the above-mentioned accent representation. G_NORMALIZE_ALL also standardizes the "compatibility" characters in Unicode, such as SUPERSCRIPT THREE to the standard forms (in this case DIGIT THREE). Formatting information may be lost but for most text operations such characters should be considered the same. For example, <a class="el" href="classXfc_1_1String.html#9e25c18e2a5855507e53a984d7194cf7">collate()</a> normalizes with G_NORMALIZE_ALL as its first step. G_NORMALIZE_DEFAULT_COMPOSE and G_NORMALIZE_ALL_COMPOSE are like G_NORMALIZE_DEFAULT and G_NORMALIZE_ALL, but returned a result with composed forms rather than a maximally decomposed form. This is often useful if you intend to convert the string to a legacy encoding or pass it to a system with less capable Unicode handling. 
</div>
</div><p>
<a class="anchor" name="9e25c18e2a5855507e53a984d7194cf7"></a><!-- doxytag: member="Xfc::String::collate" ref="9e25c18e2a5855507e53a984d7194cf7" args="(const String &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::String::collate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare the string and str for ordering using the linguistically correct rules for the current locale. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A UTF-8 encoded string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 if the string compares before str, 0 if they compare equal, 1 if string compares after str.</dd></dl>
When sorting a large number of strings, it will be significantly faster to comapre them with <a class="el" href="classXfc_1_1String.html#73baaa651b004932c9412f4b9fd23469">collate_key()</a> when sorting. 
</div>
</div><p>
<a class="anchor" name="73baaa651b004932c9412f4b9fd23469"></a><!-- doxytag: member="Xfc::String::collate_key" ref="73baaa651b004932c9412f4b9fd23469" args="(const String &amp;str, size_t n_bytes=npos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::String::collate_key           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXfc_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_bytes</em> = <code><a class="el" href="classXfc_1_1String.html#9f5a01ee75a540c8ab7faeb44c5019d1">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the string and str into collation keys and compares them using strcmp(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A UTF-8 encoded string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_bytes</em>&nbsp;</td><td>The length in bytes, or npos for the entire string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 if the string compares before str, 0 if they compare equal, 1 if string compares after str.</dd></dl>
The results of comparing the two strings with collate_key will always be the same as comparing the two strings with <a class="el" href="classXfc_1_1String.html#9e25c18e2a5855507e53a984d7194cf7">collate()</a>. 
</div>
</div><p>
<a class="anchor" name="2099e0fd7432aa7c28baf8e41f0f0659"></a><!-- doxytag: member="Xfc::String::convert" ref="2099e0fd7432aa7c28baf8e41f0f0659" args="(const char *to_codeset, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xfc::String::convert           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to_codeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the string from UTF-8 to another character set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_codeset</em>&nbsp;</td><td>The character set to convert the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location to store any error, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The converted string if successful, otherwise an empty string and error will be set.</dd></dl>
Any of the errors in GConvertError may occur. 
</div>
</div><p>
<a class="anchor" name="55ec19242d943cadec5e7b4facfbc7ee"></a><!-- doxytag: member="Xfc::String::convert_with_fallback" ref="55ec19242d943cadec5e7b4facfbc7ee" args="(const char *to_codeset, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xfc::String::convert_with_fallback           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to_codeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the string from UTF-8 to another character set, possibly including fallback sequences for characters not representable in the output. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_codeset</em>&nbsp;</td><td>The character set of convert the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location to store any error, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The converted string if successful, otherwise an empty string and error will be set.</dd></dl>
This method uses a default fallback string in place of a character not present in the target encoding. Characters not in the target encoding are represented as Unicode escapes \x{XXXX} or \x{XXXXXX}. Note that it is not guaranteed that the specification for the fallback sequences will be honored. Some systems may do an approximate conversion from <em>from_codeset</em> to UTF-8 in their iconv() functions, in which case GLib will simply return that approximate conversion.<p>
Any of the errors in GConvertError may occur. 
</div>
</div><p>
<a class="anchor" name="ed4400fdcb285a53682e3863f8ad4ccd"></a><!-- doxytag: member="Xfc::String::convert_with_fallback" ref="ed4400fdcb285a53682e3863f8ad4ccd" args="(const char *to_codeset, const char *fallback, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xfc::String::convert_with_fallback           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to_codeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the string from UTF-8 to another character set, possibly including fallback sequences for characters not representable in the output. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_codeset</em>&nbsp;</td><td>The character set of convert the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fallback</em>&nbsp;</td><td>A UTF-8 string to use in place of a character not present in the target encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location to store any error, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The converted string if successful, otherwise an empty string and error will be set.</dd></dl>
The <em>fallback</em> string must be in the target encoding. Characters not in the target encoding are represented as Unicode escapes \x{XXXX} or \x{XXXXXX}. Note that it is not guaranteed that the specification for the fallback sequences will be honored. Some systems may do an approximate conversion from <em>from_codeset</em> to UTF-8 in their iconv() functions, in which case GLib will simply return that approximate conversion.<p>
Any of the errors in GConvertError may occur. 
</div>
</div><p>
<a class="anchor" name="1223c24876567ad92ea83c3395a4373e"></a><!-- doxytag: member="Xfc::String::to_locale" ref="1223c24876567ad92ea83c3395a4373e" args="(G::Error *error=0) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xfc::String::to_locale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the string from UTF-8 to the encoding used by the C runtime for the current locale. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Location to store the error occuring, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The converted string.</dd></dl>
Any of the errors in GConvertError may occur. 
</div>
</div><p>
<a class="anchor" name="dbb85a544662aa75b6f2fed6c670086c"></a><!-- doxytag: member="Xfc::String::to_filename" ref="dbb85a544662aa75b6f2fed6c670086c" args="(G::Error *error=0) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xfc::String::to_filename           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a string from UTF-8 to the encoding used for filenames. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Location to store the error occuring, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The converted string.</dd></dl>
Any of the errors in GConvertError may occur. 
</div>
</div><p>
<a class="anchor" name="2e851a4e19942d2c765e3823f4a58703"></a><!-- doxytag: member="Xfc::String::from_locale" ref="2e851a4e19942d2c765e3823f4a58703" args="(const std::string &amp;opsysstring, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::String::from_locale           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>opsysstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the opsysstring from the current locale's encoding used by the C runtime into a UTF-8 string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>opsysstring</em>&nbsp;</td><td>A string in the encoding of the current locale. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Location to store the error occuring, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The converted <a class="el" href="classXfc_1_1String.html">String</a>.</dd></dl>
Any of the errors in GConvertError may occur. 
</div>
</div><p>
<a class="anchor" name="1b9579a5346a9a51d4c099551801f795"></a><!-- doxytag: member="Xfc::String::from_filename" ref="1b9579a5346a9a51d4c099551801f795" args="(const std::string &amp;opsysstring, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::String::from_filename           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>opsysstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a string from the encoding used for filenames into a UTF-8 string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>opsysstring</em>&nbsp;</td><td>A string in the encoding for filenames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Location to store the error occuring, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The converted <a class="el" href="classXfc_1_1String.html">String</a>.</dd></dl>
Any of the errors in GConvertError may occur. 
</div>
</div><p>
<a class="anchor" name="5e74063a2a9761ce5669918ef13f537e"></a><!-- doxytag: member="Xfc::String::convert" ref="5e74063a2a9761ce5669918ef13f537e" args="(const std::string &amp;str, const char *from_codeset, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::String::convert           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>from_codeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a string from one character set to UTF-8. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to convert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from_codeset</em>&nbsp;</td><td>The character set of <em>str</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location to store any error, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The converted <a class="el" href="classXfc_1_1String.html">String</a> if successful, otherwise a null string and error will be set.</dd></dl>
Any of the errors in GConvertError may occur. 
</div>
</div><p>
<a class="anchor" name="d9846979dda8e4d648100899f013325e"></a><!-- doxytag: member="Xfc::String::convert_with_fallback" ref="d9846979dda8e4d648100899f013325e" args="(const std::string &amp;str, const char *from_codeset, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::String::convert_with_fallback           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>from_codeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a string from one character set to UTF-8, possibly including fallback sequences for characters not representable in the output. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to convert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from_codeset</em>&nbsp;</td><td>The character set of <em>str</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location to store any error, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The converted <a class="el" href="classXfc_1_1String.html">String</a> if successful, otherwise a null string and error will be set.</dd></dl>
This method uses a default fallback string in place of a character not present in the target encoding. Characters not in the target encoding are represented as Unicode escapes \x{XXXX} or \x{XXXXXX}. Note that it is not guaranteed that the specification for the fallback sequences will be honored. Some systems may do an approximate conversion from <em>from_codeset</em> to UTF-8 in their iconv() functions, in which case GLib will simply return that approximate conversion.<p>
Any of the errors in GConvertError may occur. 
</div>
</div><p>
<a class="anchor" name="6b1c8f1efdda691108dca969a0f89289"></a><!-- doxytag: member="Xfc::String::convert_with_fallback" ref="6b1c8f1efdda691108dca969a0f89289" args="(const std::string &amp;str, const char *from_codeset, const char *fallback, G::Error *error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXfc_1_1String.html">String</a> Xfc::String::convert_with_fallback           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>from_codeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a string from one character set to UTF-8, possibly including fallback sequences for characters not representable in the output. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to convert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from_codeset</em>&nbsp;</td><td>The character set of <em>str</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fallback</em>&nbsp;</td><td>A UTF-8 string to use in place of a character not present in the target encoding </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The location to store any error, or null to ignore errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The converted <a class="el" href="classXfc_1_1String.html">String</a> if successful, otherwise a null string and error will be set.</dd></dl>
The <em>fallback</em> string must be in the target encoding. Characters not in the target encoding are represented as Unicode escapes \x{XXXX} or \x{XXXXXX}. Note that it is not guaranteed that the specification for the fallback sequences will be honored. Some systems may do an approximate conversion from <em>from_codeset</em> to UTF-8 in their iconv() functions, in which case GLib will simply return that approximate conversion.<p>
Any of the errors in GConvertError may occur. 
</div>
</div><p>
<a class="anchor" name="d2c27b6290af059734de51ecbd29e4b1"></a><!-- doxytag: member="Xfc::String::validate" ref="d2c27b6290af059734de51ecbd29e4b1" args="(size_t &amp;byte_pos) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::String::validate           </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>byte_pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Validates UTF-8 encoded text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>byte_pos</em>&nbsp;</td><td>The location to store the byte index of the first invalid byte. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if all of str was valid.</dd></dl>
Many routines require valid UTF-8 as input; so data read from a file or the network should be checked with <a class="el" href="classXfc_1_1String.html#d2c27b6290af059734de51ecbd29e4b1">validate()</a> before doing anything else with it. 
</div>
</div><p>
<a class="anchor" name="18467d84356eaf48b6656a0492267456"></a><!-- doxytag: member="Xfc::String::validate" ref="18467d84356eaf48b6656a0492267456" args="(const_pointer *end=0) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::String::validate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXfc_1_1String.html#87576004293473e0f8728a14727a03e5">const_pointer</a> *&nbsp;</td>
          <td class="paramname"> <em>end</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Validates UTF-8 encoded text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>On returning points to the first invalid byte or the end of the string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if all of str was valid.</dd></dl>
Many routines require valid UTF-8 as input; so data read from a file or the network should be checked with <a class="el" href="classXfc_1_1String.html#d2c27b6290af059734de51ecbd29e4b1">validate()</a> before doing anything else with it. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="utfstring_8hh.html">utfstring.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
