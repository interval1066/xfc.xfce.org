<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="classXfc_1_1Trackable.html">Trackable</a></div>
<h1>Xfc::Trackable Class Reference</h1><!-- doxytag: class="Xfc::Trackable" -->The primary base class for the XFC object hierarchy.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/trackable.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::Trackable:
<p><center><img src="classXfc_1_1Trackable.png" usemap="#Xfc::Trackable_map" border="0" alt=""></center>
<map name="Xfc::Trackable_map">
<area href="classXfc_1_1G_1_1IOChannel.html" alt="Xfc::G::IOChannel" shape="rect" coords="0,56,171,80">
<area href="classXfc_1_1G_1_1MainContext.html" alt="Xfc::G::MainContext" shape="rect" coords="181,56,352,80">
<area href="classXfc_1_1G_1_1MainLoop.html" alt="Xfc::G::MainLoop" shape="rect" coords="362,56,533,80">
<area href="classXfc_1_1G_1_1Source.html" alt="Xfc::G::Source" shape="rect" coords="543,56,714,80">
<area href="classXfc_1_1G_1_1TypeInstance.html" alt="Xfc::G::TypeInstance" shape="rect" coords="905,56,1076,80">
<area href="classXfc_1_1Object.html" alt="Xfc::Object" shape="rect" coords="1267,56,1438,80">
<area href="classXfc_1_1G_1_1ChildWatchSource.html" alt="Xfc::G::ChildWatchSource" shape="rect" coords="724,112,895,136">
<area href="classXfc_1_1G_1_1IdleSource.html" alt="Xfc::G::IdleSource" shape="rect" coords="724,168,895,192">
<area href="classXfc_1_1G_1_1IOSource.html" alt="Xfc::G::IOSource" shape="rect" coords="724,224,895,248">
<area href="classXfc_1_1G_1_1TimeoutSource.html" alt="Xfc::G::TimeoutSource" shape="rect" coords="724,280,895,304">
<area href="classXfc_1_1G_1_1Object.html" alt="Xfc::G::Object" shape="rect" coords="1086,112,1257,136">
<area href="classXfc_1_1G_1_1ObjectSignals.html" alt="Xfc::G::ObjectSignals" shape="rect" coords="1086,168,1257,192">
<area href="classXfc_1_1G_1_1TypeInterface.html" alt="Xfc::G::TypeInterface" shape="rect" coords="1086,224,1257,248">
<area href="classXfc_1_1G_1_1AsyncQueue.html" alt="Xfc::G::AsyncQueue" shape="rect" coords="1448,112,1619,136">
<area href="classXfc_1_1G_1_1Boxed.html" alt="Xfc::G::Boxed" shape="rect" coords="1448,168,1619,192">
<area href="classXfc_1_1G_1_1Completion.html" alt="Xfc::G::Completion" shape="rect" coords="1448,224,1619,248">
<area href="classXfc_1_1G_1_1Condition.html" alt="Xfc::G::Condition" shape="rect" coords="1448,280,1619,304">
<area href="classXfc_1_1G_1_1Date.html" alt="Xfc::G::Date" shape="rect" coords="1448,336,1619,360">
<area href="classXfc_1_1G_1_1KeyFile.html" alt="Xfc::G::KeyFile" shape="rect" coords="1448,392,1619,416">
<area href="classXfc_1_1G_1_1MarkupParseContext.html" alt="Xfc::G::MarkupParseContext" shape="rect" coords="1448,448,1619,472">
<area href="classXfc_1_1G_1_1Module.html" alt="Xfc::G::Module" shape="rect" coords="1448,504,1619,528">
<area href="classXfc_1_1G_1_1Mutex.html" alt="Xfc::G::Mutex" shape="rect" coords="1448,560,1619,584">
<area href="classXfc_1_1G_1_1OptionContext.html" alt="Xfc::G::OptionContext" shape="rect" coords="1448,616,1619,640">
<area href="classXfc_1_1G_1_1OptionGroup.html" alt="Xfc::G::OptionGroup" shape="rect" coords="1448,672,1619,696">
<area href="classXfc_1_1G_1_1PatternSpec.html" alt="Xfc::G::PatternSpec" shape="rect" coords="1448,728,1619,752">
<area href="classXfc_1_1G_1_1Rand.html" alt="Xfc::G::Rand" shape="rect" coords="1448,784,1619,808">
<area href="classXfc_1_1G_1_1Scanner.html" alt="Xfc::G::Scanner" shape="rect" coords="1448,840,1619,864">
<area href="classXfc_1_1G_1_1ThreadPool.html" alt="Xfc::G::ThreadPool" shape="rect" coords="1448,896,1619,920">
<area href="classXfc_1_1G_1_1Timer.html" alt="Xfc::G::Timer" shape="rect" coords="1448,952,1619,976">
<area href="classXfc_1_1Gdk_1_1PixbufFormat.html" alt="Xfc::Gdk::PixbufFormat" shape="rect" coords="1448,1008,1619,1032">
<area href="classXfc_1_1Gdk_1_1Region.html" alt="Xfc::Gdk::Region" shape="rect" coords="1448,1064,1619,1088">
<area href="classXfc_1_1Gtk_1_1TargetList.html" alt="Xfc::Gtk::TargetList" shape="rect" coords="1448,1120,1619,1144">
<area href="classXfc_1_1Pango_1_1Attribute.html" alt="Xfc::Pango::Attribute" shape="rect" coords="1448,1176,1619,1200">
<area href="classXfc_1_1Pango_1_1AttrIterator.html" alt="Xfc::Pango::AttrIterator" shape="rect" coords="1448,1232,1619,1256">
<area href="classXfc_1_1Pango_1_1Coverage.html" alt="Xfc::Pango::Coverage" shape="rect" coords="1448,1288,1619,1312">
<area href="classXfc_1_1Pango_1_1Item.html" alt="Xfc::Pango::Item" shape="rect" coords="1448,1344,1619,1368">
<area href="classXfc_1_1Pango_1_1LayoutLine.html" alt="Xfc::Pango::LayoutLine" shape="rect" coords="1448,1400,1619,1424">
</map>
<a href="classXfc_1_1Trackable-members.html">List of all members.</a><h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>bool <a class="el" href="classXfc_1_1Trackable.html#b6c92724f9e6004dbcbbbda8f217c8fa">is_dynamic</a> () const
<dl class="el"><dd class="mdescRight">Determines whether the object was allocated from the heap.  <a href="#b6c92724f9e6004dbcbbbda8f217c8fa"></a><br></dl><li>bool <a class="el" href="classXfc_1_1Trackable.html#6a03464221d8722811d1b911643627ec">owns_reference</a> () const
<dl class="el"><dd class="mdescRight">The owns_reference flag setting.  <a href="#6a03464221d8722811d1b911643627ec"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li><a class="anchor" name="dcb8707f7fa6dddef79a9d9b77eb669d"></a><!-- doxytag: member="Xfc::Trackable::ref" ref="dcb8707f7fa6dddef79a9d9b77eb669d" args="()" -->
virtual void <a class="el" href="classXfc_1_1Trackable.html#dcb8707f7fa6dddef79a9d9b77eb669d">ref</a> ()
<dl class="el"><dd class="mdescRight">Increases the object's reference count by one. <br></dl><li>virtual void <a class="el" href="classXfc_1_1Trackable.html#e3755b87fbff5a30350e2bf7492a62a0">unref</a> ()
<dl class="el"><dd class="mdescRight">Decreases the object's reference count by one.  <a href="#e3755b87fbff5a30350e2bf7492a62a0"></a><br></dl></ul>
<h2>Static Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>static std::new_handler <a class="el" href="classXfc_1_1Trackable.html#82590edd0c84e7850d77de9be6d10761">set_new_handler</a> (std::new_handler handler)
<dl class="el"><dd class="mdescRight">Specify a class-specific out-of-memory handler.  <a href="#82590edd0c84e7850d77de9be6d10761"></a><br></dl><li>static void * <a class="el" href="classXfc_1_1Trackable.html#23d0cd5dcecb0517d127f38a98c7ee3f">operator new</a> (size_t size)
<dl class="el"><dd class="mdescRight">Class-specific operator new; inherited by derived classes.  <a href="#23d0cd5dcecb0517d127f38a98c7ee3f"></a><br></dl><li>static void * <a class="el" href="classXfc_1_1Trackable.html#8a9d95309bb6c7f8086d1afcf16a3912">operator new</a> (size_t size, void *ptr)
<dl class="el"><dd class="mdescRight">Class-specific placement operator new.  <a href="#8a9d95309bb6c7f8086d1afcf16a3912"></a><br></dl><li>static void <a class="el" href="classXfc_1_1Trackable.html#1591682fd3d8b056f936412d411c4f9f">operator delete</a> (void *ptr)
<dl class="el"><dd class="mdescRight">Class-specific operator delete; inherited by derived classes.  <a href="#1591682fd3d8b056f936412d411c4f9f"></a><br></dl></ul>
<h2>Protected Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="classXfc_1_1Trackable.html#2c30e514f6b061120c1994f19840e7c6">set_owns_reference</a> (bool setting)
<dl class="el"><dd class="mdescRight">Set the internal <em>owns_reference</em> flag.  <a href="#2c30e514f6b061120c1994f19840e7c6"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The primary base class for the XFC object hierarchy. 
<p>
<a class="el" href="classXfc_1_1Trackable.html">Trackable</a> is a reference counting base class. It implements the reference counting features required by the XFC smart pointer, Xfc::Pointer&lt;&gt;. <a class="el" href="classXfc_1_1Trackable.html">Trackable</a> is also a memory manager. It allows XFC objects to be created either on the heap or on the stack, and it prevents memory leaks by catching any stray objects. <a class="el" href="classXfc_1_1Trackable.html">Trackable</a> is based on "Item 27" from Scott Meyers book: More Effective C++. It is a memory tracking class that keeps track of objects allocated on the heap. <a class="el" href="classXfc_1_1Trackable.html">Trackable</a> provides it's own version of operator new and delete. All new allocations are added to an internal allocation list. When an object's reference count reaches zero the object is removed from this list and delete is called.<p>
When a program ends, <a class="el" href="classXfc_1_1Trackable.html">Trackable</a> walks through the object allocation list and calls operator delete to free any pointers it finds. This frees the raw memory a pointer points to but note - it doesn't call the object destructor. Ideally, if a program manages heap memory correctly the list should be empty, but it wont be. The list will contain a C++ pointers to any wrapped global GTK+ objects used in your program, such as <a class="el" href="classXfc_1_1Gdk_1_1Display.html">Gdk::Display</a>, <a class="el" href="classXfc_1_1Gdk_1_1Keymap.html">Gdk::Keymap</a>, <a class="el" href="classXfc_1_1Gdk_1_1Screen.html">Gdk::Screen</a>, <a class="el" href="classXfc_1_1Gtk_1_1Clipboard.html">Gtk::Clipboard</a>, the default <a class="el" href="classXfc_1_1Gdk_1_1Colormap.html">Gdk::Colormap</a> and the default <a class="el" href="classXfc_1_1Gtk_1_1Style.html">Gtk::Style</a>.<p>
Why? If you remember, XFC adds a hook to GTK+ that calls a global "destroy_notify" function when each GTK+ object is destroyed. This function checks to see if the C++ wrapper for the GTK+ object being destroyed was dynamically allocated, and if it was calls delete (otherwise the object was allocated on the stack and nothing happens). This is how XFC manages memory. It lets the GTK+ object decide when it's time to destroy the C++ wrapper, which only happens when an object's reference count drops to zero. This causes a problem for those few default and global objects owned by GTK+. They don't get destroyed until GTK+ is removed from memory, which is never if you use the GNOME desktop. When a program ends the C++ wrappers for these objects will not be deleted and over time could cause a significant memory leak. Since these objects are few, the easiest solution was to have <a class="el" href="classXfc_1_1Trackable.html">Trackable</a> clean up after itself and free their allocated raw memory.<p>
<b>Note:</b> Do not use <a class="el" href="classXfc_1_1Trackable.html">Trackable</a> as a garbage collector. It only cleans up after a program ends and not while it's running. The programmer is still responsible for allocating and freeing heap objects correctly. <a class="el" href="classXfc_1_1Trackable.html">Trackable</a> is just a safe guard to prevent inadvertent memory leaks. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2c30e514f6b061120c1994f19840e7c6"></a><!-- doxytag: member="Xfc::Trackable::set_owns_reference" ref="2c30e514f6b061120c1994f19840e7c6" args="(bool setting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Trackable::set_owns_reference           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the internal <em>owns_reference</em> flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Set <em>true</em> if the initial reference count must be removed by owner.</td></tr>
  </table>
</dl>
Called by derived classes to set the owns_reference_ flag. A <a class="el" href="classXfc_1_1G_1_1Object.html">G::Object</a> sets this flag to true , indicating that it owns the initial reference count and <a class="el" href="classXfc_1_1Trackable.html#e3755b87fbff5a30350e2bf7492a62a0">unref()</a> must be called. As a general rule a <a class="el" href="classXfc_1_1Gtk_1_1Object.html">Gtk::Object</a> sets this flag to false, indicating that the initial reference count is floating and <a class="el" href="classXfc_1_1Trackable.html#e3755b87fbff5a30350e2bf7492a62a0">unref()</a> only needs to be called if you take ownership. If you pass a <a class="el" href="classXfc_1_1Gtk_1_1Object.html">Gtk::Object</a> to an owner or add a <a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a> to a container you only need to call <a class="el" href="classXfc_1_1Trackable.html#e3755b87fbff5a30350e2bf7492a62a0">unref()</a> if you called <a class="el" href="classXfc_1_1Trackable.html#dcb8707f7fa6dddef79a9d9b77eb669d">ref()</a>. 
</div>
</div><p>
<a class="anchor" name="b6c92724f9e6004dbcbbbda8f217c8fa"></a><!-- doxytag: member="Xfc::Trackable::is_dynamic" ref="b6c92724f9e6004dbcbbbda8f217c8fa" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Trackable::is_dynamic           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the object was allocated from the heap. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the object was created by new and can safely be deleted. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6a03464221d8722811d1b911643627ec"></a><!-- doxytag: member="Xfc::Trackable::owns_reference" ref="6a03464221d8722811d1b911643627ec" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Trackable::owns_reference           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The owns_reference flag setting. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if <a class="el" href="classXfc_1_1Trackable.html#e3755b87fbff5a30350e2bf7492a62a0">unref()</a> must be explicitly called on this object.</dd></dl>
This is mainly used by the XFC smart pointer to deteremine if the initial reference count is owned by the object and must be explicitly cleared. 
</div>
</div><p>
<a class="anchor" name="e3755b87fbff5a30350e2bf7492a62a0"></a><!-- doxytag: member="Xfc::Trackable::unref" ref="e3755b87fbff5a30350e2bf7492a62a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Xfc::Trackable::unref           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decreases the object's reference count by one. 
<p>
After this call, if the object reference is zero and the object was allocated on the heap, delete is automatically called. <b>You don't need to call delete on objects derived from <a class="el" href="classXfc_1_1Trackable.html">Trackable</a></b>. <a class="el" href="classXfc_1_1Trackable.html">Trackable</a> has no refernece counter itself. It just sets up the reference counting API for the derived classes classes <a class="el" href="classXfc_1_1Object.html">Xfc::Object</a> and <a class="el" href="classXfc_1_1G_1_1TypeInstance.html">Xfc::G::TypeInstance</a>, which do have reference counters. Therefore <a class="el" href="classXfc_1_1Trackable.html#e3755b87fbff5a30350e2bf7492a62a0">Trackable::unref()</a> must only be called by a dervied class when its reference count reaches zero. 
<p>
Reimplemented in <a class="el" href="classXfc_1_1G_1_1AsyncQueue.html#2858622c763028508656cb7af94e9fbc">Xfc::G::AsyncQueue</a>, <a class="el" href="classXfc_1_1G_1_1IOChannel.html#45c8749367a15752d764807d172fea56">Xfc::G::IOChannel</a>, <a class="el" href="classXfc_1_1G_1_1MainContext.html#18927522b935969fad0e2bca1a1f47dd">Xfc::G::MainContext</a>, <a class="el" href="classXfc_1_1G_1_1MainLoop.html#7662bad9eb67bd1fec09d58df8b2d07f">Xfc::G::MainLoop</a>, <a class="el" href="classXfc_1_1G_1_1Source.html#fcf6f1e4ad6022e1a87c1d5be35f27dc">Xfc::G::Source</a>, <a class="el" href="classXfc_1_1G_1_1Object.html#513fc400272db0db24d32f9a280e64a5">Xfc::G::Object</a>, and <a class="el" href="classXfc_1_1Object.html#97861bfac97de2b84b18803c1bd560ca">Xfc::Object</a>.
</div>
</div><p>
<a class="anchor" name="82590edd0c84e7850d77de9be6d10761"></a><!-- doxytag: member="Xfc::Trackable::set_new_handler" ref="82590edd0c84e7850d77de9be6d10761" args="(std::new_handler handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::new_handler Xfc::Trackable::set_new_handler           </td>
          <td>(</td>
          <td class="paramtype">std::new_handler&nbsp;</td>
          <td class="paramname"> <em>handler</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify a class-specific out-of-memory handler. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>A user defined out-of-memory handler to install. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="23d0cd5dcecb0517d127f38a98c7ee3f"></a><!-- doxytag: member="Xfc::Trackable::operator new" ref="23d0cd5dcecb0517d127f38a98c7ee3f" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* Xfc::Trackable::operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Class-specific operator new; inherited by derived classes. 
<p>
Stores a pointer to each <em>new</em> allocation in the allocation_list. If the allocation fails the out-of-memory handler is called. 
</div>
</div><p>
<a class="anchor" name="8a9d95309bb6c7f8086d1afcf16a3912"></a><!-- doxytag: member="Xfc::Trackable::operator new" ref="8a9d95309bb6c7f8086d1afcf16a3912" args="(size_t size, void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* Xfc::Trackable::operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Class-specific placement operator new. 
<p>
This operator new is defined for GCC versions prior to 3.4.0. The standard C++ library included with these versions has a bug in &lt;stl_construct.h&gt; at line 78. Operator new in this line is missing the scope resolution operator, so instead of calling global placement new it calls the class placement new operator. This version of placement new simply calls the global placement new operator . 
</div>
</div><p>
<a class="anchor" name="1591682fd3d8b056f936412d411c4f9f"></a><!-- doxytag: member="Xfc::Trackable::operator delete" ref="1591682fd3d8b056f936412d411c4f9f" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Xfc::Trackable::operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Class-specific operator delete; inherited by derived classes. 
<p>
Only deletes <em>ptr</em> if it's in the <a class="el" href="classXfc_1_1Trackable.html">Trackable</a> allocation list. You should not call delete yourself! <a class="el" href="classXfc_1_1Object.html">Object</a> deletion is handled internally by XFC. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="trackable_8hh.html">trackable.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
