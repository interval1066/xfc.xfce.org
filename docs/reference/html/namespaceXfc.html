<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<h1>Xfc Namespace Reference</h1>The primary namespace for the Xfce Foundation Classes.  
<a href="#_details">More...</a>
<p>
<h2>Classes</h2>
<ul>
<li>class <a class="el" href="classXfc_1_1IntegerObject.html">IntegerObject</a>
<dl class="el"><dd class="mdescRight">A C++ template base class for integer objects.  <a href="classXfc_1_1IntegerObject.html#_details">More...</a><br></dl><li>class <a class="el" href="classXfc_1_1Object.html">Object</a>
<dl class="el"><dd class="mdescRight">Reference counting base class.  <a href="classXfc_1_1Object.html#_details">More...</a><br></dl><li>class <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>
<dl class="el"><dd class="mdescRight">Smart pointer template class.  <a href="classXfc_1_1Pointer.html#_details">More...</a><br></dl><li>class <a class="el" href="classXfc_1_1StackObject.html">StackObject</a>
<dl class="el"><dd class="mdescRight">A C++ base class for automatic (or stack) objects.  <a href="classXfc_1_1StackObject.html#_details">More...</a><br></dl><li>class <a class="el" href="classXfc_1_1Trackable.html">Trackable</a>
<dl class="el"><dd class="mdescRight">The primary base class for the XFC object hierarchy.  <a href="classXfc_1_1Trackable.html#_details">More...</a><br></dl><li>class <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a>
<dl class="el"><dd class="mdescRight">UTF-8 string iterator base class.  <a href="classXfc_1_1StringIterator.html#_details">More...</a><br></dl><li>class <a class="el" href="classXfc_1_1Forward__StringIterator.html">Forward_StringIterator</a>
<dl class="el"><dd class="mdescRight">A const non-random access iterator that iterates over a <a class="el" href="classXfc_1_1String.html">String</a> in the forward direction.  <a href="classXfc_1_1Forward__StringIterator.html#_details">More...</a><br></dl><li>class <a class="el" href="classXfc_1_1Reverse__StringIterator.html">Reverse_StringIterator</a>
<dl class="el"><dd class="mdescRight">A const non-random access iterator that iterates over a <a class="el" href="classXfc_1_1String.html">String</a> in the reverse direction.  <a href="classXfc_1_1Reverse__StringIterator.html#_details">More...</a><br></dl><li>class <a class="el" href="classXfc_1_1String.html">String</a>
<dl class="el"><dd class="mdescRight">A UTF-8 standard string compatible string class.  <a href="classXfc_1_1String.html#_details">More...</a><br></dl></ul>
<h2>Namespaces</h2>
<ul>
<li>namespace <a class="el" href="namespaceXfc_1_1Atk.html">Atk</a>
<dl class="el"><dd class="mdescRight">The C++ framework for the ATK Accessibility Toolkit. <br></dl>
<p>
<li>namespace <a class="el" href="namespaceXfc_1_1G.html">G</a>
<dl class="el"><dd class="mdescRight">The C++ framework for the GObject and GLib libraries. <br></dl>
<p>
<li>namespace <a class="el" href="namespaceXfc_1_1Gdk.html">Gdk</a>
<dl class="el"><dd class="mdescRight">The C++ framework for the GTK+ Drawing Kit and the GdkPixbuf library. <br></dl>
<p>
<li>namespace <a class="el" href="namespaceXfc_1_1Glade.html">Glade</a>
<dl class="el"><dd class="mdescRight">The glade XML interface namespace. <br></dl>
<p>
<li>namespace <a class="el" href="namespaceXfc_1_1Gtk.html">Gtk</a>
<dl class="el"><dd class="mdescRight">The C++ framework for the GTK GUI library. <br></dl>
<p>
<li>namespace <a class="el" href="namespaceXfc_1_1i18n.html">i18n</a>
<dl class="el"><dd class="mdescRight">The internationalization and localization namespace. <br></dl>
<p>
<li>namespace <a class="el" href="namespaceXfc_1_1Main.html">Main</a>
<dl class="el"><dd class="mdescRight">The initialization, main event loop and event namespace. <br></dl>
<p>
<li>namespace <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a>
<dl class="el"><dd class="mdescRight">The C++ framework for the <a class="el" href="namespaceXfc_1_1Pango.html">Pango</a> text handling library. <br></dl>
<p>
</ul>
<h2>Functions</h2>
<tr><td colspan="2"><div class="groupHeader">String conversion functions</div></td></tr>
<ul>
<li>std::vector&lt; <a class="el" href="classXfc_1_1String.html">String</a> &gt; <a class="el" href="namespaceXfc.html#6955ae923c2b8d9e646a141e1672300c">array_to_vector_of_string</a> (const char *const *strs)
<dl class="el"><dd class="mdescRight">A convenience function that converts an array of C strings into a vector of <a class="el" href="classXfc_1_1String.html">String</a>.  <a href="#6955ae923c2b8d9e646a141e1672300c"></a><br></dl><li>char ** <a class="el" href="namespaceXfc.html#f25465fdcb68e670ba4a99f4b9b00f6e">vector_of_string_to_array</a> (const std::vector&lt; <a class="el" href="classXfc_1_1String.html">String</a> &gt; &amp;strings)
<dl class="el"><dd class="mdescRight">A convenience function that converts a vector of <a class="el" href="classXfc_1_1String.html">String</a> into an array of C strings.  <a href="#f25465fdcb68e670ba4a99f4b9b00f6e"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">GetText Methods</div></td></tr>
<ul>
<li>const char * <a class="el" href="namespaceXfc.html#1f992f2d1dac15ed1e5159daf5123280">_</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Convenient wrapper for GNU gettext.  <a href="#1f992f2d1dac15ed1e5159daf5123280"></a><br></dl><li>const char * <a class="el" href="namespaceXfc.html#29fb716be483e34a69fc6534f7db3acc">_</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str, const char *domain)
<dl class="el"><dd class="mdescRight">Convenient wrapper for GNU dgettext.  <a href="#29fb716be483e34a69fc6534f7db3acc"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">IntegerObject equality operators</div></td></tr>
<ul>
<li>template&lt;typename IntegerType&gt; bool <a class="el" href="namespaceXfc.html#79d292e5cb1716e73c6dc68fa84ebdc5">operator==</a> (const <a class="el" href="classXfc_1_1IntegerObject.html">IntegerObject</a>&lt; IntegerType &gt; &amp;lhs, IntegerType rhs)
<dl class="el"><dd class="mdescRight">Equality operator.  <a href="#79d292e5cb1716e73c6dc68fa84ebdc5"></a><br></dl><li>template&lt;typename IntegerType&gt; bool <a class="el" href="namespaceXfc.html#c6c72e03933c357ac0be94d7b5fe1364">operator==</a> (IntegerType lhs, const <a class="el" href="classXfc_1_1IntegerObject.html">IntegerObject</a>&lt; IntegerType &gt; &amp;rhs)
<dl class="el"><dd class="mdescRight">Equality operator.  <a href="#c6c72e03933c357ac0be94d7b5fe1364"></a><br></dl><li>template&lt;typename IntegerType&gt; bool <a class="el" href="namespaceXfc.html#66f7f4e8b493303f600c4c28fbfa2c5c">operator!=</a> (const <a class="el" href="classXfc_1_1IntegerObject.html">IntegerObject</a>&lt; IntegerType &gt; &amp;lhs, IntegerType rhs)
<dl class="el"><dd class="mdescRight">Inequality operator.  <a href="#66f7f4e8b493303f600c4c28fbfa2c5c"></a><br></dl><li>template&lt;typename IntegerType&gt; bool <a class="el" href="namespaceXfc.html#d93d35f2ffcde2d4fe96440386b0b588">operator!=</a> (IntegerType lhs, const <a class="el" href="classXfc_1_1IntegerObject.html">IntegerObject</a>&lt; IntegerType &gt; &amp;rhs)
<dl class="el"><dd class="mdescRight">Inequality operator.  <a href="#d93d35f2ffcde2d4fe96440386b0b588"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Smart pointer C++-style casting functions</div></td></tr>
<ul>
<li>template&lt;typename To, typename From&gt; <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; To &gt; <a class="el" href="namespaceXfc.html#b5dfc0d98a87d01c08ad14ee55d07b35">cast_const</a> (const <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; From &gt; &amp;from)
<dl class="el"><dd class="mdescRight">Removes the <em>const</em> qualifier from a managed const dumb pointer.  <a href="#b5dfc0d98a87d01c08ad14ee55d07b35"></a><br></dl><li>template&lt;typename To, typename From&gt; <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; To &gt; <a class="el" href="namespaceXfc.html#eb5dd12f287061e313e8436d926aca09">cast_dynamic</a> (const <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; From &gt; &amp;from)
<dl class="el"><dd class="mdescRight">Casts a managed polymophic dumb pointer down or across its inheritance heirarchy.  <a href="#eb5dd12f287061e313e8436d926aca09"></a><br></dl><li>template&lt;typename To, typename From&gt; <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; To &gt; <a class="el" href="namespaceXfc.html#c0de9db2f1f44c6fd65d81799b7b4ee7">cast_static</a> (const <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; From &gt; &amp;from)
<dl class="el"><dd class="mdescRight">Casts a managed dumb pointer to a pointer to a related type.  <a href="#c0de9db2f1f44c6fd65d81799b7b4ee7"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">String i/o stream operators</div></td></tr>
<ul>
<li><a class="anchor" name="7b9f1c570cf48473b4cda104a8e7010c"></a><!-- doxytag: member="Xfc::operator&gt;&gt;" ref="7b9f1c570cf48473b4cda104a8e7010c" args="(std::istream &amp;is, String &amp;str)" -->
std::istream &amp; <a class="el" href="namespaceXfc.html#7b9f1c570cf48473b4cda104a8e7010c">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Read a whitespace-terminated word from an istream to the string str. <br></dl><li><a class="anchor" name="ac778b0a37b776657863a74921052261"></a><!-- doxytag: member="Xfc::operator&lt;&lt;" ref="ac778b0a37b776657863a74921052261" args="(std::ostream &amp;os, const String &amp;str)" -->
std::ostream &amp; <a class="el" href="namespaceXfc.html#ac778b0a37b776657863a74921052261">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;str)
<dl class="el"><dd class="mdescRight">Write the string str to an ostream. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">StringIterator comparison operators</div></td></tr>
<ul>
<li><a class="anchor" name="26f0a0cccafe37dd1c4ca8c75a94237b"></a><!-- doxytag: member="Xfc::operator==" ref="26f0a0cccafe37dd1c4ca8c75a94237b" args="(const StringIterator &amp;lhs, const StringIterator &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#26f0a0cccafe37dd1c4ca8c75a94237b">operator==</a> (const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;lhs, const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string iterators lhs and rhs point to the same character. <br></dl><li><a class="anchor" name="9a4d4f26573d9378690fd1fdbe7bc75a"></a><!-- doxytag: member="Xfc::operator!=" ref="9a4d4f26573d9378690fd1fdbe7bc75a" args="(const StringIterator &amp;lhs, const StringIterator &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#9a4d4f26573d9378690fd1fdbe7bc75a">operator!=</a> (const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;lhs, const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string iterators lhs and rhs do not point to the same character. <br></dl><li><a class="anchor" name="c0519de484501535942e61e42341b236"></a><!-- doxytag: member="Xfc::operator&lt;" ref="c0519de484501535942e61e42341b236" args="(const StringIterator &amp;lhs, const StringIterator &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#c0519de484501535942e61e42341b236">operator&lt;</a> (const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;lhs, const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if lhs points to a character in a string that is before the character pointed to by rhs. <br></dl><li><a class="anchor" name="d249b4f5c0b402771e25b3042c48dc0f"></a><!-- doxytag: member="Xfc::operator&gt;" ref="d249b4f5c0b402771e25b3042c48dc0f" args="(const StringIterator &amp;lhs, const StringIterator &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#d249b4f5c0b402771e25b3042c48dc0f">operator&gt;</a> (const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;lhs, const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if lhs points to a character in a string that is after the character pointed to by rhs. <br></dl><li><a class="anchor" name="560c4228c887de99a91f53871b165afb"></a><!-- doxytag: member="Xfc::operator&lt;=" ref="560c4228c887de99a91f53871b165afb" args="(const StringIterator &amp;lhs, const StringIterator &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#560c4228c887de99a91f53871b165afb">operator&lt;=</a> (const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;lhs, const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if lhs points to a character in a string that is before the character or is the same character pointed to by rhs. <br></dl><li><a class="anchor" name="400ffc61ff5ae6665a5a4f817469d3fa"></a><!-- doxytag: member="Xfc::operator&gt;=" ref="400ffc61ff5ae6665a5a4f817469d3fa" args="(const StringIterator &amp;lhs, const StringIterator &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#400ffc61ff5ae6665a5a4f817469d3fa">operator&gt;=</a> (const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;lhs, const <a class="el" href="classXfc_1_1StringIterator.html">StringIterator</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if lhs points to a character in a string that is the same character or after the character pointed to by rhs. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">String concatenation operators</div></td></tr>
<ul>
<li><a class="anchor" name="c8aab9e03427677ab3521775f967bf35"></a><!-- doxytag: member="Xfc::operator+" ref="c8aab9e03427677ab3521775f967bf35" args="(const String &amp;lhs, const String &amp;rhs)" -->
<a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="namespaceXfc.html#c8aab9e03427677ab3521775f967bf35">operator+</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Append the string rhs to the end of the string lhs and return the result as a new <a class="el" href="classXfc_1_1String.html">String</a>. <br></dl><li><a class="anchor" name="4b3a55d6901a4a3f6cec83b197c25bcf"></a><!-- doxytag: member="Xfc::operator+" ref="4b3a55d6901a4a3f6cec83b197c25bcf" args="(const char *lhs, const String &amp;rhs)" -->
<a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="namespaceXfc.html#4b3a55d6901a4a3f6cec83b197c25bcf">operator+</a> (const char *lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Append the string rhs to the end of the character array lhs and return the result as a new <a class="el" href="classXfc_1_1String.html">String</a>. <br></dl><li><a class="anchor" name="ab82e403192d685b406c9e99fc67deca"></a><!-- doxytag: member="Xfc::operator+" ref="ab82e403192d685b406c9e99fc67deca" args="(char c, const String &amp;rhs)" -->
<a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="namespaceXfc.html#ab82e403192d685b406c9e99fc67deca">operator+</a> (char c, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Append the string rhs to the character c and return the result as a new <a class="el" href="classXfc_1_1String.html">String</a>. <br></dl><li><a class="anchor" name="1ae1cc23f8e8d22771c822dd7369592b"></a><!-- doxytag: member="Xfc::operator+" ref="1ae1cc23f8e8d22771c822dd7369592b" args="(const String &amp;lhs, const char *rhs)" -->
<a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="namespaceXfc.html#1ae1cc23f8e8d22771c822dd7369592b">operator+</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const char *rhs)
<dl class="el"><dd class="mdescRight">Append the character array rhs to the end of the string lhs and return the result as a new <a class="el" href="classXfc_1_1String.html">String</a>. <br></dl><li><a class="anchor" name="153d1440e16b6755c0641d6238ad4c6b"></a><!-- doxytag: member="Xfc::operator+" ref="153d1440e16b6755c0641d6238ad4c6b" args="(const String &amp;lhs, char c)" -->
<a class="el" href="classXfc_1_1String.html">String</a> <a class="el" href="namespaceXfc.html#153d1440e16b6755c0641d6238ad4c6b">operator+</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, char c)
<dl class="el"><dd class="mdescRight">Append the character c to the end of the string lhs and return the result as a new <a class="el" href="classXfc_1_1String.html">String</a>. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">String comparison operators</div></td></tr>
<ul>
<li><a class="anchor" name="34f5db3cd1177182ffb5e47645507993"></a><!-- doxytag: member="Xfc::operator==" ref="34f5db3cd1177182ffb5e47645507993" args="(const String &amp;lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#34f5db3cd1177182ffb5e47645507993">operator==</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs and the string rhs are characterwise equal. <br></dl><li><a class="anchor" name="5b19fecd41147a8bce04264a6c010529"></a><!-- doxytag: member="Xfc::operator==" ref="5b19fecd41147a8bce04264a6c010529" args="(const char *lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#5b19fecd41147a8bce04264a6c010529">operator==</a> (const char *lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the character array lhs and the string rhs are characterwise equal. <br></dl><li><a class="anchor" name="bed70a8b1340349122a384d1563a13c4"></a><!-- doxytag: member="Xfc::operator==" ref="bed70a8b1340349122a384d1563a13c4" args="(const String &amp;lhs, const char *rhs)" -->
bool <a class="el" href="namespaceXfc.html#bed70a8b1340349122a384d1563a13c4">operator==</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const char *rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs and the character array rhs are characterwise equal. <br></dl><li><a class="anchor" name="65bf50470dd8f15e52833aad32583508"></a><!-- doxytag: member="Xfc::operator!=" ref="65bf50470dd8f15e52833aad32583508" args="(const char *lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#65bf50470dd8f15e52833aad32583508">operator!=</a> (const char *lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the character array lhs and the string rhs are not characterwise equal. <br></dl><li><a class="anchor" name="67c697372001b39cf78baab5a9ef115c"></a><!-- doxytag: member="Xfc::operator!=" ref="67c697372001b39cf78baab5a9ef115c" args="(const String &amp;lhs, const char *rhs)" -->
bool <a class="el" href="namespaceXfc.html#67c697372001b39cf78baab5a9ef115c">operator!=</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const char *rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs and the character array rhs are not characterwise equal. <br></dl><li><a class="anchor" name="e6040003c6a3ab0b736198e599362053"></a><!-- doxytag: member="Xfc::operator&lt;" ref="e6040003c6a3ab0b736198e599362053" args="(const String &amp;lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#e6040003c6a3ab0b736198e599362053">operator&lt;</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs is lexicographically before the string rhs. <br></dl><li><a class="anchor" name="03b7f6c670721cdcd6305e2182750ab5"></a><!-- doxytag: member="Xfc::operator&lt;" ref="03b7f6c670721cdcd6305e2182750ab5" args="(const char *lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#03b7f6c670721cdcd6305e2182750ab5">operator&lt;</a> (const char *lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the character array lhs is lexicographically before the string rhs. <br></dl><li><a class="anchor" name="309445c2a468722d22ccf1bfb71e7df8"></a><!-- doxytag: member="Xfc::operator&lt;" ref="309445c2a468722d22ccf1bfb71e7df8" args="(const String &amp;lhs, const char *rhs)" -->
bool <a class="el" href="namespaceXfc.html#309445c2a468722d22ccf1bfb71e7df8">operator&lt;</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const char *rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs is lexicographically before the character array rhs. <br></dl><li><a class="anchor" name="a09ef422a3018984d4848939462f9315"></a><!-- doxytag: member="Xfc::operator&gt;" ref="a09ef422a3018984d4848939462f9315" args="(const char *lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#a09ef422a3018984d4848939462f9315">operator&gt;</a> (const char *lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the character array lhs is lexicographically greater the string rhs. <br></dl><li><a class="anchor" name="f2a41855f018ad2bbd6cbfe55e97baa5"></a><!-- doxytag: member="Xfc::operator&gt;" ref="f2a41855f018ad2bbd6cbfe55e97baa5" args="(const String &amp;lhs, const char *rhs)" -->
bool <a class="el" href="namespaceXfc.html#f2a41855f018ad2bbd6cbfe55e97baa5">operator&gt;</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const char *rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs is lexicographically greater the character array rhs. <br></dl><li><a class="anchor" name="45a2703cc5a03bcfe4ff350f3f3d6af5"></a><!-- doxytag: member="Xfc::operator&lt;=" ref="45a2703cc5a03bcfe4ff350f3f3d6af5" args="(const char *lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#45a2703cc5a03bcfe4ff350f3f3d6af5">operator&lt;=</a> (const char *lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the character array lhs is lexicographically before or equal to the string rhs. <br></dl><li><a class="anchor" name="84e7cbf4675871db3aae7f11057356f7"></a><!-- doxytag: member="Xfc::operator&lt;=" ref="84e7cbf4675871db3aae7f11057356f7" args="(const String &amp;lhs, const char *rhs)" -->
bool <a class="el" href="namespaceXfc.html#84e7cbf4675871db3aae7f11057356f7">operator&lt;=</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const char *rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs is lexicographically before or equal to the character array rhs. <br></dl><li><a class="anchor" name="c16a2b71cf5d3b22b848172ac2629ded"></a><!-- doxytag: member="Xfc::operator&gt;=" ref="c16a2b71cf5d3b22b848172ac2629ded" args="(const char *lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#c16a2b71cf5d3b22b848172ac2629ded">operator&gt;=</a> (const char *lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the character array lhs is lexicographically greater or equal to the string rhs. <br></dl><li><a class="anchor" name="29e5348dd1aada434867aafe163f5d8f"></a><!-- doxytag: member="Xfc::operator&gt;=" ref="29e5348dd1aada434867aafe163f5d8f" args="(const String &amp;lhs, const char *rhs)" -->
bool <a class="el" href="namespaceXfc.html#29e5348dd1aada434867aafe163f5d8f">operator&gt;=</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const char *rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs is lexicographically greater or equal to the character array rhs. <br></dl><li><a class="anchor" name="a40522bf7e76dbd9020a94bfd16ae02b"></a><!-- doxytag: member="Xfc::operator!=" ref="a40522bf7e76dbd9020a94bfd16ae02b" args="(const String &amp;lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#a40522bf7e76dbd9020a94bfd16ae02b">operator!=</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs and the string rhs are not characterwise equal. <br></dl><li><a class="anchor" name="7a522ac76df3de9a2b124a37d99a7a10"></a><!-- doxytag: member="Xfc::operator&gt;" ref="7a522ac76df3de9a2b124a37d99a7a10" args="(const String &amp;lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#7a522ac76df3de9a2b124a37d99a7a10">operator&gt;</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs is lexicographically greater the string rhs. <br></dl><li><a class="anchor" name="0bea6af67559ee101ba7ba200614a527"></a><!-- doxytag: member="Xfc::operator&lt;=" ref="0bea6af67559ee101ba7ba200614a527" args="(const String &amp;lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#0bea6af67559ee101ba7ba200614a527">operator&lt;=</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs is lexicographically before or equal to the string rhs. <br></dl><li><a class="anchor" name="7978506b61f61a0619d75fce63e3a39e"></a><!-- doxytag: member="Xfc::operator&gt;=" ref="7978506b61f61a0619d75fce63e3a39e" args="(const String &amp;lhs, const String &amp;rhs)" -->
bool <a class="el" href="namespaceXfc.html#7978506b61f61a0619d75fce63e3a39e">operator&gt;=</a> (const <a class="el" href="classXfc_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classXfc_1_1String.html">String</a> &amp;rhs)
<dl class="el"><dd class="mdescRight">Returns true if the string lhs is lexicographically greater or equal to the string rhs. <br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The primary namespace for the Xfce Foundation Classes. <hr><h2>Function Documentation</h2>
<a class="anchor" name="29fb716be483e34a69fc6534f7db3acc"></a><!-- doxytag: member="Xfc::_" ref="29fb716be483e34a69fc6534f7db3acc" args="(const String &amp;str, const char *domain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Xfc::_           </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>domain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenient wrapper for GNU dgettext. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1String.html">String</a> to be passed to dgettext(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>domain</em>&nbsp;</td><td>The name of translation domain; will always be a string literal. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The translation of <em>str</em> if it's available in <em>domain</em>.</dd></dl>
GNU gettext does two things. First, it marks a string as translable so xgettext() will find it when it scans your sources. The second thing it does is actually return the translated string. If no translation of <em>str</em> is available the <em>str</em> itself is returned. Libraries must specify the domain because the global domain is reserved for use by applications. Libraries use this method instead of defining a _ macro that calls dgettext(). When you run xgettext() don't forget to specify the '--keyword=_' option. This option tells xgettext that translatable strings are marked with an underscore instead of the word gettext. 
</div>
</div><p>
<a class="anchor" name="1f992f2d1dac15ed1e5159daf5123280"></a><!-- doxytag: member="Xfc::_" ref="1f992f2d1dac15ed1e5159daf5123280" args="(const String &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Xfc::_           </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenient wrapper for GNU gettext. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1String.html">String</a> to be passed to gettext(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The translation of <em>str</em> if it's available in the current domain.</dd></dl>
GNU gettext does two things. First, it marks a string as translable so xgettext() will find it when it scans your sources. The second thing it does is actually return the translated string. If no translation of <em>str</em> is available the <em>str</em> itself is returned. Applications should use this method instead of defining a _ macro that calls gettext(). When you run xgettext() don't forget to specify the '--keyword=_' option. This option tells xgettext that translatable strings are marked with an underscore instead of the word gettext. 
</div>
</div><p>
<a class="anchor" name="6955ae923c2b8d9e646a141e1672300c"></a><!-- doxytag: member="Xfc::array_to_vector_of_string" ref="6955ae923c2b8d9e646a141e1672300c" args="(const char *const *strs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classXfc_1_1String.html">String</a>&gt; Xfc::array_to_vector_of_string           </td>
          <td>(</td>
          <td class="paramtype">const char *const *&nbsp;</td>
          <td class="paramname"> <em>strs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A convenience function that converts an array of C strings into a vector of <a class="el" href="classXfc_1_1String.html">String</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strs</em>&nbsp;</td><td>A null-terminated string array containing the C strings to be converted. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vector of <a class="el" href="classXfc_1_1String.html">String</a> containing the converted C strings. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5dfc0d98a87d01c08ad14ee55d07b35"></a><!-- doxytag: member="Xfc::cast_const" ref="b5dfc0d98a87d01c08ad14ee55d07b35" args="(const Pointer&lt; From &gt; &amp;from)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To, typename From&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;To&gt; Xfc::cast_const           </td>
          <td>(</td>
          <td class="paramtype">const Pointer&lt; From &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the <em>const</em> qualifier from a managed const dumb pointer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Pointer.html">Pointer</a> that manages a const dumb pointer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classXfc_1_1Pointer.html">Pointer</a> that manages the non-const dumb pointer.</dd></dl>
Calls <em>const_cast</em> on the dumb pointer and returns the non-const pointer as a new <a class="el" href="classXfc_1_1Pointer.html">Pointer</a>. 
</div>
</div><p>
<a class="anchor" name="eb5dd12f287061e313e8436d926aca09"></a><!-- doxytag: member="Xfc::cast_dynamic" ref="eb5dd12f287061e313e8436d926aca09" args="(const Pointer&lt; From &gt; &amp;from)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To, typename From&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;To&gt; Xfc::cast_dynamic           </td>
          <td>(</td>
          <td class="paramtype">const Pointer&lt; From &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Casts a managed polymophic dumb pointer down or across its inheritance heirarchy. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Pointer.html">Pointer</a> managing a polymophic dumb pointer of type From. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classXfc_1_1Pointer.html">Pointer</a> managing the dumb pointer as a base or sibling pointer of type <em>To</em>.</dd></dl>
Calls <em>dynmaic_cast</em> to safely cast a managed polymophic dumb pointer of type <em>From</em> to a base, derived or sibling class pointer of type <em>To</em>. 
</div>
</div><p>
<a class="anchor" name="c0de9db2f1f44c6fd65d81799b7b4ee7"></a><!-- doxytag: member="Xfc::cast_static" ref="c0de9db2f1f44c6fd65d81799b7b4ee7" args="(const Pointer&lt; From &gt; &amp;from)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To, typename From&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;To&gt; Xfc::cast_static           </td>
          <td>(</td>
          <td class="paramtype">const Pointer&lt; From &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Casts a managed dumb pointer to a pointer to a related type. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>A <a class="el" href="classXfc_1_1Pointer.html">Pointer</a> managing a dumb pointer of type From. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classXfc_1_1Pointer.html">Pointer</a> managing the dumb pointer as a pointer of type <em>To</em>.</dd></dl>
Calls <em>static_cast</em> to cast a dumb pointer of type <em>From</em> to a pointer of type <em>To</em>. 
</div>
</div><p>
<a class="anchor" name="d93d35f2ffcde2d4fe96440386b0b588"></a><!-- doxytag: member="Xfc::operator!=" ref="d93d35f2ffcde2d4fe96440386b0b588" args="(IntegerType lhs, const IntegerObject&lt; IntegerType &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::operator!=           </td>
          <td>(</td>
          <td class="paramtype">IntegerType&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntegerObject&lt; IntegerType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>A value of type IntegerType. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>An <a class="el" href="classXfc_1_1IntegerObject.html">IntegerObject</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the value of <em>rhs</em> is equal to <em>lhs</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66f7f4e8b493303f600c4c28fbfa2c5c"></a><!-- doxytag: member="Xfc::operator!=" ref="66f7f4e8b493303f600c4c28fbfa2c5c" args="(const IntegerObject&lt; IntegerType &gt; &amp;lhs, IntegerType rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const IntegerObject&lt; IntegerType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerType&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>An <a class="el" href="classXfc_1_1IntegerObject.html">IntegerObject</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>A value of type IntegerType. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the value of <em>lhs</em> is equal to <em>rhs</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c6c72e03933c357ac0be94d7b5fe1364"></a><!-- doxytag: member="Xfc::operator==" ref="c6c72e03933c357ac0be94d7b5fe1364" args="(IntegerType lhs, const IntegerObject&lt; IntegerType &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::operator==           </td>
          <td>(</td>
          <td class="paramtype">IntegerType&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntegerObject&lt; IntegerType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>A value of type IntegerType. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>An <a class="el" href="classXfc_1_1IntegerObject.html">IntegerObject</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the value of <em>rhs</em> is equal to <em>lhs</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="79d292e5cb1716e73c6dc68fa84ebdc5"></a><!-- doxytag: member="Xfc::operator==" ref="79d292e5cb1716e73c6dc68fa84ebdc5" args="(const IntegerObject&lt; IntegerType &gt; &amp;lhs, IntegerType rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::operator==           </td>
          <td>(</td>
          <td class="paramtype">const IntegerObject&lt; IntegerType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerType&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>An <a class="el" href="classXfc_1_1IntegerObject.html">IntegerObject</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>A value of type IntegerType. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the value of <em>lhs</em> is equal to <em>rhs</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f25465fdcb68e670ba4a99f4b9b00f6e"></a><!-- doxytag: member="Xfc::vector_of_string_to_array" ref="f25465fdcb68e670ba4a99f4b9b00f6e" args="(const std::vector&lt; String &gt; &amp;strings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** Xfc::vector_of_string_to_array           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; String &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>strings</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A convenience function that converts a vector of <a class="el" href="classXfc_1_1String.html">String</a> into an array of C strings. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strings</em>&nbsp;</td><td>A vector of <a class="el" href="classXfc_1_1String.html">String</a> to convert into an array of C strings. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A null-terminated array of C strings; this array must be deleted when no longer required.</dd></dl>
The returned C string array is allocated with operator new [] and must be deleted with operator delete [] when no longer required. 
</div>
</div><p>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
