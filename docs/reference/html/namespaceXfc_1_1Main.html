<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1Main.html">Main</a></div>
<h1>Xfc::Main Namespace Reference<br>
<small>
[<a class="el" href="group__xfc__group.html">The Xfc Namespace</a>]</small>
</h1>The initialization, main event loop and event namespace.  
<a href="#_details">More...</a>
<p>
<h2>Classes</h2>
<ul>
<li>class <a class="el" href="classXfc_1_1Main_1_1QuitSignal.html">QuitSignal</a>
<dl class="el"><dd class="mdescRight">Quit signal class.  <a href="classXfc_1_1Main_1_1QuitSignal.html#_details">More...</a><br></dl><li>class <a class="el" href="classXfc_1_1Main_1_1KeySnooperSignal.html">KeySnooperSignal</a>
<dl class="el"><dd class="mdescRight">KeySnooper signal class.  <a href="classXfc_1_1Main_1_1KeySnooperSignal.html#_details">More...</a><br></dl></ul>
<h2>Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Initializers</div></td></tr>
<ul>
<li>void <a class="el" href="namespaceXfc_1_1Main.html#8504c76067cdb92e95bd3f5f7e227896">init</a> (int *argc, char ***argv)
<dl class="el"><dd class="mdescRight">Initialize the XFC library.  <a href="#8504c76067cdb92e95bd3f5f7e227896"></a><br></dl><li>bool <a class="el" href="namespaceXfc_1_1Main.html#c674d908876ea616c17828236dd91a99">init_check</a> (int *argc, char ***argv)
<dl class="el"><dd class="mdescRight">Initialize the XFC library.  <a href="#c674d908876ea616c17828236dd91a99"></a><br></dl><li>bool <a class="el" href="namespaceXfc_1_1Main.html#8f5a4bf71ed453bdb300e1b20c9dfb6f">init_with_args</a> (int *argc, char ***argv, const char *parameter_string, <a class="el" href="classXfc_1_1G_1_1OptionGroup.html">G::OptionGroup</a> &amp;group, <a class="el" href="classXfc_1_1G_1_1Error.html">G::Error</a> *error)
<dl class="el"><dd class="mdescRight">Initialize the XFC library.  <a href="#8f5a4bf71ed453bdb300e1b20c9dfb6f"></a><br></dl><li>void <a class="el" href="namespaceXfc_1_1Main.html#ec0d54d5b6f55d2b4dc82ae6737a57c2">init_add</a> (const sigc::slot&lt; bool &gt; &amp;callback)
<dl class="el"><dd class="mdescRight">Register a slot to be called when the mainloop is started.  <a href="#ec0d54d5b6f55d2b4dc82ae6737a57c2"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li>GOptionGroup * <a class="el" href="namespaceXfc_1_1Main.html#ba947f73edbe3b57f7be721684814988">get_option_group</a> (bool open_default_display=true)
<dl class="el"><dd class="mdescRight">Returns a GOptionGroup for the commandline arguments recognized by GTK+ and GDK.  <a href="#ba947f73edbe3b57f7be721684814988"></a><br></dl><li>PangoLanguage * <a class="el" href="namespaceXfc_1_1Main.html#0753952d9bd633b41b901b0c8b153543">default_language</a> ()
<dl class="el"><dd class="mdescRight">Get the default language currently in effect.  <a href="#0753952d9bd633b41b901b0c8b153543"></a><br></dl><li>bool <a class="el" href="namespaceXfc_1_1Main.html#f97e9d598b4c1b00977488d0eb6cb4d5">events_pending</a> ()
<dl class="el"><dd class="mdescRight">Checks if any events are pending.  <a href="#f97e9d598b4c1b00977488d0eb6cb4d5"></a><br></dl><li><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt; <a class="el" href="classXfc_1_1Gdk_1_1Event.html">Gdk::Event</a> &gt; <a class="el" href="namespaceXfc_1_1Main.html#61210774c603b6eb259ec7570f18a849">get_current_event</a> ()
<dl class="el"><dd class="mdescRight">Obtains a copy of the event currently being processed by GTK+.  <a href="#61210774c603b6eb259ec7570f18a849"></a><br></dl><li>unsigned int <a class="el" href="namespaceXfc_1_1Main.html#5f032f331fe8893dc9fa3bb97241a0a1">get_current_event_time</a> ()
<dl class="el"><dd class="mdescRight">If there is a current event and it has a timestamp, return that timestamp, otherwise return GDK_CURRENT_TIME.  <a href="#5f032f331fe8893dc9fa3bb97241a0a1"></a><br></dl><li>bool <a class="el" href="namespaceXfc_1_1Main.html#6a6f0f3afcc36df5007ab3e6330ae804">get_current_event_state</a> (<a class="el" href="namespaceXfc_1_1Gdk.html#3e9243eedea123c72cc727b05c79f3c0">Gdk::ModifierTypeField</a> *state)
<dl class="el"><dd class="mdescRight">If there is a current event and it has a state field, place that state field in <em>state</em> and return true, otherwise return false.  <a href="#6a6f0f3afcc36df5007ab3e6330ae804"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a> * <a class="el" href="namespaceXfc_1_1Main.html#04fa17444d89be24631d764ce281aadb">get_event_widget</a> (<a class="el" href="classXfc_1_1Gdk_1_1Event.html">Gdk::Event</a> &amp;event)
<dl class="el"><dd class="mdescRight">Get the widget that originally received the <em>event</em>.  <a href="#04fa17444d89be24631d764ce281aadb"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Main Event Loop</div></td></tr>
<ul>
<li>void <a class="el" href="namespaceXfc_1_1Main.html#27e92c29d1c7f686b1bad05dda78c98c">run</a> (<a class="el" href="classXfc_1_1Gtk_1_1Window.html">Gtk::Window</a> *main_window=0)
<dl class="el"><dd class="mdescRight">Runs the main loop until <a class="el" href="namespaceXfc_1_1Main.html#639458a1da017c407742425af77def9a">quit()</a> is called.  <a href="#27e92c29d1c7f686b1bad05dda78c98c"></a><br></dl><li>int <a class="el" href="namespaceXfc_1_1Main.html#92b228d4b725f2d8d7fea6ff473850b7">level</a> ()
<dl class="el"><dd class="mdescRight">Asks for the current nesting level of the main loop.  <a href="#92b228d4b725f2d8d7fea6ff473850b7"></a><br></dl><li><a class="anchor" name="639458a1da017c407742425af77def9a"></a><!-- doxytag: member="Xfc::Main::quit" ref="639458a1da017c407742425af77def9a" args="()" -->
void <a class="el" href="namespaceXfc_1_1Main.html#639458a1da017c407742425af77def9a">quit</a> ()
<dl class="el"><dd class="mdescRight">Makes the innermost invocation of the main loop return when it regains control. <br></dl><li>bool <a class="el" href="namespaceXfc_1_1Main.html#34e24c7f916eda6721b4caaed67e6330">iterate</a> (bool blocking=true)
<dl class="el"><dd class="mdescRight">Runs a single iteration of the mainloop.  <a href="#34e24c7f916eda6721b4caaed67e6330"></a><br></dl><li>void <a class="el" href="namespaceXfc_1_1Main.html#47689b0e4fe3066c037c0c90530739e5">grab_add</a> (<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a> &amp;widget)
<dl class="el"><dd class="mdescRight">Makes <em>widget</em> the current grabbed widget.  <a href="#47689b0e4fe3066c037c0c90530739e5"></a><br></dl><li><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a> * <a class="el" href="namespaceXfc_1_1Main.html#9c9ec6ba625e75363de383605a6b4bea">grab_get_current</a> ()
<dl class="el"><dd class="mdescRight">Queries the current grab.  <a href="#9c9ec6ba625e75363de383605a6b4bea"></a><br></dl><li>void <a class="el" href="namespaceXfc_1_1Main.html#b3573605dc833438a21cc54c5ec43ff2">grab_remove</a> (<a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a> &amp;widget)
<dl class="el"><dd class="mdescRight">Removes the grab from the given widget.  <a href="#b3573605dc833438a21cc54c5ec43ff2"></a><br></dl></ul>
<h2>Variables</h2>
<tr><td colspan="2"><div class="groupHeader">Signals</div></td></tr>
<ul>
<li><a class="anchor" name="bc0d626969eb8234b0c31d5784895acc"></a><!-- doxytag: member="Xfc::Main::quit_signal" ref="bc0d626969eb8234b0c31d5784895acc" args="" -->
<a class="el" href="classXfc_1_1Main_1_1QuitSignal.html">QuitSignal</a> <a class="el" href="namespaceXfc_1_1Main.html#bc0d626969eb8234b0c31d5784895acc">quit_signal</a>
<dl class="el"><dd class="mdescRight">A namespace instance of the <a class="el" href="classXfc_1_1Main_1_1QuitSignal.html">QuitSignal</a> for connecting slots to be invoked at the termination of the current mainloop. <br></dl><li><a class="anchor" name="464d0c2b72d89e2a7f392951ddca8629"></a><!-- doxytag: member="Xfc::Main::key_snooper_signal" ref="464d0c2b72d89e2a7f392951ddca8629" args="" -->
<a class="el" href="classXfc_1_1Main_1_1KeySnooperSignal.html">KeySnooperSignal</a> <a class="el" href="namespaceXfc_1_1Main.html#464d0c2b72d89e2a7f392951ddca8629">key_snooper_signal</a>
<dl class="el"><dd class="mdescRight">A namespace instance of the <a class="el" href="classXfc_1_1Main_1_1KeySnooperSignal.html">KeySnooperSignal</a> for connecting slots that will receive keypress events. <br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The initialization, main event loop and event namespace. 
<p>
Provides a set of methods and signals for handling program initialization and custom event loop processing. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="0753952d9bd633b41b901b0c8b153543"></a><!-- doxytag: member="Xfc::Main::default_language" ref="0753952d9bd633b41b901b0c8b153543" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PangoLanguage* Xfc::Main::default_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the default language currently in effect. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The ISO language code for the default language currently in effect.</dd></dl>
Note that this can change over the life of an application. The default language is derived from the current locale. It determines, for example, whether XFC uses the right-to-left or left-to-right text direction. 
</div>
</div><p>
<a class="anchor" name="f97e9d598b4c1b00977488d0eb6cb4d5"></a><!-- doxytag: member="Xfc::Main::events_pending" ref="f97e9d598b4c1b00977488d0eb6cb4d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Main::events_pending           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if any events are pending. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if any events are pending, <em>false</em> otherwise.</dd></dl>
This can be used to update the GUI and invoke timeouts etc. while doing some time intensive computation.<p>
<b>Example:</b> Updating the GUI during a long computation. <div class="fragment"><pre class="fragment">&lt; <span class="comment">// computation going on</span>
&lt; ...
&lt; <span class="keywordflow">while</span> (<a class="code" href="namespaceXfc_1_1Main.html#f97e9d598b4c1b00977488d0eb6cb4d5">events_pending</a>())
&lt;       <a class="code" href="namespaceXfc_1_1Main.html#34e24c7f916eda6721b4caaed67e6330">iterate</a>();
&lt; ...
&lt; <span class="comment">// computation continued</span>
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="61210774c603b6eb259ec7570f18a849"></a><!-- doxytag: member="Xfc::Main::get_current_event" ref="61210774c603b6eb259ec7570f18a849" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Pointer.html">Pointer</a>&lt;<a class="el" href="classXfc_1_1Gdk_1_1Event.html">Gdk::Event</a>&gt; Xfc::Main::get_current_event           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains a copy of the event currently being processed by GTK+. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A copy of the current event, or null if there is no current event.</dd></dl>
For example, if you get a "clicked" signal from <a class="el" href="classXfc_1_1Gtk_1_1Button.html">Gtk::Button</a>, the current event will be the <a class="el" href="classXfc_1_1Gdk_1_1EventButton.html">Gdk::EventButton</a> that triggered the "clicked" signal. If there is no current event, the function returns null. 
</div>
</div><p>
<a class="anchor" name="6a6f0f3afcc36df5007ab3e6330ae804"></a><!-- doxytag: member="Xfc::Main::get_current_event_state" ref="6a6f0f3afcc36df5007ab3e6330ae804" args="(Gdk::ModifierTypeField *state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Main::get_current_event_state           </td>
          <td>(</td>
          <td class="paramtype">Gdk::ModifierTypeField *&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If there is a current event and it has a state field, place that state field in <em>state</em> and return true, otherwise return false. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The location to store the state of the current event. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if there was a current event and it had a state field. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f032f331fe8893dc9fa3bb97241a0a1"></a><!-- doxytag: member="Xfc::Main::get_current_event_time" ref="5f032f331fe8893dc9fa3bb97241a0a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Xfc::Main::get_current_event_time           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If there is a current event and it has a timestamp, return that timestamp, otherwise return GDK_CURRENT_TIME. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The timestamp from the current event, or GDK_CURRENT_TIME. </dd></dl>

</div>
</div><p>
<a class="anchor" name="04fa17444d89be24631d764ce281aadb"></a><!-- doxytag: member="Xfc::Main::get_event_widget" ref="04fa17444d89be24631d764ce281aadb" args="(Gdk::Event &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a>* Xfc::Main::get_event_widget           </td>
          <td>(</td>
          <td class="paramtype">Gdk::Event &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the widget that originally received the <em>event</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>A reference to a <a class="el" href="classXfc_1_1Gdk_1_1Event.html">Gdk::Event</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The widget that originally received event, or null.</dd></dl>
If <em>event</em> is null or the event was not associated with any widget, returns null, otherwise returns the widget that received the event originally. The widget is returned as a smart pointer because there is the possiblity that the widget was wrapped for the first time and needs to be unreferenced. 
</div>
</div><p>
<a class="anchor" name="ba947f73edbe3b57f7be721684814988"></a><!-- doxytag: member="Xfc::Main::get_option_group" ref="ba947f73edbe3b57f7be721684814988" args="(bool open_default_display=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GOptionGroup* Xfc::Main::get_option_group           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>open_default_display</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a GOptionGroup for the commandline arguments recognized by GTK+ and GDK. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>open_default_display</em>&nbsp;</td><td>Whether to open the default display when parsing the commandline arguments. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A GOptionGroup for the commandline arguments recognized by GTK+.</dd></dl>
You should add this group to your option context with <a class="el" href="classXfc_1_1G_1_1OptionContext.html#2dc740dff90034d2159fac6ac78a5546">G::OptionContext::add_group()</a>, if you are using <a class="el" href="classXfc_1_1G_1_1OptionContext.html">G::OptionContext</a>:parse() to parse your commandline arguments. 
</div>
</div><p>
<a class="anchor" name="47689b0e4fe3066c037c0c90530739e5"></a><!-- doxytag: member="Xfc::Main::grab_add" ref="47689b0e4fe3066c037c0c90530739e5" args="(Gtk::Widget &amp;widget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Main::grab_add           </td>
          <td>(</td>
          <td class="paramtype">Gtk::Widget &amp;&nbsp;</td>
          <td class="paramname"> <em>widget</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes <em>widget</em> the current grabbed widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>widget</em>&nbsp;</td><td>The widget that grabs keyboard and pointer events.</td></tr>
  </table>
</dl>
This means that interaction with other widgets in the same application is blocked and mouse as well as keyboard events are delivered to this widget. 
</div>
</div><p>
<a class="anchor" name="9c9ec6ba625e75363de383605a6b4bea"></a><!-- doxytag: member="Xfc::Main::grab_get_current" ref="9c9ec6ba625e75363de383605a6b4bea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXfc_1_1Gtk_1_1Widget.html">Gtk::Widget</a>* Xfc::Main::grab_get_current           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queries the current grab. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The widget which currently has the grab or null if no grab is active. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3573605dc833438a21cc54c5ec43ff2"></a><!-- doxytag: member="Xfc::Main::grab_remove" ref="b3573605dc833438a21cc54c5ec43ff2" args="(Gtk::Widget &amp;widget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Main::grab_remove           </td>
          <td>(</td>
          <td class="paramtype">Gtk::Widget &amp;&nbsp;</td>
          <td class="paramname"> <em>widget</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the grab from the given widget. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>widget</em>&nbsp;</td><td>The widget which gives up the grab. You have to pair calls to <a class="el" href="namespaceXfc_1_1Main.html#47689b0e4fe3066c037c0c90530739e5">grab_add()</a> and <a class="el" href="namespaceXfc_1_1Main.html#b3573605dc833438a21cc54c5ec43ff2">grab_remove()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8504c76067cdb92e95bd3f5f7e227896"></a><!-- doxytag: member="Xfc::Main::init" ref="8504c76067cdb92e95bd3f5f7e227896" args="(int *argc, char ***argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Main::init           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&nbsp;</td>
          <td class="paramname"> <em>argv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the XFC library. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>argc</em>&nbsp;</td><td>Address of the argc parameter of your main() function, changed if any arguments were handled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argv</em>&nbsp;</td><td>Address of the argv parameter of your main() function, any arguments understood by <a class="el" href="namespaceXfc_1_1Main.html#8504c76067cdb92e95bd3f5f7e227896">init()</a> are stripped before returning.</td></tr>
  </table>
</dl>
Call this method before using any other XFC methods in your GUI applications. It will initialize everything needed to operate the toolkit and parses some standard command line options. argc and argv are adjusted accordingly so your own code will never see those standard arguments. 
</div>
</div><p>
<a class="anchor" name="ec0d54d5b6f55d2b4dc82ae6737a57c2"></a><!-- doxytag: member="Xfc::Main::init_add" ref="ec0d54d5b6f55d2b4dc82ae6737a57c2" args="(const sigc::slot&lt; bool &gt; &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Main::init_add           </td>
          <td>(</td>
          <td class="paramtype">const sigc::slot&lt; bool &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a slot to be called when the mainloop is started. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>A slot to invoke when main() is called next.</td></tr>
  </table>
</dl>
The callback slot should return false to remove it from the list of slots to call, otherwise it might get called again. 
</div>
</div><p>
<a class="anchor" name="c674d908876ea616c17828236dd91a99"></a><!-- doxytag: member="Xfc::Main::init_check" ref="c674d908876ea616c17828236dd91a99" args="(int *argc, char ***argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Main::init_check           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&nbsp;</td>
          <td class="paramname"> <em>argv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the XFC library. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>argc</em>&nbsp;</td><td>Address of the argc parameter of your main() function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argv</em>&nbsp;</td><td>Address of the argv parameter of your main() function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the GUI has been successfully initialized, <em>false</em> otherwise.</dd></dl>
This method does the same work as <a class="el" href="namespaceXfc_1_1Main.html#8504c76067cdb92e95bd3f5f7e227896">init()</a> with only a single change: It does not terminate the program if the GUI can't be initialized. Instead it returns <em>false</em> on failure. This way the application can fall back to some other means of communication with the user - for example a command line interface. 
</div>
</div><p>
<a class="anchor" name="8f5a4bf71ed453bdb300e1b20c9dfb6f"></a><!-- doxytag: member="Xfc::Main::init_with_args" ref="8f5a4bf71ed453bdb300e1b20c9dfb6f" args="(int *argc, char ***argv, const char *parameter_string, G::OptionGroup &amp;group, G::Error *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Main::init_with_args           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&nbsp;</td>
          <td class="paramname"> <em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>parameter_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G::OptionGroup &amp;&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G::Error *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the XFC library. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>argc</em>&nbsp;</td><td>Address of the argc parameter of your main() function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argv</em>&nbsp;</td><td>Address of the argv parameter of your main() function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parameter_string</em>&nbsp;</td><td>The string to display in the first line of --help output, after programname [OPTION...]. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>The option group describing the options of your program. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The return location for errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the GUI has been successfully initialized, <em>false</em> otherwise.</dd></dl>
This method does the same work as <a class="el" href="namespaceXfc_1_1Main.html#c674d908876ea616c17828236dd91a99">init_check()</a>. Additionally, it allows you to add your own commandline options, and it automatically generates nicely formatted --help output. Note that your program will be terminated after writing out the help output.<p>
<b>Example:</b> Initializing your application with optional commandline arguments <div class="fragment"><pre class="fragment">&lt; <span class="keywordtype">int</span> repeats = 2;
&lt; <span class="keywordtype">int</span> max_size = 8;
&lt; <span class="keywordtype">bool</span> verbose = <span class="keyword">false</span>;
&lt; <span class="keywordtype">bool</span> beep = <span class="keyword">false</span>;
&lt; <span class="keywordtype">bool</span> rand = <span class="keyword">false</span>;
&lt;
&lt; <span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
&lt; {
&lt;     <span class="keyword">using namespace </span>Main;
&lt;     G::OptionGroup group;
&lt;     group-&gt;add(<span class="stringliteral">"repeats"</span>, <span class="charliteral">'r'</span>, &amp;repeats, <span class="stringliteral">"Average over N repetitions"</span>, <span class="stringliteral">"N"</span>);
&lt;     group-&gt;add(<span class="stringliteral">"max-size"</span>, <span class="charliteral">'m'</span>, &amp;max_size, <span class="stringliteral">"Test up to 2^M items"</span>, <span class="stringliteral">"M"</span>);
&lt;     group-&gt;add(<span class="stringliteral">"verbose"</span>, <span class="charliteral">'v'</span>, &amp;verbose, <span class="stringliteral">"Be verbose"</span>);
&lt;     group-&gt;add(<span class="stringliteral">"beep"</span>, <span class="charliteral">'b'</span>, &amp;beep, <span class="stringliteral">"Beep when done"</span>);
&lt;     group-&gt;add(<span class="stringliteral">"rand"</span>, 0, &amp;rand, <span class="stringliteral">"Randomize the data"</span>);
&lt;
&lt;     G::Error error;
&lt;     <a class="code" href="namespaceXfc_1_1Main.html#8f5a4bf71ed453bdb300e1b20c9dfb6f">init_with_args</a>(&amp;argc, &amp;argv, <span class="stringliteral">"- test tree model performance"</span>, group, &amp;error);
&lt;     ...
&lt; }
&lt;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="34e24c7f916eda6721b4caaed67e6330"></a><!-- doxytag: member="Xfc::Main::iterate" ref="34e24c7f916eda6721b4caaed67e6330" args="(bool blocking=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::Main::iterate           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>blocking</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Runs a single iteration of the mainloop. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blocking</em>&nbsp;</td><td>Set <em>true</em> if you want to block if no events are pending. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if <a class="el" href="namespaceXfc_1_1Main.html#639458a1da017c407742425af77def9a">quit()</a> has been called for the innermost mainloop.</dd></dl>
If <em>blocking</em> is true and no events are waiting to be processed XFC will block until the next event is noticed. If <em>blocking</em> is false and no events are available return. 
</div>
</div><p>
<a class="anchor" name="92b228d4b725f2d8d7fea6ff473850b7"></a><!-- doxytag: member="Xfc::Main::level" ref="92b228d4b725f2d8d7fea6ff473850b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xfc::Main::level           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks for the current nesting level of the main loop. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The nesting level of the current invocation of the main loop.</dd></dl>
This can be useful when connecting a slot to the <em>quit_signal</em>. 
</div>
</div><p>
<a class="anchor" name="27e92c29d1c7f686b1bad05dda78c98c"></a><!-- doxytag: member="Xfc::Main::run" ref="27e92c29d1c7f686b1bad05dda78c98c" args="(Gtk::Window *main_window=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::Main::run           </td>
          <td>(</td>
          <td class="paramtype">Gtk::Window *&nbsp;</td>
          <td class="paramname"> <em>main_window</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Runs the main loop until <a class="el" href="namespaceXfc_1_1Main.html#639458a1da017c407742425af77def9a">quit()</a> is called. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>main_window</em>&nbsp;</td><td>The main application window, or null.</td></tr>
  </table>
</dl>
If <em>main_window</em> is specified its "destroy" signal is automatically connected to the <a class="el" href="namespaceXfc_1_1Main.html#639458a1da017c407742425af77def9a">Main::quit()</a> function and the window is made visible on the screen. If <em>main_window</em> is null you will have to manage showing and destroying the main window yourself.<p>
You can nest calls to <a class="el" href="namespaceXfc_1_1Main.html#27e92c29d1c7f686b1bad05dda78c98c">run()</a>. In that case <a class="el" href="namespaceXfc_1_1Main.html#639458a1da017c407742425af77def9a">quit()</a> will make the innermost invocation of the main loop return. 
</div>
</div><p>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
