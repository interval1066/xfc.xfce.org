<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="structXfc_1_1G_1_1StaticRWLock.html">StaticRWLock</a></div>
<h1>Xfc::G::StaticRWLock Class Reference</h1><!-- doxytag: class="Xfc::G::StaticRWLock" -->A compile-time GStaticRWlock C++ wrapper interface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/mutex.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::G::StaticRWLock:
<p><center><img src="structXfc_1_1G_1_1StaticRWLock.png" usemap="#Xfc::G::StaticRWLock_map" border="0" alt=""></center>
<map name="Xfc::G::StaticRWLock_map">
<area href="classXfc_1_1G_1_1RWLock.html" alt="Xfc::G::RWLock" shape="rect" coords="0,56,130,80">
</map>
<a href="classXfc_1_1G_1_1StaticRWLock-members.html">List of all members.</a><h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<ul>
<li><a class="anchor" name="e9a40a21bcd03ba7956bb14e29ef2a9f"></a><!-- doxytag: member="Xfc::G::StaticRWLock::init" ref="e9a40a21bcd03ba7956bb14e29ef2a9f" args="()" -->
void <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#e9a40a21bcd03ba7956bb14e29ef2a9f">init</a> ()
<dl class="el"><dd class="mdescRight">Initializes a <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html">StaticRWLock</a>. Alternatively you can initialize it with <a class="el" href="mutex_8hh.html#75eb0b5fc0c78281aee575d98876e2cb">G::XFC_STATIC_RW_LOCK_INIT</a>. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="2eb4197cca6a91bf31d4a58de32d0cf9"></a><!-- doxytag: member="Xfc::G::StaticRWLock::g_static_rw_lock" ref="2eb4197cca6a91bf31d4a58de32d0cf9" args="() const" -->
GStaticRWLock * <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#2eb4197cca6a91bf31d4a58de32d0cf9">g_static_rw_lock</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GStaticRWLock object. <br></dl><li><a class="anchor" name="431221be685ee76cbf78b9058cf730ce"></a><!-- doxytag: member="Xfc::G::StaticRWLock::operator GStaticRWLock *" ref="431221be685ee76cbf78b9058cf730ce" args="() const" -->
<a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#431221be685ee76cbf78b9058cf730ce">operator GStaticRWLock *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; Safely converts a <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html">G::StaticRWLock</a> object into a GStaticRWLock pointer. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#324ada24aa32f79ab452c3700ea977ff">reader_lock</a> ()
<dl class="el"><dd class="mdescRight">Locks a lock for reading.  <a href="#324ada24aa32f79ab452c3700ea977ff"></a><br></dl><li>bool <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#ae1c95a49356a7c28bc43addb32d1497">reader_trylock</a> ()
<dl class="el"><dd class="mdescRight">Tries to lock the lock for reading.  <a href="#ae1c95a49356a7c28bc43addb32d1497"></a><br></dl><li>void <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#1762e1f964fb5c0d4f532e4906c15d66">reader_unlock</a> ()
<dl class="el"><dd class="mdescRight">Unlocks the lock.  <a href="#1762e1f964fb5c0d4f532e4906c15d66"></a><br></dl><li>void <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#8a4fcd2b96238fbc20220715ca53585d">writer_lock</a> ()
<dl class="el"><dd class="mdescRight">Locks the lock for writing.  <a href="#8a4fcd2b96238fbc20220715ca53585d"></a><br></dl><li>bool <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#cd1e26b50cddf3a6ce943524ebd8b9f1">writer_trylock</a> ()
<dl class="el"><dd class="mdescRight">Tries to lock the lock for writing.  <a href="#cd1e26b50cddf3a6ce943524ebd8b9f1"></a><br></dl><li>void <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#d37589ebc0efd9b76294c03ff2db69ad">writer_unlock</a> ()
<dl class="el"><dd class="mdescRight">Unlocks the lock.  <a href="#d37589ebc0efd9b76294c03ff2db69ad"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A compile-time GStaticRWlock C++ wrapper interface. 
<p>
<a class="el" href="structXfc_1_1G_1_1StaticRWLock.html">StaticRWLock</a> represents a read-write lock. A read-write lock can be used for protecting data, that some portions of code only read from, while others also write. In such situations it is desirable, that several readers can read at once, whereas of course only one writer may write at a time. Take a look at the following example:<p>
<b>Example:</b> An array with access functions. <div class="fragment"><pre class="fragment"> G::StaticRWLock rwlock = <a class="code" href="mutex_8hh.html#75eb0b5fc0c78281aee575d98876e2cb">XFC_STATIC_RW_LOCK_INIT</a>;
 GPtrArray *array;

 <span class="keywordtype">void</span>* my_array_get(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)
 {
        <span class="keywordtype">void</span> *retval = 0;

     <span class="keywordflow">if</span> (!array)
                <span class="keywordflow">return</span> 0;

     rw_lock.reader_lock();

     <span class="keywordflow">if</span> (index &lt; array-&gt;len)
                retval = g_ptr_array_index(array, index);

        rwlock.reader_unlock();

     <span class="keywordflow">return</span> retval;
 }

 <span class="keywordtype">void</span> my_array_set(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index, <span class="keywordtype">void</span> *data)
 {
        rwlock.writer_lock();

        <span class="keywordflow">if</span> (!array)
                array = g_ptr_array_new();

        <span class="keywordflow">if</span> (index &gt;= array-&gt;len)
                g_ptr_array_set_size(array, index+1);

        g_ptr_array_index(array, index) = data;

        rwlock.writer_unlock();
 }
</pre></div><p>
This example shows an array, which can be accessed by many readers (the my_array_get() function) simultaneously, whereas the writers (the my_array_set() function) will only be allowed once a time and only if no readers currently access the array. This is because of the potentially dangerous resizing of the array. Using these functions is fully multi-thread safe now.<p>
Most of the time the writers should have precedence over readers. That means for this implementation, that as soon as a writer wants to lock the data, no other reader is allowed to lock the data, whereas of course the readers, that already have locked the data are allowed to finish their operation. As soon as the last reader unlocks the data, the writer will lock it.<p>
A read-write lock has a higher overhead than a mutex. For example both <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#324ada24aa32f79ab452c3700ea977ff">reader_lock()</a> and <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#1762e1f964fb5c0d4f532e4906c15d66">reader_unlock()</a> have to lock and unlock a <a class="el" href="structXfc_1_1G_1_1StaticMutex.html">StaticMutex</a>, so it takes at least twice the time to lock and unlock a <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html">StaticRWLock</a> than to lock and unlock a <a class="el" href="structXfc_1_1G_1_1StaticMutex.html">StaticMutex</a>. So only data structures, that are accessed by multiple readers, which keep the lock for a considerable time justify a <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html">StaticRWLock</a>. The above example most probably would fare better with a <a class="el" href="structXfc_1_1G_1_1StaticMutex.html">StaticMutex</a>. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="324ada24aa32f79ab452c3700ea977ff"></a><!-- doxytag: member="Xfc::G::StaticRWLock::reader_lock" ref="324ada24aa32f79ab452c3700ea977ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::StaticRWLock::reader_lock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks a lock for reading. 
<p>
There may be unlimited concurrent locks for reading of a <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html">StaticRWLock</a> at the same time. If lock is already locked for writing by another thread or if another thread is already waiting to lock lock for writing, this function will block until lock is unlocked by the other writing thread and no other writing threads want to lock lock. This lock has to be unlocked by <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#1762e1f964fb5c0d4f532e4906c15d66">reader_unlock()</a>.<p>
<a class="el" href="structXfc_1_1G_1_1StaticRWLock.html">StaticRWLock</a> is not recursive. It might seem to be possible to recursively lock for reading, but that can result in a deadlock as well, due to writer preference. 
</div>
</div><p>
<a class="anchor" name="ae1c95a49356a7c28bc43addb32d1497"></a><!-- doxytag: member="Xfc::G::StaticRWLock::reader_trylock" ref="ae1c95a49356a7c28bc43addb32d1497" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::StaticRWLock::reader_trylock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to lock the lock for reading. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if lock could be locked for reading.</dd></dl>
If lock is already locked for writing by another thread or if another thread is already waiting to lock lock for writing, it immediately returns false. Otherwise it locks lock for reading and returns true. This lock has to be unlocked by <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#1762e1f964fb5c0d4f532e4906c15d66">reader_unlock()</a>. 
</div>
</div><p>
<a class="anchor" name="1762e1f964fb5c0d4f532e4906c15d66"></a><!-- doxytag: member="Xfc::G::StaticRWLock::reader_unlock" ref="1762e1f964fb5c0d4f532e4906c15d66" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::StaticRWLock::reader_unlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlocks the lock. 
<p>
If a thread waits to lock the lock for writing and all locks for reading have been unlocked, the waiting thread is woken up and can lock lock for writing. 
</div>
</div><p>
<a class="anchor" name="8a4fcd2b96238fbc20220715ca53585d"></a><!-- doxytag: member="Xfc::G::StaticRWLock::writer_lock" ref="8a4fcd2b96238fbc20220715ca53585d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::StaticRWLock::writer_lock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks the lock for writing. 
<p>
If lock is already locked for writing or reading by other threads, this method will block until lock is completely unlocked and then lock the lock for writing. While this method waits to lock the lock, no other thread can lock the lock for reading. When lock is locked for writing, no other thread can lock the lock (neither for reading nor writing). This lock has to be unlocked by <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#d37589ebc0efd9b76294c03ff2db69ad">writer_unlock()</a>. 
</div>
</div><p>
<a class="anchor" name="cd1e26b50cddf3a6ce943524ebd8b9f1"></a><!-- doxytag: member="Xfc::G::StaticRWLock::writer_trylock" ref="cd1e26b50cddf3a6ce943524ebd8b9f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::StaticRWLock::writer_trylock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to lock the lock for writing. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if lock could be locked for writing.</dd></dl>
If lock is already locked (for either reading or writing) by another thread, it immediately returns false. Otherwise it locks the lock for writing and returns true. This lock has to be unlocked by <a class="el" href="structXfc_1_1G_1_1StaticRWLock.html#d37589ebc0efd9b76294c03ff2db69ad">writer_unlock()</a>. 
</div>
</div><p>
<a class="anchor" name="d37589ebc0efd9b76294c03ff2db69ad"></a><!-- doxytag: member="Xfc::G::StaticRWLock::writer_unlock" ref="d37589ebc0efd9b76294c03ff2db69ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::StaticRWLock::writer_unlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlocks the lock. 
<p>
If a thread waits to lock the lock for writing and all locks for reading have been unlocked, the waiting thread is woken up and can lock the lock for writing. If no thread waits to lock the lock for writing and threads wait to lock the lock for reading, the waiting threads are woken up and can lock the lock for reading. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="mutex_8hh.html">mutex.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
