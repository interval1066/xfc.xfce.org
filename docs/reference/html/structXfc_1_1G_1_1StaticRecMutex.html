<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  
  
  
  <title>Xfce Foundation Classes</title>
  <meta content="XFC Reference Manual" name="description">



  
  
  
  <meta content="The XFC Development Team" name="author">



  
  
  
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>


<body>



<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="background-color: rgb(21, 67, 116); text-align: center; height: 25px;"><span style="color: rgb(255, 255, 192); font-weight: bold; font-family: Helvetica,Arial,sans-serif;"><br>



      </span></td>



    </tr>



    <tr>



      <td style="text-align: center; background-color: rgb(255, 255, 255); height: 25px;"><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif; color: rgb(17, 55, 95);">Xfce
Foundation Classes</span><br>



      </td>



    </tr>



    <tr style="font-family: Helvetica,Arial,sans-serif;">



      <td style="height: 25px; text-align: center; background-color: rgb(153, 169, 192);"><font size="-1"><a class="qindexH" href="../../index.html">Main Page</a>&nbsp;
| <a class="qindexH" href="index.html">Index</a> |&nbsp; <a class="qindexH" href="namespaces.html">Namespace
List</a>&nbsp; |&nbsp; <a class="qindexH" href="classes.html">Alphabetical
List</a>&nbsp;
|&nbsp; <a class="qindexH" href="annotated.html">Class List</a>&nbsp;
|&nbsp; <a class="qindexH" href="files.html">File List</a></font> </td>



    </tr>



  
  
  
  </tbody>
</table>



<br>



<br>



</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespaceXfc.html">Xfc</a>::<a class="el" href="namespaceXfc_1_1G.html">G</a>::<a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html">StaticRecMutex</a></div>
<h1>Xfc::G::StaticRecMutex Class Reference</h1><!-- doxytag: class="Xfc::G::StaticRecMutex" -->A compile-time GStaticRecMutex C++ wrapper interface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;xfc/glib/mutex.hh&gt;</code>
<p>
<p>Inheritance diagram for Xfc::G::StaticRecMutex:
<p><center><img src="structXfc_1_1G_1_1StaticRecMutex.png" usemap="#Xfc::G::StaticRecMutex_map" border="0" alt=""></center>
<map name="Xfc::G::StaticRecMutex_map">
<area href="classXfc_1_1G_1_1RecMutex.html" alt="Xfc::G::RecMutex" shape="rect" coords="0,56,140,80">
</map>
<a href="classXfc_1_1G_1_1StaticRecMutex-members.html">List of all members.</a><h2>Public Member Functions</h2>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<ul>
<li><a class="anchor" name="97ebe548498fdd42e4c6869e6815a550"></a><!-- doxytag: member="Xfc::G::StaticRecMutex::init" ref="97ebe548498fdd42e4c6869e6815a550" args="()" -->
void <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#97ebe548498fdd42e4c6869e6815a550">init</a> ()
<dl class="el"><dd class="mdescRight">Initializes a <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html">StaticRecMutex</a>. Alternatively you can initialize it with <a class="el" href="mutex_8hh.html#cabf71939dc270dd628165cafa8c1f7d">G::XFC_STATIC_REC_MUTEX_INIT</a>. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<ul>
<li><a class="anchor" name="54c6ab35250563246cb2e5c2b42154ad"></a><!-- doxytag: member="Xfc::G::StaticRecMutex::g_static_rec_mutex" ref="54c6ab35250563246cb2e5c2b42154ad" args="() const" -->
GStaticRecMutex * <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#54c6ab35250563246cb2e5c2b42154ad">g_static_rec_mutex</a> () const
<dl class="el"><dd class="mdescRight">Get a pointer to the GStaticRecMutex object. <br></dl><li><a class="anchor" name="a57b7021ed388dd06dcd3965be545234"></a><!-- doxytag: member="Xfc::G::StaticRecMutex::operator GStaticRecMutex *" ref="a57b7021ed388dd06dcd3965be545234" args="() const" -->
<a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#a57b7021ed388dd06dcd3965be545234">operator GStaticRecMutex *</a> () const
<dl class="el"><dd class="mdescRight">Conversion operator; Safely converts a <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html">G::StaticRecMutex</a> object into a GStaticRecMutex pointer. <br></dl><li><a class="anchor" name="111050f0aec7dc0c5dbe735684fba8ac"></a><!-- doxytag: member="Xfc::G::StaticRecMutex::is_locked" ref="111050f0aec7dc0c5dbe735684fba8ac" args="() const" -->
bool <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#111050f0aec7dc0c5dbe735684fba8ac">is_locked</a> () const
<dl class="el"><dd class="mdescRight">Returns true it the mutex is locked, that is, if its locked depth one or more. <br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Methods</div></td></tr>
<ul>
<li>void <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#6e2b58b8535e182dfd6ffb0239760721">lock</a> (unsigned int depth=1)
<dl class="el"><dd class="mdescRight">Locks the mutex.  <a href="#6e2b58b8535e182dfd6ffb0239760721"></a><br></dl><li>bool <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#a442208972e8feb2afc19497d535a49d">trylock</a> ()
<dl class="el"><dd class="mdescRight">Tries to lock the mutex.  <a href="#a442208972e8feb2afc19497d535a49d"></a><br></dl><li>void <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#df7aa0e0bd59bf05c2df3b52975d5019">unlock</a> ()
<dl class="el"><dd class="mdescRight">Unlocks the mutex one level.  <a href="#df7aa0e0bd59bf05c2df3b52975d5019"></a><br></dl><li>unsigned int <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#ad37ea280de42ff3500adc5d164545a5">unlock_full</a> ()
<dl class="el"><dd class="mdescRight">Unlocks the mutex completely.  <a href="#ad37ea280de42ff3500adc5d164545a5"></a><br></dl></ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A compile-time GStaticRecMutex C++ wrapper interface. 
<p>
A <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html">StaticRecMutex</a> works like a <a class="el" href="structXfc_1_1G_1_1StaticMutex.html">StaticMutex</a>, but it can be locked multiple times by one thread If you enter it n times, however, you have to unlock it n times again to let other threads lock it. An exception is the function <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#ad37ea280de42ff3500adc5d164545a5">unlock_full()</a>, that allows you to unlock a <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html">StaticRecMutex</a> completely returning the depth, i.e. the number of times this mutex was locked. The depth can later be used to restore the state by calling <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#6e2b58b8535e182dfd6ffb0239760721">lock()</a>.<p>
A <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html">StaticRecMutex</a> can be statically initialized with the value XFC_STATIC_REC_MUTEX_INIT. All of the <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html">StaticRecMutex</a> methods can be used if <a class="el" href="classXfc_1_1G_1_1Thread.html#8ebc56c3be96c382eea240242772fb97">G::Thread::init()</a> has not been called. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6e2b58b8535e182dfd6ffb0239760721"></a><!-- doxytag: member="Xfc::G::StaticRecMutex::lock" ref="6e2b58b8535e182dfd6ffb0239760721" args="(unsigned int depth=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::StaticRecMutex::lock           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>1</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks the mutex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>The number of times the mutex has to be unlocked to be completely unlocked.</td></tr>
  </table>
</dl>
If the mutex is already locked by another thread, the current thread will block until mutex is unlocked by the other thread. If mutex is already locked by the calling thread, this functions increases the depth of mutex <em>depth</em> times and returns. The default depth is one. 
</div>
</div><p>
<a class="anchor" name="a442208972e8feb2afc19497d535a49d"></a><!-- doxytag: member="Xfc::G::StaticRecMutex::trylock" ref="a442208972e8feb2afc19497d535a49d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xfc::G::StaticRecMutex::trylock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to lock the mutex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if the mutex could be locked.</dd></dl>
If mutex is already locked by another thread, it immediately returns false. Otherwise it locks mutex and returns true. If mutex is already locked by the calling thread, this functions increases the depth of mutex by one and immediately returns true. 
</div>
</div><p>
<a class="anchor" name="df7aa0e0bd59bf05c2df3b52975d5019"></a><!-- doxytag: member="Xfc::G::StaticRecMutex::unlock" ref="df7aa0e0bd59bf05c2df3b52975d5019" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xfc::G::StaticRecMutex::unlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlocks the mutex one level. 
<p>
Other threads can only lock the mutex when it has been unlocked as many times, as it had been locked before. If mutex is completely unlocked and another thread is blocked in a <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#6e2b58b8535e182dfd6ffb0239760721">lock()</a> call for mutex, it will be woken and can lock mutex itself. 
</div>
</div><p>
<a class="anchor" name="ad37ea280de42ff3500adc5d164545a5"></a><!-- doxytag: member="Xfc::G::StaticRecMutex::unlock_full" ref="ad37ea280de42ff3500adc5d164545a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Xfc::G::StaticRecMutex::unlock_full           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlocks the mutex completely. 
<p>
Other threads can only lock mutex when it has been unlocked as many times, as it had been locked before. If mutex is completely unlocked and another thread is blocked in a <a class="el" href="structXfc_1_1G_1_1StaticRecMutex.html#6e2b58b8535e182dfd6ffb0239760721">lock()</a> call for mutex, it will be woken and can lock mutex itself. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="mutex_8hh.html">mutex.hh</a></ul>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Xfce Foundation Classes</title>
  <meta content="The XFC Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body>
<hr style="width: 100%; height: 1px;" noshade="noshade">
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 33%; font-style: italic;"><font size="-1">Copyright
&copy; 2004-2005 The XFC
Development Team</font></td>
      <td style="width: 33%; text-align: right;"><font size="-1">XFC
4.3</font><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
